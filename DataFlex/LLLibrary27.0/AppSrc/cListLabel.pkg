// **********************************************************************************************************
// Header File for List & Label 27/26/25/24/23/22/21/20/19/18/17/16/15
// Author: Bernhard Ponemayr
// I give combit GmbH the right to freely use/make changes to this file without limitation.
//
// Notes: 
// Not all functions of List & Label are already implemented. 
// You may use this source on an "as is" basis on your own responsibility. I will give no support for it 
//
// Take care to read the Comments inside, the enclosed Sample and the Readme-File carefully. You will find
// valueable Informations at this Places.
// **********************************************************************************************************

// Important Notice for Updates from DataFlex <20.0 (pre Unicode) to DataFlex 20 and above
// If you are using any direct DLL Calls to List & Label (you can find them by searching LL*Ef) are using WStrings now.
// You have to change your calls to use Strings directly instead of the previously used Pointers to ANSI Strings and remove any OEM/ANSI Translations
// 
// If you are using any of the Functions
// 
// * DefinePointerVariable
// * DefinePointerField
// * DefineMemoryVariable
// * DefineMemoryField
// * LLDefineVariableExtHandle
// * LLDefineFieldExtHandle
//
// you have to make sure that the passed Handle is now a Handle pointing to a WString
//
// The Property piRtfObjectHandle (should only be rarely used) is changed to phRtfObjectHandle


#IFDEF USELLVERSION
#ELSE
Define USELLVERSION for 27
#ENDIF

#IF (USELLVERSION=15)
Define LLDllName for cmll15.dll
#ENDIF

#IF (USELLVERSION=16)
Define LLDllName for cmll16.dll
#ENDIF

#IF (USELLVERSION=17)
Define LLDllName for cmll17.dll
#ENDIF

#IF (USELLVERSION=18)
    #IFDEF Is$Win64
    Define LLDllName for cxll18.dll
    #ELSE
    Define LLDllName for cmll18.dll
    #ENDIF
#ENDIF

#IF (USELLVERSION=19)
    #IFDEF Is$Win64
    Define LLDllName for cxll19.dll
    #ELSE
    Define LLDllName for cmll19.dll
    #ENDIF
#ENDIF

#IF (USELLVERSION=20)
    #IFDEF Is$Win64
    Define LLDllName for cxll20.dll
    #ELSE
    Define LLDllName for cmll20.dll
    #ENDIF
#ENDIF

#IF (USELLVERSION=21)
    #IFDEF Is$Win64
    Define LLDllName for cxll21.dll
    #ELSE
    Define LLDllName for cmll21.dll
    #ENDIF
#ENDIF

#IF (USELLVERSION=22)
    #IFDEF Is$Win64
    Define LLDllName for cxll22.dll
    #ELSE
    Define LLDllName for cmll22.dll
    #ENDIF
#ENDIF

#IF (USELLVERSION=23)
    #IFDEF Is$Win64
    Define LLDllName for cxll23.dll
    #ELSE
    Define LLDllName for cmll23.dll
    #ENDIF
#ENDIF

#IF (USELLVERSION=24)
    #IFDEF Is$Win64
    Define LLDllName for cxll24.dll
    #ELSE
    Define LLDllName for cmll24.dll
    #ENDIF
#ENDIF

#IF (USELLVERSION=25)
    #IFDEF Is$Win64
    Define LLDllName for cxll25.dll
    #ELSE
    Define LLDllName for cmll25.dll
    #ENDIF
#ENDIF

#IF (USELLVERSION=26)
    #IFDEF Is$Win64
    Define LLDllName for cxll26.dll
    #ELSE
    Define LLDllName for cmll26.dll
    #ENDIF
#ENDIF

#IF (USELLVERSION=27)
    #IFDEF Is$Win64
    Define LLDllName for cxll27.dll
    #ELSE
    Define LLDllName for cmll27.dll
    #ENDIF
#ENDIF

// **********************************************************************************************************
// Defines the needed List & Label Constants
// **********************************************************************************************************

Define CMBTLANG_DEFAULT                                 FOR -1
Define CMBTLANG_GERMAN                                  FOR 0
Define CMBTLANG_ENGLISH                                 FOR 1
Define CMBTLANG_ARABIC                                  FOR 2
Define CMBTLANG_AFRIKAANS                               FOR 3
Define CMBTLANG_ALBANIAN                                FOR 4
Define CMBTLANG_BASQUE                                  FOR 5
Define CMBTLANG_BULGARIAN                               FOR 6
Define CMBTLANG_BYELORUSSIAN                            FOR 7
Define CMBTLANG_CATALAN                                 FOR 8
Define CMBTLANG_CHINESE                                 FOR 9
Define CMBTLANG_CROATIAN                                FOR 10
Define CMBTLANG_CZECH                                   FOR 11
Define CMBTLANG_DANISH                                  FOR 12
Define CMBTLANG_DUTCH                                   FOR 13
Define CMBTLANG_ESTONIAN                                FOR 14
Define CMBTLANG_FAEROESE                                FOR 15
Define CMBTLANG_FARSI                                   FOR 16
Define CMBTLANG_FINNISH                                 FOR 17
Define CMBTLANG_FRENCH                                  FOR 18
Define CMBTLANG_GREEK                                   FOR 19
Define CMBTLANG_HEBREW                                  FOR 20
Define CMBTLANG_HUNGARIAN                               FOR 21
Define CMBTLANG_ICELANDIC                               FOR 22
Define CMBTLANG_INDONESIAN                              FOR 23
Define CMBTLANG_ITALIAN                                 FOR 24
Define CMBTLANG_JAPANESE                                FOR 25
Define CMBTLANG_KOREAN                                  FOR 26
Define CMBTLANG_LATVIAN                                 FOR 27
Define CMBTLANG_LITHUANIAN                              FOR 28
Define CMBTLANG_NORWEGIAN                               FOR 29
Define CMBTLANG_POLISH                                  FOR 30
Define CMBTLANG_PORTUGUESE                              FOR 31
Define CMBTLANG_ROMANIAN                                FOR 32
Define CMBTLANG_RUSSIAN                                 FOR 33
Define CMBTLANG_SLOVAK                                  FOR 34
Define CMBTLANG_SLOVENIAN                               FOR 35
Define CMBTLANG_SERBIAN                                 FOR 36
Define CMBTLANG_SPANISH                                 FOR 37
Define CMBTLANG_SWEDISH                                 FOR 38
Define CMBTLANG_THAI                                    FOR 39
Define CMBTLANG_TURKISH                                 FOR 40
Define CMBTLANG_UKRAINIAN                               for 41
#IF (USELLVERSION>19)
Define CMBTLANG_SERBIAN_LATIN                           for 42
#ENDIF
Define CMBTLANG_CHINESE_TRADITIONAL                     FOR 48
Define CMBTLANG_PORTUGUESE_BRAZILIAN                    FOR 129
Define CMBTLANG_SPANISH_COLOMBIA                        FOR 130
Define CMBTLANG_UNSPECIFIED                             FOR 255    

Define LL_LINK_HPOS_NONE                                FOR |CI$0000            
Define LL_LINK_HPOS_START                               FOR |CI$0001            
Define LL_LINK_HPOS_END                                 FOR |CI$0002            
Define LL_LINK_HPOS_ABS                                 FOR |CI$0003            
Define LL_LINK_HPOS_MASK                                FOR |CI$0007            
Define LL_LINK_VPOS_NONE                                FOR |CI$0000            
Define LL_LINK_VPOS_START                               FOR |CI$0010            
Define LL_LINK_VPOS_END                                 FOR |CI$0020            
Define LL_LINK_VPOS_ABS                                 FOR |CI$0030            
Define LL_LINK_VPOS_MASK                                FOR |CI$0070            
Define LL_LINK_HSIZE_NONE                               FOR |CI$0000            
Define LL_LINK_HSIZE_PROP                               FOR |CI$0100            
Define LL_LINK_HSIZE_INV                                FOR |CI$0200            
Define LL_LINK_HSIZE_MASK                               FOR |CI$0300            
Define LL_LINK_VSIZE_NONE                               FOR |CI$0000            
Define LL_LINK_VSIZE_PROP                               FOR |CI$1000            
Define LL_LINK_VSIZE_INV                                FOR |CI$2000            
Define LL_LINK_VSIZE_MASK                               FOR |CI$3000            
Define LL_LINK_SIZEPOS_MASK                             FOR |CI$3377            
Define LL_LINK_SIZEOFPARENT                             for |CI$4000
Define LL_DESIGNERPRINTCALLBACK_PREVIEW_START           for 1
Define LL_DESIGNERPRINTCALLBACK_PREVIEW_ABORT           for 2
Define LL_DESIGNERPRINTCALLBACK_PREVIEW_FINALIZE        for 3
Define LL_DESIGNERPRINTCALLBACK_PREVIEW_QUEST_JOBSTATE  for 4
Define LL_DESIGNERPRINTCALLBACK_EXPORT_START            for 5
Define LL_DESIGNERPRINTCALLBACK_EXPORT_ABORT            for 6
Define LL_DESIGNERPRINTCALLBACK_EXPORT_FINALIZE         for 7
Define LL_DESIGNERPRINTCALLBACK_EXPORT_QUEST_JOBSTATE   for 8
Define LL_DESIGNERPRINTTHREAD_STATE_STOPPED             for 0
Define LL_DESIGNERPRINTTHREAD_STATE_SUSPENDED           for 1
Define LL_DESIGNERPRINTTHREAD_STATE_RUNNING             for 2
Define LL_DRILLDOWN_START                               for 1
Define LL_DRILLDOWN_FINALIZE                            for 2
Define LL_JOBOPENFLAG_NOLLXPRELOAD                      for |CI$00001000
Define LL_JOBOPENFLAG_ONLYEXACTLANGUAGE                 for |CI$00002000        // do not look for '@@' LNG file
Define LL_DEBUG_CMBTLL                                  FOR |CI$0001            // debug CMBTLLnn.DLL
Define LL_DEBUG_CMBTDWG                                 FOR |CI$0002            // debug CMBTDWGnn.DLL
Define LL_DEBUG_CMBTLS                                  for |CI$0080            // debug CMBTLSnn.DLL
Define LL_DEBUG_PRNINFO                                 for |CI$0100            // debug basic printer operations
Define LL_DEBUG_CMBTLL_NOCALLBACKS                      FOR |CI$0004
Define LL_DEBUG_CMBTLL_NOSTORAGE                        FOR |CI$0008
Define LL_DEBUG_CMBTLL_NOWAITDLG                        FOR |CI$0010
Define LL_DEBUG_CMBTLL_NOSYSINFO                        FOR |CI$0020
Define LL_DEBUG_CMBTLL_LOGTOFILE                        for |CI$0040
#IF (USELLVERSION>15)
Define LL_DEBUG_CMBTLL_LICINFO                          for |CI$0200            // issue LIC messages
#ENDIF
#IF (USELLVERSION>19)
Define LL_DEBUG_CMBTLL_OBJECTSTATES                     for |CI$0400            // issue Object states after drawing (realdata printing only)
Define LL_DEBUG_NOPRIVACYDATA                           for |CI$0800            // suppress Field contents (useful If they might contain private data)
Define LL_DEBUG_FORCE_SYSINFO                           for |CI$1000            // issue sysinfo even though it has been issued once already
Define LL_DEBUG_EVAL2HOSTEXPRESSION                     for |CI$2000            // debug Eval2HostExpr processing 
Define LL_DEBUG_EXTENDED_DEBWINFLAGS                    for |CI$80000000        // internal usage
#ENDIF
Define LL_VERSION_MAJOR                                 FOR 1                   // direct return Of major version (f.ex. 1)
Define LL_VERSION_MINOR                                 FOR 2                   // direct return Of minor version (f.ex. 13)
Define LL_CMND_DRAW_USEROBJ                             FOR 0                   // callback FOR LL_DRAWING_USEROBJ
Define LL_CMND_EDIT_USEROBJ                             FOR 1                   // callback FOR LL_DRAWING_USEROBJ_DLG
Define LL_CMND_GETSIZE_USEROBJ                          FOR 2
Define LL_CMND_GETSIZE_USEROBJ_SCM                      for 3
Define LL_CMND_GETSIZE_USEROBJ_PIXEL                    for 4
Define LL_CMND_TABLELINE                                FOR 10                  // callback FOR LL_CB_TABLELINE
Define LL_TABLE_LINE_HEADER                             FOR 0
Define LL_TABLE_LINE_BODY                               FOR 1
Define LL_TABLE_LINE_FOOTER                             FOR 2
Define LL_TABLE_LINE_FILL                               FOR 3
Define LL_TABLE_LINE_GROUP                              FOR 4
Define LL_TABLE_LINE_GROUPFOOTER                        FOR 5
Define LL_CMND_TABLEFIELD                               FOR 11                  // callback FOR LL_CB_TABLEFIELD
Define LL_TABLE_FIELD_HEADER                            FOR 0
Define LL_TABLE_FIELD_BODY                              FOR 1
Define LL_TABLE_FIELD_FOOTER                            FOR 2
Define LL_TABLE_FIELD_FILL                              FOR 3
Define LL_TABLE_FIELD_GROUP                             FOR 4
Define LL_TABLE_FIELD_GROUPFOOTER                       FOR 5
Define LL_CMND_EVALUATE                                 FOR 12                  // callback FOR "External$" Function
Define LL_CMND_OBJECT                                   FOR 20                  // callback Of LL_CB_OBJECT
Define LL_CMND_PAGE                                     FOR 21                  // callback Of LL_CB_PAGE
Define LL_CMND_PROJECT                                  FOR 22                  // callback Of LL_CB_PROJECT
Define LL_CMND_DRAW_GROUP_BEGIN                         FOR 23                  // callback FOR LlPrintBeginGroup
Define LL_CMND_DRAW_GROUP_END                           FOR 24                  // callback FOR LlPrintEndGroup
Define LL_CMND_DRAW_GROUPLINE                           FOR 25                  // callback FOR LlPrintGroupLine
Define LL_RSP_GROUP_IMT                                 FOR 0
Define LL_RSP_GROUP_NEXTPAGE                            FOR 1
Define LL_RSP_GROUP_OK                                  FOR 2
Define LL_RSP_GROUP_DRAWFOOTER                          FOR 3
Define LL_CMND_HELP                                     FOR 30                  // lParam: HIWORD=HELP_xxx, LOWORD=Context #
Define LL_CMND_ENABLEMENU                               FOR 31                  // undoc: lParam/LOWORD(lParam) = HMENU
Define LL_CMND_MODIFYMENU                               FOR 32                  // undoc: lParam/LOWORD(lParam) = HMENU
Define LL_CMND_SELECTMENU                               FOR 33                  // undoc: lParam=ID (return TRUE If processed)
Define LL_CMND_GETVIEWERBUTTONSTATE                     FOR 34                  // HIWORD(lParam)=ID, LOWORD(lParam)=state
Define LL_CMND_VARHELPTEXT                              FOR 35                  // lParam=LPSTR(Name), Returns LPSTR(Helptext)
Define LL_INFO_METER                                    FOR 37                  // lParam = addr(scLlMeterInfo)
Define LL_METERJOB_LOAD                                 FOR 1
Define LL_METERJOB_SAVE                                 FOR 2
Define LL_METERJOB_CONSISTENCYCHECK                     for 3
Define LL_METERJOB_PASS2                                for 4
Define LL_METERJOB_PASS3                                for 5
Define LL_NTFY_FAILSFILTER                              FOR 1000                // data Set fails filter expression
Define LL_NTFY_VIEWERBTNCLICKED                         FOR 38                  // user presses a preview button (action will be done). lParam=ID. result: 0=allowed, 1=Not allowed
Define LL_CMND_DLGEXPR_VARBTN                           FOR 39                  // lParam: @scLlDlgExprVarExt, return: IDOK FOR ok
Define LL_CMND_HOSTPRINTER                              FOR 40                  // lParam: scLlPrinter
Define LL_PRN_CREATE_DC                                 FOR 1                   // scLlPrinter._nCmd values
Define LL_PRN_DELETE_DC                                 FOR 2
Define LL_PRN_SET_ORIENTATION                           FOR 3
Define LL_PRN_GET_ORIENTATION                           FOR 4
Define LL_PRN_EDIT                                      FOR 5                   // unused
Define LL_PRN_GET_DEVICENAME                            FOR 6
Define LL_PRN_GET_DRIVERNAME                            FOR 7
Define LL_PRN_GET_PORTNAME                              FOR 8
Define LL_PRN_RESET_DC                                  FOR 9
Define LL_PRN_COMPARE_PRINTER                           FOR 10
Define LL_PRN_GET_PHYSPAGE                              FOR 11
Define LL_PRN_SET_PHYSPAGE                              FOR 12
Define LL_PRN_GET_PAPERFORMAT                           FOR 13                  // fill _nPaperFormat
Define LL_PRN_SET_PAPERFORMAT                           FOR 14                  // _nPaperFormat, _xPaperSize, _yPaperSize
Define LL_OEM_TOOLBAR_START                             FOR 41
Define LL_OEM_TOOLBAR_END                               FOR 50
Define LL_NTFY_EXPRERROR                                FOR 51                  // lParam = LPCSTR(error text)
Define LL_CMND_CHANGE_DCPROPERTIES_CREATE               FOR 52                  // lParam = addr(scLlPrinter), _hDC is valid
Define LL_CMND_CHANGE_DCPROPERTIES_DOC                  FOR 53                  // lParam = addr(scLlPrinter), _hDC is valid
Define LL_CMND_CHANGE_DCPROPERTIES_PAGE                 FOR 54                  // lParam = addr(scLlPrinter), _hDC is valid
Define LL_CMND_CHANGE_DCPROPERTIES_PREPAGE              FOR 56                  // lParam = addr(scLlPrinter), _hDC and _pszBuffer( DEVMODE* ) are valid
Define LL_CMND_MODIFY_METAFILE                          FOR 57                  // lParam = Handle Of metafile (32 bit: enh. metafile)
Define LL_INFO_PRINTJOBSUPERVISION                      FOR 58                  // lParam = addr(scLlPrintJobInfo) 
Define LL_CMND_DELAYEDVALUE                             FOR 59                  // lParam = addr(scLlDelayedValue)
Define LL_CMND_SUPPLY_USERDATA                          FOR 60                  // lParam = addr(scLlProjectUserData)
Define LL_CMND_SAVEFILENAME                             FOR 61                  // lParam = LPCTSTR(Filename)
Define LL_QUERY_IS_VARIABLE_OR_FIELD                    for 62                  // lParam = addr(scLlDelayDefineFieldOrVariable), must be enabled by CB mask. If Returns TRUE, the var must be defined In the callback... */
Define LL_NTFY_PROJECTLOADED                            for 63                  // lParam = 0
Define LL_QUERY_DESIGNERACTIONSTATE                     for 64                  // 
Define LL_NTFY_DESIGNERREADY                            for 65                  // lParam = 0
Define LL_NTFY_DESIGNERPRINTJOB                         for 66
Define LL_NTFY_VIEWERDRILLDOWN                          for 67
Define LL_NTFY_QUEST_DRILLDOWNDENIED                    for 68                  // see LS_VIEWERCONTROL_QUEST_DRILLDOWNDENIED
Define LL_QUERY_DRILLDOWN_ADDITIONAL_BASETABLES_FOR_VARIABLES for 69            // lParam = scLlDDFilterInfo* 
Define LL_QUERY_DRILLDOWN_ADDITIONAL_TABLES             for 70                  // lParam = scLlDDFilterInfo* 
Define LL_NTFY_DRILLDOWN_DESIGNERACTION                 for 71                  // lParam = scLlDDDesignerActionW*
Define LL_NTFY_INPLACEDESIGNER_START                    for 72
Define LL_NTFY_INPLACEDESIGNER_END                      for 73
Define LL_QUERY_OWN_MENU                                for 74                  // lParam = HMENU -> return 1 If uses own menu
Define LL_CMND_UPDATE_MENU                              for 75
Define LL_NTFY_FRAMEHANDLE                              for 76                  // lParam -> Handle of layout window ("L&LFrame")
Define LL_QUERY_DEFAULTPROJECTSTREAM                    for 77                  // lParam -> IStream**. Return NONZERO when stream contains data 
#IF (USELLVERSION>18)
Define LL_NTFY_QUEST_RP_REALDATAJOBDENIED               for 78
Define LL_NTFY_QUEST_EXPANDABLEREGIONSJOBDENIED         for 79
Define LL_NTFY_QUEST_INTERACTIVESORTINGJOBDENIED        for 80
#ENDIF
#IF (USELLVERSION>19)
Define LL_QUERY_EXPR2HOSTEXPRESSION                     for 81                  // lParam = LLEXPR2HOSTEXPR*, return 0 for FAIL, 1 for OPTIMAL, 2 for INEXACT
Define LL_NTFY_REPORTPARAMETERS_COLLECTED               for 82                  // lParam = &scNtfyReportparametersCollected, return LL_ERR_USER_ABORTED to Abort, 0x01 to Get RP stream, 0x02 to Get RP contents, 0 to leave processing
Define LL_NTFY_EXPORTERPAGEFINISHED                     for 83                  // lParam = &scNtfyExporterPageFinished
Define LL_NTFY_HYPERLINK                                for 84                  // lParam = &scNtfyHyperlink
#ENDIF
#IF (USELLVERSION>21)
Define LL_NTFY_SAVEREPORTSTATEITEM                      for 85                  // lParam = &scLLNtfyReportStateItem
Define LL_NTFY_RESTOREREPORTSTATEITEM                   for 86                  // lParam = &scLLNtfyReportStateItem
Define LL_NTFY_PROGRESS                                 for 87                  // lParam -> percentage of current progress
Define LL_NTFY_TRIGGEREDJOBINUITHREAD                   for 88                  // lParam -> user data
Define LL_NTFY_PLEASE_TRANSLATE                         for 89                  // lParam=BSTR*
Define LL_NTFY_PREVIEW_PRINT_START                      for 99                  // lParam = &scViewerControlPrintData, return 1 to Abort Print 
Define LL_NTFY_PREVIEW_PRINT_PAGE                       for 100                 // lParam = &scViewerControlPrintData, return 1 to Abort Loop
Define LL_NTFY_PREVIEW_PRINT_END                        for 101                 // lParam = &scViewerControlPrintData 
Define LL_NTFY_EMF_PAGE                                 for 102                 // lParam = &scLLNtfyEMF 
Define LL_QUERY_FILENAME_FOR_EXPORTJOB                  for 103                 // lParam = Variant* (in: old filename, out:new filename) 
#ENDIF
#IF (USELLVERSION>23)
Define LL_QUERY_OBJECT_NOT_SUPPORTED                    for 104                 // lParam = &scLLQueryObjectAllowed
Define LL_QUERY_REPLACE_FILESYSTEMITEM                  for 105                 // lParam = &scLLQueryFilenameReplacement -> return 1 If replaced
Define LL_QUERY_HOSTIMPORT                              for 106                 // lParam = &scLlNtfyHostImport -> return 1 If LL's internal routine is superseded
Define LL_NTFY_PREVIEW_ACTIONRESULT                     for 107                 // see LS_VIEWERCONTROL_NTFY_ACTIONRESULT - for RealDataPreview 
Define LL_NTFY_DATA_LOSS                                for 108                 // lParam = LL_NTFYDATALOSS_XXX
Define LL_NTFYDATALOSS_RTFDETECTION_NOT_ENOUGH_SPACE    for 1
Define LL_NTFY_REPORTPARAMETERS_COLLECTION_FINISHED     for 109                 // lParam and result: see LL_NTFY_REPORTPARAMETERS_COLLECTED
Define LL_NTFY_EXPRERROR_EX                             for 110                 // lParam = @scLlNtfyExprErrorEx
Define LL_NTFY_EXPORTERPAGECOUNT                        for 111                 // lParam = &scLLNtfyExporterPageCount
#ENDIF
#IF (USELLVERSION>24)
Define LL_NTFY_FIND_AND_REPLACE                         for 112                 // lParam = &scLLNtfyFindAndReplace, Returns: 0 to replace, 1 to skip, 2 to cancel search globally
Define LL_NTFY_PROJECTLOAD_EX                           for 113                 // lParam = &scLLNtfyProjectLoadEx, called before a project is loaded. SetErrortext to Abort loading.
Define LL_NTFY_JOBWILLCHANGE                            for 114                 // internal 
#ENDIF
#IF (USELLVERSION>25)
Define LL_NTFY_COMBINATIONPRINTSTEP                     for 115                 // lParam = &scLlCombinationPrintStep, return 0 on OK, error code on error */
#ENDIF

Define LL_PROJECT_LABEL                                 for 1                   // new names...
Define LL_PROJECT_LIST                                  FOR 2
Define LL_PROJECT_CARD                                  for 3
Define LL_PROJECT_TOC                                   for 4
Define LL_PROJECT_IDX                                   for 5
Define LL_PROJECT_GTC                                   for 6
Define LL_PROJECT_LAST                                  for 6
Define LL_PROJECT_MASK                                  for |CI$000f
Define LL_OBJ_MARKER                                    FOR 0                   // internal Use only
Define LL_OBJ_TEXT                                      FOR 1                   // the following are used In the Object callback
Define LL_OBJ_RECT                                      FOR 2
Define LL_OBJ_LINE                                      FOR 3
Define LL_OBJ_BARCODE                                   FOR 4
Define LL_OBJ_DRAWING                                   FOR 5
Define LL_OBJ_TABLE                                     FOR 6
Define LL_OBJ_TEMPLATE                                  FOR 7
Define LL_OBJ_ELLIPSE                                   FOR 8
Define LL_OBJ_GROUP                                     FOR 9                   // internal Use only
Define LL_OBJ_RTF                                       FOR 10
Define LL_OBJ_LLX                                       FOR 11
Define LL_OBJ_INPUT                                     FOR 12
Define LL_OBJ_LAST                                      for 12                  // last Object type (FOR loops as upper bound) - If this is changed, change the contants In Object.c too!
#IF (USELLVERSION>19) 
Define LL_OBJ_REPORTCONTAINER                           for 253                 // for exporter
#ENDIF
Define LL_OBJ_PROJECT                                   FOR 254                 // FOR exporter
Define LL_OBJ_PAGE                                      FOR 255                 // FOR exporter
Define LL_DELAYEDVALUE                                  FOR |CI$80000000
Define LL_TYPEMASK                                      for |CI$7FFF0000
Define LL_TABLE_FOOTERFIELD                             FOR |CI$00008000        // 'or'ed FOR footline-only fields // reserved also for Variables (see "$$xx$$")!!!!
Define LL_TABLE_GROUPFIELD                              FOR |CI$00004000        // 'or'ed FOR groupline-only fields
Define LL_TABLE_HEADERFIELD                             FOR |CI$00002000        // 'or'ed FOR headline-only fields
Define LL_TABLE_BODYFIELD                               FOR |CI$00001000        // 'or'ed FOR headline-only fields
Define LL_TABLE_GROUPFOOTERFIELD                        FOR |CI$00000800        // 'or'ed FOR group-footer-line-only fields
Define LL_TABLE_FIELDTYPEMASK                           for |CI$0000F800        // internal Use
#IF (USELLVERSION>19)
Define LL_TYPEFLAGS                                     for |CI$8000f800
Define LL_SUBTYPEMASK                                   for |CI$000007ff
#ENDIF
Define LL_BARCODE                                       FOR |CI$40000000        
Define LL_BARCODE_EAN13                                 FOR |CI$40000000        
Define LL_BARCODE_EAN8                                  for |CI$40000001        
Define LL_BARCODE_GTIN13                                for |CI$40000000
Define LL_BARCODE_GTIN8                                 for |CI$40000001
Define LL_BARCODE_UPCA                                  FOR |CI$40000002        
Define LL_BARCODE_UPCE                                  FOR |CI$40000003        
Define LL_BARCODE_3OF9                                  FOR |CI$40000004        
Define LL_BARCODE_25INDUSTRIAL                          FOR |CI$40000005        
Define LL_BARCODE_25INTERLEAVED                         FOR |CI$40000006        
Define LL_BARCODE_25DATALOGIC                           FOR |CI$40000007        
Define LL_BARCODE_25MATRIX                              FOR |CI$40000008        
Define LL_BARCODE_POSTNET                               FOR |CI$40000009        
Define LL_BARCODE_FIM                                   FOR |CI$4000000A        
Define LL_BARCODE_CODABAR                               FOR |CI$4000000B        
Define LL_BARCODE_EAN128                                for |CI$4000000C
Define LL_BARCODE_GS1_128                               for |CI$4000000C
Define LL_BARCODE_CODE128                               FOR |CI$4000000D        
Define LL_BARCODE_DP_LEITCODE                           FOR |CI$4000000E        
Define LL_BARCODE_DP_IDENTCODE                          FOR |CI$4000000F        
Define LL_BARCODE_GERMAN_PARCEL                         FOR |CI$40000010        
Define LL_BARCODE_CODE93                                FOR |CI$40000011        
Define LL_BARCODE_MSI                                   FOR |CI$40000012        
Define LL_BARCODE_CODE11                                FOR |CI$40000013        
Define LL_BARCODE_MSI_10_CD                             FOR |CI$40000014        
Define LL_BARCODE_MSI_10_10                             FOR |CI$40000015        
Define LL_BARCODE_MSI_11_10                             FOR |CI$40000016        
Define LL_BARCODE_MSI_PLAIN                             FOR |CI$40000017        
Define LL_BARCODE_EAN14                                 FOR |CI$40000018        
Define LL_BARCODE_UCC14                                 FOR |CI$40000019        
Define LL_BARCODE_CODE39                                FOR |CI$4000001A        
Define LL_BARCODE_CODE39_CRC43                          FOR |CI$4000001B
Define LL_BARCODE_PZN                                   FOR |CI$4000001C        
Define LL_BARCODE_CODE39_EXT                            FOR |CI$4000001D        
Define LL_BARCODE_JAPANESE_POSTAL                       FOR |CI$4000001E        
Define LL_BARCODE_RM4SCC                                FOR |CI$4000001F        
Define LL_BARCODE_RM4SCC_CRC                            FOR |CI$40000020        
Define LL_BARCODE_SSCC                                  for |CI$40000021
Define LL_BARCODE_ISBN                                  for |CI$40000022
Define LL_BARCODE_GS1                                   for |CI$40000023
Define LL_BARCODE_GS1_TRUNCATED                         for |CI$40000024
Define LL_BARCODE_GS1_STACKED                           for |CI$40000025
Define LL_BARCODE_GS1_STACKED_OMNI                      for |CI$40000026
Define LL_BARCODE_GS1_LIMITED                           for |CI$40000027
Define LL_BARCODE_GS1_EXPANDED                          for |CI$40000028
#IF (USELLVERSION>15)
Define LL_BARCODE_INTELLIGENT_MAIL                      for |CI$40000029
#ENDIF
#IF (USELLVERSION>17)
Define LL_BARCODE_PZN8                                  for |CI$4000002A
#ENDIF
#IF (USELLVERSION>19)
Define LL_BARCODE_CODE128_FULL                          for |CI$4000002B
Define LL_BARCODE_EAN128_FULL                           for |CI$4000002C
#ENDIF
#IF (USELLVERSION>21)
Define LL_BARCODE_CODABLOCK_F                           for |CI$4000002D
#ENDIF
Define LL_BARCODE_LLXSTART                              FOR |CI$40000040        
Define LL_BARCODE_PDF417                                FOR |CI$40000040        
Define LL_BARCODE_MAXICODE                              FOR |CI$40000041        
Define LL_BARCODE_MAXICODE_UPS                          FOR |CI$40000042        
Define LL_BARCODE_DATAMATRIX                            FOR |CI$40000044        
Define LL_BARCODE_AZTEC                                 FOR |CI$40000045        
Define LL_BARCODE_QRCODE                                for |CI$40000046
#IF (USELLVERSION>19)
Define LL_BARCODE_DATAMATRIX_PREMIUMADRESS              for |CI$40000047
#ENDIF
#IF (USELLVERSION>21)
Define LL_BARCODE_MICROPDF417                           for |CI$40000048
#ENDIF
Define LL_BARCODE_METHODMASK                            FOR |CI$000000ff        
Define LL_BARCODE_WITHTEXT                              FOR |CI$00000100        
Define LL_BARCODE_WITHOUTTEXT                           FOR |CI$00000200        
Define LL_BARCODE_TEXTDONTCARE                          FOR |CI$00000000
Define LL_DRAWING                                       FOR |CI$20000000
Define LL_DRAWING_HMETA                                 FOR |CI$20000001
Define LL_DRAWING_USEROBJ                               FOR |CI$20000002
Define LL_DRAWING_USEROBJ_DLG                           FOR |CI$20000003
Define LL_DRAWING_HBITMAP                               FOR |CI$20000004
Define LL_DRAWING_HICON                                 FOR |CI$20000005
Define LL_DRAWING_HEMETA                                FOR |CI$20000006
Define LL_DRAWING_HDIB                                  FOR |CI$20000007        // global Handle to BITMAPINFO And bits
Define LL_DRAWING_METHODMASK                            FOR |CI$000000FF
Define LL_META_MAXX                                     FOR 10000
Define LL_META_MAXY                                     FOR 10000
Define LL_TEXT                                          FOR |CI$10000000
Define LL_TEXT_ALLOW_WORDWRAP                           FOR |CI$10000000
Define LL_TEXT_DENY_WORDWRAP                            FOR |CI$10000001
Define LL_TEXT_FORCE_WORDWRAP                           FOR |CI$10000002
Define LL_NUMERIC                                       FOR |CI$08000000
Define LL_NUMERIC_LOCALIZED                             for |CI$08000001
Define LL_NUMERIC_INTEGER                               for |CI$08000002        // flag
Define LL_DATE                                          FOR |CI$04000000        // LL's own julian
Define LL_DATE_DELPHI_1                                 FOR |CI$04000001
Define LL_DATE_DELPHI                                   FOR |CI$04000002        // DELPHI 2, 3, 4: OLE Date
Define LL_DATE_MS                                       FOR |CI$04000002        // MS C/Basic: OLE Date
Define LL_DATE_OLE                                      FOR |CI$04000002        // generic: OLE Date
Define LL_DATE_VFOXPRO                                  FOR |CI$04000003        // nearly LL's own julian, has an offset of 1!
Define LL_DATE_DMY                                      FOR |CI$04000004        // <d><sep><m><sep><yyyy>. Year MUST be 4 digits!
Define LL_DATE_MDY                                      FOR |CI$04000005        // <m><sep><d><sep><yyyy>. Year MUST be 4 digits!
Define LL_DATE_YMD                                      FOR |CI$04000006        // <yyyy><sep><m><sep><d>. Year MUST be 4 digits!
Define LL_DATE_YYYYMMDD                                 FOR |CI$04000007        // <yyyymmdd>
Define LL_DATE_LOCALIZED                                FOR |CI$04000008        // localized (automatic VariantConversion)
Define LL_DATE_JULIAN                                   FOR |CI$04000009        // Variant 'date' is a julian Date 
Define LL_DATE_CLARION                                  FOR |CI$0400000A        // days since 1800-12-28 (what's so special about that day?)
Define LL_DATE_YMD_AUTO                                 FOR |CI$04000010        // wither DMY, MDY Or YMD, automatically detected
Define LL_DATE_METHODMASK                               FOR |CI$000000FF
Define LL_BOOLEAN                                       FOR |CI$02000000
Define LL_RTF                                           FOR |CI$01000000
Define LL_HTML                                          FOR |CI$00800000
Define LL_LLXOBJECT                                     for |CI$00100000        // internal Use only
#IF (USELLVERSION>21)
Define LL_SUBTABLELIST                                  for |CI$00080000        // internal Use only
#ENDIF
#IF (USELLVERSION>19) 
Define LL_FIXEDNAME                                     for |CI$00008000
Define LL_NOSAVEAS                                      for |CI$00004000
Define LL_EXPRCONVERTQUIET                              for |CI$00001000            // convert to new expressions without warning box
Define LL_NONAMEINTITLE                                 for |CI$00000800            // no file name appended to title
Define LL_DESIGNER_OVER_CHILD                           for |CI$00002000
#ELSE
Define LL_FIXEDNAME                                     for |CI$8000
Define LL_NOSAVEAS                                      for |CI$4000
Define LL_EXPRCONVERTQUIET                              for |CI$1000            // convert to new expressions without warning box
Define LL_NONAMEINTITLE                                 for |CI$0800            // no file name appended to title
#ENDIF
#IF (USELLVERSION>20)
Define LL_SUBTABLELIST                                  for |CI$00080000        // internal use only
#ENDIF
Define LL_PRVOPT_PRN_USEDEFAULT                         FOR |CI$00000000
Define LL_PRVOPT_PRN_ASKPRINTERIFNEEDED                 FOR |CI$00000001
Define LL_PRVOPT_PRN_ASKPRINTERALWAYS                   FOR |CI$00000002
Define LL_PRVOPT_PRN_ALWAYSUSEDEFAULT                   FOR |CI$00000003
Define LL_PRVOPT_PRN_ASSIGNMASK                         for |CI$00000003        // used by List & Label
#IF (USELLVERSION>18)
Define LL_PRVOPT_FLAG_STANDALONEVIEWER                  for |CI$00000010
#ENDIF
Define LL_OPTION_COPIES                                 FOR 0                   // compatibility only, please Use LL_PRNOPT_...
Define LL_OPTION_STARTPAGE                              FOR 1                   // compatibility only, please Use LL_PRNOPT_PAGE
Define LL_OPTION_PAGE                                   FOR 1                   // compatibility only, please Use LL_PRNOPT_...
Define LL_OPTION_OFFSET                                 FOR 2                   // compatibility only, please Use LL_PRNOPT_...
Define LL_OPTION_COPIES_SUPPORTED                       FOR 3                   // compatibility only, please Use LL_PRNOPT_...
Define LL_OPTION_FIRSTPAGE                              FOR 5                   // compatibility only, please Use LL_PRNOPT_...
Define LL_OPTION_LASTPAGE                               FOR 6                   // compatibility only, please Use LL_PRNOPT_...
Define LL_OPTION_JOBPAGES                               FOR 7                   // compatibility only, please Use LL_PRNOPT_...
Define LL_OPTION_PRINTORDER                             FOR 8                   // compatibility only, please Use LL_PRNOPT_...
Define LL_PRNOPT_COPIES                                 FOR 0
Define LL_COPIES_HIDE                                   FOR -32768              // anything negative...
Define LL_PRNOPT_STARTPAGE                              FOR 1
Define LL_PRNOPT_PAGE                                   FOR 1                   // alias; please do Not Use STARTPAGE any more...
Define LL_PAGE_HIDE                                     FOR -32768              // must be exactly this value!
Define LL_PRNOPT_OFFSET                                 FOR 2
Define LL_PRNOPT_COPIES_SUPPORTED                       FOR 3
Define LL_PRNOPT_UNITS                                  FOR 4                   // r/o
Define LL_UNITS_MM_DIV_10                               FOR 0                   // FOR LL_PRNOPT_UNITS, LL_OPTION_UNITS And LL_OPTION_UNITS_DEFAULT
Define LL_UNITS_INCH_DIV_100                            FOR 1
Define LL_UNITS_INCH_DIV_1000                           FOR 2
Define LL_UNITS_SYSDEFAULT_LORES                        FOR 3                   // mm/10, In/100 (depending on regional settings Of the system)
Define LL_UNITS_SYSDEFAULT                              FOR 4                   // mm/100, In/1000 (depending on regional settings Of the system)
Define LL_UNITS_MM_DIV_100                              FOR 5
Define LL_UNITS_MM_DIV_1000                             FOR 6
Define LL_UNITS_SYSDEFAULT_HIRES                        FOR 7                   // mm/100, In/1000 (depending on regional settings Of the system) 
Define LL_PRNOPT_FIRSTPAGE                              FOR 5
Define LL_PRNOPT_LASTPAGE                               FOR 6
Define LL_PRNOPT_JOBPAGES                               FOR 7
Define LL_PRNOPT_PRINTORDER                             FOR 8
Define LL_PRINTORDER_HORZ_LTRB                          FOR 0
Define LL_PRINTORDER_VERT_LTRB                          FOR 1
Define LL_PRINTORDER_HORZ_RBLT                          FOR 2
Define LL_PRINTORDER_VERT_RBLT                          FOR 3
Define LL_PRNOPT_DEFPRINTERINSTALLED                    FOR 11                  // Returns 0 FOR no default printer, 1 FOR default printer present
Define LL_PRNOPT_PRINTDLG_DESTMASK                      FOR 12                  // any combination Of the ones below... Default: all. Outdated, please Use LL_OPTIONSTR_EXPORTS_ALLOWED
Define LL_DESTINATION_PRN                               FOR 1
Define LL_DESTINATION_PRV                               FOR 2
Define LL_DESTINATION_FILE                              FOR 4
Define LL_DESTINATION_EXTERN                            FOR 8
Define LL_DESTINATION_MSFAX                             FOR 16                  // reserved
Define LL_PRNOPT_PRINTDLG_DEST                          FOR 13                  // default destination; outdated, please Use LL_PRNOPTSTR_EXPORT
Define LL_PRNOPT_PRINTDLG_ONLYPRINTERCOPIES             FOR 14                  // show copies option In dialog only If they are supported by the printer. default: FALSE
Define LL_PRNOPT_JOBID                                  FOR 17
Define LL_PRNOPT_PAGEINDEX                              FOR 18
Define LL_PRNOPT_USES2PASS                              FOR 19                  // r/o
Define LL_PRNOPT_PAGERANGE_USES_ABSOLUTENUMBER          FOR 20                  // default: FALSE 
Define LL_PRNOPT_USEMEMORYMETAFILE                      FOR 22                  // default: False 
Define LL_PRNOPT_PARTIALPREVIEW                         for 23                  // default: False
#IF (USELLVERSION>19) 
Define LL_PRNOPT_ADDITIONALPAGES_FOR_TOTAL              for 24                  // internal
Define LL_PRNOPT_HAS_TOTALPAGES                         for 25                  // internal
#ENDIF
#IF (USELLVERSION>25)
Define LL_PRNOPT_COUNT_OF_ITEMS                         for 26                  // labels/cards
Define LL_PRNOPT_IS_PREPROCESSING                       for 27                  // 
Define LL_PRNOPT_PRINTDLG_ALLOW_NUMBER_OF_FIRST_PAGE    for 28                  //
Define LL_PRNOPT_NEXT_INDEX                             for 29                  //
#ENDIF
Define LL_PRNOPTSTR_PRINTDST_FILENAME                   FOR 0                   // print to file: default filename (LlGet/SetPrintOptionString)
Define LL_PRNOPTSTR_EXPORTDESCR                         FOR 1                   // r/o, Returns the description Of the export chosen
Define LL_PRNOPTSTR_EXPORT                              FOR 2                   // sets default exporter to Use / Returns the name Of the export chosen
Define LL_PRNOPTSTR_PRINTJOBNAME                        FOR 3                   // Set name to be given to StartDoc() (lpszMessage Of LlPrintWithBoxStart()
Define LL_PRNOPTSTR_PRESTARTDOCESCSTRING                FOR 4                   // sent before StartDoc()
Define LL_PRNOPTSTR_POSTENDDOCESCSTRING                 FOR 5                   // sent after EndDoc()
Define LL_PRNOPTSTR_PRESTARTPAGEESCSTRING               FOR 6                   // sent before StartPage()
Define LL_PRNOPTSTR_POSTENDPAGEESCSTRING                FOR 7                   // sent after EndPage()
Define LL_PRNOPTSTR_PRESTARTPROJECTESCSTRING            FOR 8                   // sent before first StartPage() Of project 
Define LL_PRNOPTSTR_POSTENDPROJECTESCSTRING             FOR 9                   // sent after last EndPage() Of project
Define LL_PRNOPTSTR_PAGERANGES                          for 10
Define LL_PRNOPTSTR_ISUSERANGES                         for 11
#IF (USELLVERSION>25)
Define LL_PRNOPTSTR_PREVIEWTITLE                        for 12                  // default: language dependent
Define LL_PRNOPTSTR_NEXT_INDEX                          for 13                  //
#ENDIF
Define LL_PRINT_V1POINTX                                FOR |CI$00000000        
Define LL_PRINT_NORMAL                                  FOR |CI$00000100        
Define LL_PRINT_PREVIEW                                 FOR |CI$00000200        
Define LL_PRINT_STORAGE                                 FOR |CI$00000200        // same as LL_PRINT_PREVIEW
Define LL_PRINT_FILE                                    FOR |CI$00000400        
Define LL_PRINT_USERSELECT                              FOR |CI$00000800        
Define LL_PRINT_EXPORT                                  FOR |CI$00000800        // same as LL_PRINT_USERSELECT
Define LL_PRINT_MODEMASK                                FOR |CI$00000F00        
Define LL_PRINT_MULTIPLE_JOBS                           FOR |CI$00001000        
Define LL_PRINT_KEEPJOB                                 FOR |CI$00002000        
Define LL_PRINT_IS_DOM_CALLER                           for |CI$00004000        // internal 
Define LL_PRINT_DOM_NOCREATEDC                          for |CI$00010000        // internal
Define LL_PRINT_REMOVE_UNUSED_VARS                      for |CI$00008000        // optimization flag
#IF (USELLVERSION>19)
Define LL_BOXTYPE_BOXTYPEMASK                           for |CI$000000ff
Define LL_BOXTYPE_NONE                                  for |CI$000000ff
Define LL_BOXTYPE_FLAG_ALLOWSUSPEND                     for |CI$40000000
Define LL_BOXTYPE_FLAG_USEMARQUEE                       for |CI$80000000
#ELSE
Define LL_BOXTYPE_NONE                                  for -1
#ENDIF
Define LL_BOXTYPE_NORMALMETER                           FOR 0
Define LL_BOXTYPE_BRIDGEMETER                           FOR 1
Define LL_BOXTYPE_NORMALWAIT                            FOR 2
Define LL_BOXTYPE_BRIDGEWAIT                            FOR 3
Define LL_BOXTYPE_EMPTYWAIT                             FOR 4
Define LL_BOXTYPE_EMPTYABORT                            FOR 5
Define LL_BOXTYPE_STDWAIT                               FOR 6
Define LL_BOXTYPE_STDABORT                              FOR 7
Define LL_BOXTYPE_MAX                                   for 7                     
#IF (USELLVERSION>21)
Define LL_FILE_ALSONEW                                  for |CI$00008000
Define LL_SELECTFILEDLGTITLE_USE_OSFILENAME             for |CI$00010000
#ELSE
Define LL_FILE_ALSONEW                                  for |CI$8000
#ENDIF
#IF (USELLVERSION>18)
Define LL_FCTPARATYPE_DOUBLE                            for |CI$0001
Define LL_FCTPARATYPE_DATE                              for |CI$0002
Define LL_FCTPARATYPE_STRING                            for |CI$0004
Define LL_FCTPARATYPE_BOOL                              for |CI$0008
Define LL_FCTPARATYPE_DRAWING                           for |CI$0010
Define LL_FCTPARATYPE_BARCODE                           for |CI$0020
Define LL_FCTPARATYPE_ALL                               for |CI$003F
#ELSE
Define LL_FCTPARATYPE_DOUBLE                            FOR |CI$01
Define LL_FCTPARATYPE_DATE                              FOR |CI$02
Define LL_FCTPARATYPE_STRING                            FOR |CI$04
Define LL_FCTPARATYPE_BOOL                              FOR |CI$08
Define LL_FCTPARATYPE_DRAWING                           FOR |CI$10
Define LL_FCTPARATYPE_BARCODE                           FOR |CI$20
Define LL_FCTPARATYPE_ALL                               for |CI$3F
#ENDIF
Define LL_FCTPARATYPE_PARA1                             FOR |CI$8001
Define LL_FCTPARATYPE_PARA2                             FOR |CI$8002
Define LL_FCTPARATYPE_PARA3                             FOR |CI$8003
Define LL_FCTPARATYPE_PARA4                             FOR |CI$8004
Define LL_FCTPARATYPE_SAME                              FOR |CI$803F
Define LL_FCTPARATYPE_MASK                              for |CI$8FFF
#IF (USELLVERSION>21)
Define LL_FCTPARATYPEFLAG_NONULLCHECK                   for |CI$00010000
Define LL_FCTPARATYPEFLAG_MULTIDIM_ALLOWED              for |CI$00020000
#ELSE
Define LL_FCTPARATYPEFLAG_NONULLCHECK                   for |CI$10000
Define LL_FCTPARATYPEFLAG_MULTIDIM_ALLOWED              for |CI$20000                   // internal
#ENDIF
#IF (USELLVERSION=20)
Define LL_FCTPARATYPEFLAG_RAW                           for |CI$80000                   // parameter passed as String without evaluation
Define LL_FCTPARATYPEFLAG_RAW_WITH_SYNTAXCHECK          for |CI$40000                   // parameter passed as String without evaluation 
Define LL_FCTPARATYPEFLAG_KEEP_LINEBREAKS               for |CI$100000
#ENDIF
#IF (USELLVERSION>21)
Define LL_FCTPARATYPEFLAG_RAW                           for |CI$00080000                // parameter passed as String without evaluation
Define LL_FCTPARATYPEFLAG_RAW_WITH_SYNTAXCHECK          for |CI$00040000                // parameter passed as String without evaluation
Define LL_FCTPARATYPEFLAG_KEEP_LINEBREAKS               for |CI$00100000
Define LL_FCTPARATYPEFLAG_EXECUTE_ON_SYNTAXCHECK_AT_LOADTIME for |CI$00200000
#ENDIF
Define LL_EXPRTYPE_DOUBLE                               FOR 1
Define LL_EXPRTYPE_DATE                                 FOR 2
Define LL_EXPRTYPE_STRING                               FOR 3
Define LL_EXPRTYPE_BOOL                                 FOR 4
Define LL_EXPRTYPE_DRAWING                              FOR 5
Define LL_EXPRTYPE_BARCODE                              FOR 6
Define LL_OPTION_NEWEXPRESSIONS                         FOR 0                   // default: TRUE
Define LL_OPTION_ONLYONETABLE                           FOR 1                   // default: FALSE
Define LL_OPTION_TABLE_COLORING                         FOR 2                   // default: LL_COLORING_LL
Define LL_COLORING_LL                                   FOR 0
Define LL_COLORING_PROGRAM                              FOR 1
Define LL_COLORING_DONTCARE                             FOR 2
Define LL_OPTION_SUPERVISOR                             FOR 3                   // default: FALSE
Define LL_OPTION_UNITS                                  FOR 4                   // default: see LL_OPTION_METRIC
Define LL_OPTION_TABSTOPS                               FOR 5                   // default: LL_TABS_DELETE
Define LL_TABS_DELETE                                   FOR 0
Define LL_TABS_EXPAND                                   FOR 1
Define LL_OPTION_CALLBACKMASK                           FOR 6                   // default: 0x00000000
Define LL_CB_PAGE                                       FOR |CI$40000000        // callback FOR each page
Define LL_CB_PROJECT                                    FOR |CI$20000000        // callback FOR each label
Define LL_CB_OBJECT                                     FOR |CI$10000000        // callback FOR each Object
Define LL_CB_HELP                                       FOR |CI$08000000        // callback FOR HELP (F1/Button)
Define LL_CB_TABLELINE                                  FOR |CI$04000000        // callback FOR table line
Define LL_CB_TABLEFIELD                                 FOR |CI$02000000        // callback FOR table Field
Define LL_CB_QUERY_IS_VARIABLE_OR_FIELD                 FOR |CI$01000000        // callback FOR delayload (LL_QUERY_IS_VARIABLE_OR_FIELD)
Define LL_OPTION_CALLBACKPARAMETER                      FOR 7                   // default: 0
Define LL_OPTION_HELPAVAILABLE                          FOR 8                   // default: TRUE
Define LL_OPTION_SORTVARIABLES                          FOR 9                   // default: TRUE
Define LL_OPTION_SUPPORTPAGEBREAK                       FOR 10                  // default: TRUE
Define LL_OPTION_SHOWPREDEFVARS                         FOR 11                  // default: TRUE
Define LL_OPTION_USEHOSTPRINTER                         FOR 13                  // default: FALSE // use host printer via callback
Define LL_OPTION_EXTENDEDEVALUATION                     FOR 14                  // allows expressions In chevrons (amwin mode)
Define LL_OPTION_TABREPRESENTATIONCODE                  for 15                  // default: 247 (0xf7)
#IF (USELLVERSION>15)
Define LL_OPTION_SHOWSTATE                              for 16                  // r/o
#ENDIF
Define LL_OPTION_METRIC                                 FOR 18                  // default: depends on Windows defaults
Define LL_OPTION_ADDVARSTOFIELDS                        FOR 19                  // default: FALSE
Define LL_OPTION_MULTIPLETABLELINES                     FOR 20                  // default: TRUE
Define LL_OPTION_CONVERTCRLF                            FOR 21                  // default: FALSE
Define LL_OPTION_WIZ_FILENEW                            FOR 22                  // default: FALSE
Define LL_OPTION_RETREPRESENTATIONCODE                  FOR 23                  // default: LL_CHAR_NEWLINE (182)
Define LL_OPTION_PRVZOOM_PERC                           FOR 25                  // initial preview zoom
Define LL_OPTION_PRVRECT_LEFT                           FOR 26                  // initial preview position
Define LL_OPTION_PRVRECT_TOP                            FOR 27
Define LL_OPTION_PRVRECT_WIDTH                          FOR 28
Define LL_OPTION_PRVRECT_HEIGHT                         FOR 29
Define LL_OPTION_STORAGESYSTEM                          FOR 30                  // 0=LX4-compatible, 1=STORAGE
Define LL_OPTION_COMPRESSSTORAGE                        FOR 31                  // 0, 1, 10..17
Define LL_STG_COMPRESS_THREADED                         FOR |CI$00008000
Define LL_STG_COMPRESS_UNTHREADED                       FOR |CI$00010000
Define LL_OPTION_NOPARAMETERCHECK                       FOR 32                  // you need a bit more speed?
Define LL_OPTION_NONOTABLECHECK                         FOR 33                  // don't check on "NO_TABLEOBJECT" error. Default TRUE (don't check)
Define LL_OPTION_DRAWFOOTERLINEONPRINT                  FOR 34                  // delay footerline printing to LlPrint(). Default FALSE
Define LL_OPTION_PRVZOOM_LEFT                           FOR 35                  // initial preview position In percent Of screen
Define LL_OPTION_PRVZOOM_TOP                            FOR 36
Define LL_OPTION_PRVZOOM_WIDTH                          FOR 37
Define LL_OPTION_PRVZOOM_HEIGHT                         FOR 38
Define LL_OPTION_SPACEOPTIMIZATION                      FOR 40                  // default: TRUE
Define LL_OPTION_REALTIME                               FOR 41                  // default: FALSE
Define LL_OPTION_AUTOMULTIPAGE                          FOR 42                  // default: TRUE
Define LL_OPTION_USEBARCODESIZES                        FOR 43                  // default: FALSE
Define LL_OPTION_MAXRTFVERSION                          FOR 44                  // default: 0xff00
Define LL_OPTION_VARSCASESENSITIVE                      FOR 46                  // default: FALSE
Define LL_OPTION_DELAYTABLEHEADER                       FOR 47                  // default: TRUE
Define LL_OPTION_OFNDIALOG_EXPLORER                     FOR 48                  // default: Win16: FALSE, WIN32: NewShell present
Define LL_OPTION_OFN_NOPLACESBAR                        FOR |CI$40000000
Define LL_OPTION_EMFRESOLUTION                          FOR 49                  // default: 100 FOR 1/100 mm
Define LL_OPTION_SETCREATIONINFO                        FOR 50                  // default: TRUE
Define LL_OPTION_XLATVARNAMES                           FOR 51                  // default: TRUE
Define LL_OPTION_LANGUAGE                               FOR 52                  // Returns current language (r/o)
Define LL_OPTION_PHANTOMSPACEREPRESENTATIONCODE         FOR 54                  // default: LL_CHAR_PHANTOMSPACE
Define LL_OPTION_LOCKNEXTCHARREPRESENTATIONCODE         FOR 55                  // default: LL_CHAR_LOCK
Define LL_OPTION_EXPRSEPREPRESENTATIONCODE              FOR 56                  // default: LL_CHAR_EXPRSEP
Define LL_OPTION_DEFPRINTERINSTALLED                    FOR 57                  // r/o
Define LL_OPTION_CALCSUMVARSONINVISIBLELINES            FOR 58                  // default: FALSE - only default value If no preferences In project
Define LL_OPTION_NOFOOTERPAGEWRAP                       FOR 59                  // default: FALSE - only default value If no preferences In project
Define LL_OPTION_IMMEDIATELASTPAGE                      FOR 64                  // default: FALSE
Define LL_OPTION_LCID                                   FOR 65                  // default: LOCALE_USER_DEFAULT
Define LL_OPTION_TEXTQUOTEREPRESENTATIONCODE            FOR 66                  // default: 1
Define LL_OPTION_SCALABLEFONTSONLY                      FOR 67                  // default: TRUE
Define LL_OPTION_NOTIFICATIONMESSAGEHWND                FOR 68                  // default: NULL (parent window Handle)
Define LL_OPTION_DEFDEFFONT                             FOR 69                  // default: GetStockObject(ANSI_VAR_FONT)
Define LL_OPTION_CODEPAGE                               FOR 70                  // default: CP_ACP; Set codepage to Use FOR conversions.
Define LL_OPTION_FORCEFONTCHARSET                       FOR 71                  // default: FALSE; Set font's charset to the codepage according to LL_OPTION_LCID. Default: FALSE
Define LL_OPTION_COMPRESSRTF                            FOR 72                  // default: TRUE; compress RTF text > 1024 bytes In project file
Define LL_OPTION_ALLOW_LLX_EXPORTERS                    FOR 74                  // default: TRUE; allow ILlXExport extensions
Define LL_OPTION_SUPPORTS_PRNOPTSTR_EXPORT              FOR 75                  // default: FALSE: hides "set to default" button In "export option" tab In designer
Define LL_OPTION_DEBUGFLAG                              FOR 76
Define LL_OPTION_SKIPRETURNATENDOFRTF                   FOR 77                  // default: FALSE
Define LL_OPTION_INTERCHARSPACING                       FOR 78                  // default: FALSE: allows Character interspacing In Case Of block justify
Define LL_OPTION_INCLUDEFONTDESCENT                     FOR 79                  // default: FALSE (compatibility)
Define LL_OPTION_RESOLUTIONCOMPATIBLETO9X               FOR 80                  // default: FALSE (on NT/2K, Else TRUE)
Define LL_OPTION_USECHARTFIELDS                         FOR 81                  // default: FALSE
Define LL_OPTION_OFNDIALOG_NOPLACESBAR                  FOR 82                  // default: FALSE; do Not Use "Places" bar In NT2K?
Define LL_OPTION_SKETCH_COLORDEPTH                      for 83                  // default: 24
Define LL_OPTION_FINAL_TRUE_ON_LASTPAGE                 FOR 84                  // default: FALSE: internal Use
Define LL_OPTION_LLXAUTOSORTAXIS                        FOR 85                  // default: FALSE
Define LL_OPTION_INTERCHARSPACING_FORCED                FOR 86                  // default: FALSE: forces Character interspacing calculation In TEXT objects (possibly dangerous And slow)
Define LL_OPTION_RTFAUTOINCREMENT                       FOR 87                  // default: FALSE, to Increment RTF Char Pointer If nothing can be printed 
Define LL_OPTION_UNITS_DEFAULT                          FOR 88                  // default: LL_OPTION_UNITS_SYSDEFAULT. Use FOR contols that query the units, where we need to return "sysdefault" also 
Define LL_OPTION_NO_MAPI                                FOR 89                  // default: FALSE. Inhibit MAPI load FOR preview 
Define LL_OPTION_TOOLBARSTYLE                           FOR 90                  // default: LL_OPTION_TOOLBARSTYLE_STANDARD|LL_OPTION_TOOLBARSTYLEFLAG_DOCKABLE 
Define LL_OPTION_TOOLBARSTYLE_STANDARD                  FOR 0                   // OFFICE97 alike style 
Define LL_OPTION_TOOLBARSTYLE_OFFICEXP                  FOR 1                   // DOTNET/OFFICE_XP alike style 
Define LL_OPTION_TOOLBARSTYLE_OFFICE2003                FOR 2
Define LL_OPTION_TOOLBARSTYLEMASK                       FOR |CI$0F              
Define LL_OPTION_TOOLBARSTYLEFLAG_GRADIENT              FOR |CI$80              // starting with XP, Use gradient style 
Define LL_OPTION_TOOLBARSTYLEFLAG_DOCKABLE              FOR |CI$40              // dockable toolbars? 
Define LL_OPTION_TOOLBARSTYLEFLAG_CANCLOSE              for |CI$20              // internal Use only 
#IF (USELLVERSION>15)
Define LL_OPTION_TOOLBARSTYLEFLAG_SHRINK_TO_FIT         for |CI$10              // internal use only
#ENDIF
Define LL_OPTION_MENUSTYLE                              FOR 91                  // default: LL_OPTION_MENUSTYLE_STANDARD 
Define LL_OPTION_MENUSTYLE_STANDARD_WITHOUT_BITMAPS     FOR 0                   // values: see CTL 
Define LL_OPTION_MENUSTYLE_STANDARD                     FOR 1                
Define LL_OPTION_MENUSTYLE_OFFICEXP                     FOR 2
Define LL_OPTION_MENUSTYLE_OFFIC2003                    FOR 3
Define LL_OPTION_RULERSTYLE                             FOR 92                  // default: LL_OPTION_RULERSTYLE_FLAT 
Define LL_OPTION_RULERSTYLE_FLAT                        FOR |CI$10              
Define LL_OPTION_RULERSTYLE_GRADIENT                    FOR |CI$80              
Define LL_OPTION_STATUSBARSTYLE                         FOR 93                
Define LL_OPTION_STATUSBARSTYLE_STANDARD                FOR 0                 
Define LL_OPTION_STATUSBARSTYLE_OFFICEXP                FOR 1
Define LL_OPTION_STATUSBARSTYLE_OFFICE2003              FOR 2
Define LL_OPTION_TABBARSTYLE                            FOR 94                
Define LL_OPTION_TABBARSTYLE_STANDARD                   FOR 0                 
Define LL_OPTION_TABBARSTYLE_OFFICEXP                   FOR 1
Define LL_OPTION_TABBARSTYLE_OFFICE2003                 FOR 2
Define LL_OPTION_DROPWINDOWSTYLE                        FOR 95                
Define LL_OPTION_DROPWINDOWSTYLE_STANDARD               FOR 0                 
Define LL_OPTION_DROPWINDOWSTYLE_OFFICEXP               FOR 1
Define LL_OPTION_DROPWINDOWSTYLE_OFFICE2003             FOR 2
Define LL_OPTION_DROPWINDOWSTYLEMASK                    FOR |CI$0F              
Define LL_OPTION_DROPWINDOWSTYLEFLAG_CANCLOSE           FOR |CI$20
Define LL_OPTION_INTERFACEWRAPPER                       FOR 96                  // Returns IL<n>* 
Define LL_OPTION_FONTQUALITY                            FOR 97                  // LOGFONT.lfQuality, default: DEFAULT_QUALITY 
Define LL_OPTION_FONTPRECISION                          FOR 98                  // LOGFONT.lfOutPrecision, default: OUT_STRING_PRECIS 
Define LL_OPTION_UISTYLE                                FOR 99                  // UI collection, w/o 
Define LL_OPTION_UISTYLE_STANDARD                       FOR 0                   // 90=0x40, 91=1, 92=0x10, 93=0, 94=0, 95=0x20
Define LL_OPTION_UISTYLE_OFFICEXP                       FOR 1                   // 90=0x41, 91=2, 92=0x10, 93=1, 94=1, 95=0x21
Define LL_OPTION_UISTYLE_OFFICE2003                     FOR 2                   // 90=0x42, 91=3, 92=0x10, 93=2, 94=2, 95=0x22
Define LL_OPTION_NOFILEVERSIONUPGRADEWARNING            FOR 100                 // default: FALSE 
Define LL_OPTION_UPDATE_FOOTER_ON_DATALINEBREAK_AT_FIRST_LINE  FOR 101          // default: FALSE
Define LL_OPTION_ESC_CLOSES_PREVIEW                     FOR 102                 // shall ESC Close the preview window
Define LL_OPTION_VIEWER_ASSUMES_TEMPFILE                FOR 103                 // shall the viewer assume that the file is a temporary file (And Not store values In it)? default TRUE
Define LL_OPTION_CALC_USED_VARS                         for 104                 // default: FALSE
#IF (USELLVERSION<22)
Define LL_OPTION_BOTTOMALIGNMENT_WIN9X_UNLIKE_NT        for 105                 // default: TRUE
#ENDIF
Define LL_OPTION_NOPRINTJOBSUPERVISION                  FOR 106                 // default: TRUE
Define LL_OPTION_CALC_SUMVARS_ON_PARTIAL_LINES          FOR 107                 // default: FALSE
Define LL_OPTION_BLACKNESS_SCM                          FOR 108                 // default: 0
Define LL_OPTION_PROHIBIT_USERINTERACTION               FOR 109                 // default: FALSE
Define LL_OPTION_PERFMON_INSTALL                        FOR 110                 // w/o, TRUE to install, FALSE to uninstall
Define LL_OPTION_VARLISTBUCKETCOUNT                     FOR 112                 // applied to future jobs only, default 1000
Define LL_OPTION_MSFAXALLOWED                           FOR 113                 // global flag - Set at start Of LL! Will allow/prohibit fax detection. Default: TRUE 
Define LL_OPTION_AUTOPROFILINGTICKS                     FOR 114                 // global flag - Set at start Of LL! Activates LL's thread profiling 
Define LL_OPTION_PROJECTBACKUP                          FOR 115                 // default: TRUE 
Define LL_OPTION_ERR_ON_FILENOTFOUND                    FOR 116                 // default: FALSE
Define LL_OPTION_NOFAXVARS                              FOR 117                 // default: FALSE
Define LL_OPTION_NOMAILVARS                             FOR 118                 // default: FALSE
Define LL_OPTION_PATTERNRESCOMPATIBILITY                FOR 119                 // default: FALSE
Define LL_OPTION_NODELAYEDVALUECACHING                  FOR 120                 // default: FALSE
Define LL_OPTION_FEATURE                                FOR 1000                
Define LL_OPTION_FEATURE_CLEARALL                       FOR 0                 
Define LL_OPTION_FEATURE_SUPPRESS_JPEG_DISPLAY          FOR 1                 
Define LL_OPTION_FEATURE_SUPPRESS_JPEG_CREATION         FOR 2                 
Define LL_OPTION_VARLISTDISPLAY                         for 121                 // default: LL_OPTION_VARLISTDISPLAY_FOLDERPOS_TOP | LL_OPTION_VARLISTDISPLAY_VARSORT_ALPHA */
Define LL_OPTION_VARLISTDISPLAY_VARSORT_DECLARATIONORDER for |CI$0000
Define LL_OPTION_VARLISTDISPLAY_VARSORT_ALPHA           FOR |CI$0001
Define LL_OPTION_VARLISTDISPLAY_VARSORT_MASK            FOR |CI$000F
Define LL_OPTION_VARLISTDISPLAY_FOLDERPOS_DECLARATIONORDER FOR |CI$0000            
Define LL_OPTION_VARLISTDISPLAY_FOLDERPOS_ALPHA         FOR |CI$0010            // only If LL_OPTION_VARLISTDISPLAY_VARSORT_ALPHA is Set
Define LL_OPTION_VARLISTDISPLAY_FOLDERPOS_TOP           FOR |CI$0020
Define LL_OPTION_VARLISTDISPLAY_FOLDERPOS_BOTTOM        FOR |CI$0030
Define LL_OPTION_VARLISTDISPLAY_FOLDERPOS_MASK          FOR |CI$00F0
Define LL_OPTION_WORKAROUND_RTFBUG_EMPTYFIRSTPAGE       FOR 122
Define LL_OPTION_FORMULASTRINGCOMPARISONS_CASESENSITIVE FOR 123                 // default: TRUE
Define LL_OPTION_FIELDS_IN_PROJECTPARAMETERS            FOR 124                 // default: FALSE
Define LL_OPTION_CHECKWINDOWTHREADEDNESS                FOR 125                 // default: FALSE
Define LL_OPTION_ISUSED_WILDCARD_AT_START               FOR 126                 // default: FALSE
Define LL_OPTION_ROOT_MUST_BE_MASTERTABLE               FOR 127                 // default: FALSE
Define LL_OPTION_DLLTYPE                                FOR 128                 // r/o 
Define LL_OPTION_DLLTYPE_32BIT                          FOR |CI$0001            
Define LL_OPTION_DLLTYPE_64BIT                          FOR |CI$0002
Define LL_OPTION_DLLTYPE_BITMASK                        FOR |CI$000F
Define LL_OPTION_DLLTYPE_SDBCS                          FOR |CI$0010
Define LL_OPTION_DLLTYPE_UNICODE                        FOR |CI$0020
Define LL_OPTION_DLLTYPE_CHARSET                        FOR |CI$00F0
Define LL_OPTION_HLIBRARY                               FOR 129                 // r/o
Define LL_OPTION_INVERTED_PAGEORIENTATION               FOR 130                 // default: FALSE
Define LL_OPTION_ENABLE_STANDALONE_DATACOLLECTING_OBJECTS FOR 131               // default: FALSE
Define LL_OPTION_USERVARS_ARE_CODESNIPPETS              FOR 132                 // default: FALSE
Define LL_OPTION_STORAGE_ADD_SUMMARYINFORMATION         FOR 133                 // default: FALSE
Define LL_OPTION_INCREMENTAL_PREVIEW                    FOR 135                 // default: TRUE 
Define LL_OPTION_RELAX_AT_SHUTDOWN                      FOR 136                 // default: FALSE
Define LL_OPTION_NOPRINTERPATHCHECK                     FOR 137                 // default: FALSE
Define LL_OPTION_SUPPORT_HUGESTORAGEFS                  for 138                 // deprecated, always true
Define LL_OPTION_NOAUTOPROPERTYCORRECTION               FOR 139                 // default: False
Define LL_OPTION_NOVARLISTRESET_ON_RESETPROJECTSTATE    FOR 140                 // default: False
Define LL_OPTION_DESIGNERPREVIEWPARAMETER               FOR 141                 // default: NULL
Define LL_OPTION_RESERVED142                            FOR 142                 
Define LL_OPTION_DESIGNEREXPORTPARAMETER                FOR 143                 // default: NULL
Define LL_OPTION_DESIGNERPRINT_SINGLETHREADED           FOR 144                 // default: False 
Define LL_OPTION_ALLOW_COMMENTS_IN_FORMULA              for 145                 // default: True (still only available In LL13 In pro/enterprise version) 
Define LL_OPTION_USE_MLANG_LINEBREAKALGORITHM           for 146                 // default: False (would Use MLANG to calculate the line Break algorithm)
#IF (USELLVERSION>20)
Define LL_OPTION_USE_JPEG_OR_PNG_OPTIMIZATION           for 147                 // default: True 
#ELSE
Define LL_OPTION_USE_JPEG_OPTIMIZATION                  for 147                 // default: True 
#ENDIF
Define LL_OPTION_ENABLE_IMAGESMOOTHING                  FOR 148                 // default: True (uses GDIPLUS - no smoothing on Win2000/98 If not GDIPLUS installed! Right now, applies only to JPEG.)
Define LL_OPTION_MAXRTFVERSION_AVAILABLE                for 159                 // r/o 
Define LL_OPTION_CONDREPRESENTATIONCODES_LIKE_ANSI      for 160                 // default: False
Define LL_OPTION_NULL_IS_NONDESTRUCTIVE                 for 161                 // default: False
Define LL_OPTION_DRILLDOWNPARAMETER                     for 162                 // default: NULL
Define LL_OPTION_ROUNDINGSTRATEGY                       for 163                 // default: LL_ROUNDINGSTRATEGY_BANKERSROUNDING
Define LL_ROUNDINGSTRATEGY_BANKERSROUNDING              for 0                   //
Define LL_ROUNDINGSTRATEGY_ARITHMETIC_SYMMETRIC         for 1                   //
Define LL_OPTION_RESERVED164                            for 164                 //
Define LL_OPTION_RESERVED165                            for 165                 //
Define LL_OPTION_PICTURE_TRANSPARENCY_IS_WHITE          for 166                 // default: False (transparent)
Define LL_OPTION_FLOATPRECISION                         for 167                 // Global (not job specific!). Default: 0 (192 bit mantissa, 32 bit exponent)
Define LL_OPTION_SUPPRESS_LRUENTRY                      for 168                 //
Define LL_OPTION_FORCEFIRSTGROUPHEADER                  for 169                 // default: False (group match String is an empty String)
Define LL_OPTION_SUPPORT_PDFINPUTFIELDS                 for 170                 // PDF 3.0 supports text objects and check boxes as input objects - default: True
Define LL_OPTION_ENHANCED_SKIPRETURNATENDOFRTF          for 171                 // default: False
Define LL_OPTION_HIERARCHICALDATASOURCE                 for 172                 // default: False
Define LL_OPTION_FORCE_HEADER_EVEN_ON_LARGE_FOOTERLINES for 173                 // default: False
Define LL_OPTION_PRINTERDEVICEOPTIMIZATION              for 174                 // default: True
Define LL_OPTION_RTFHEIGHTSCALINGPERCENTAGE             for 175                 // default: 100
Define LL_OPTION_FORCE_DEFAULT_PRINTER_IN_PREVIEW       for 176                 // default: False
Define LL_OPTION_HIERARCHICALDATASOURCE_ROOT            for 177                 // internal Use only
Define LL_DRILLDOWNFILTERSTRATEGY_ALLOW_ONLY_SUBTABLES	        for 0
Define LL_DRILLDOWNFILTERSTRATEGY_ALLOW_ALL_TABLES			    for 1
Define LL_DRILLDOWNFILTERSTRATEGY_ALLOW_SUBTABLES_AND_UNRELATED for 2
Define LL_DRILLDOWNFILTERSTRATEGY_ALLOW_SUBTABLES_AND_USERDEFINED for 3
Define LL_DRILLDOWNFILTERSTRATEGY_MASK                          for |CI$0f
Define LL_DRILLDOWNFILTERFLAG_OFFER_BASERECORD_AS_VARIABLES     for |CI$10
Define LL_OPTION_DRILLDOWN_DATABASEFILTERING                    for 179         // default: 0 (filter all except subtables of the base table: LL_DRILLDOWNFILTERSTRATEGY_ALLOW_ONLY_SUBTABLES) 
Define LL_OPTION_SUPPRESS_TASKBARBUTTON_PROGRESSSTATE           for 180         // default: False
Define LL_OPTION_PRINTDLG_DEVICECHANGE_KEEPS_DEVMODESETTINGS    for 181         // default: True 
Define LL_OPTION_DRILLDOWN_SUPPORTS_EMBEDDING                   for 182         // default: True
#IF (USELLVERSION>15)
Define LL_VARLISTCLEARSTRATEGY_EMPTY_LIST                       for 0
Define LL_VARLISTCLEARSTRATEGY_SET_NULL                         for 1
Define LL_VARLISTCLEARSTRATEGY_SET_DEFAULT                      for 2
Define LL_OPTION_VARLISTCLEARSTRATEGY_ON_DEFINE_START           for 183         // default: LL_VARLISTCLEARSTRATEGY_EMPTY_LIST 
Define LL_OPTION_RESERVED184                                    for 184
Define LL_OPTION_KEEP_EMPTY_SUM_VARS                            for 185         // default: False 
Define LL_OPTION_RESERVED187                                    for 187         // internal test flag
#ENDIF
Define LL_OPTION_DEFAULTDECSFORSTR                              for 188         // default: 5. Sets the default Number of decimals for Str$
#IF (USELLVERSION>15)
Define LL_OPTION_RESETPROJECTSTATE_FORCES_NEW_PRINTJOB          for 189         // default: False
Define LL_OPTION_DEFINEXXXSTART_COMPATIBLE_TO_PRE15             for 190          
Define LL_OPTION_RESETPROJECTSTATE_FORCES_NEW_DC                for 191         // default: True
#ENDIF
#IF (USELLVERSION>17)
Define LL_OPTION_BITMAP_RESOLUTION_FOR_PREVIEW                  for 192         // default: 0 (leave original size), suggestions are 300 or 600. -1 to Use device default. 
Define LL_OPTION_DRAW_EMPTY_CHARTOBJECTS                        for 193         // default: False 
Define LL_OPTION_PREVIOUS_DEFAULTS_TO_NULL                      for 194         // default: False (for compatibility). Previous() Returns NULL on first record If True, otherwise some default value for the given datatype. 
Define LL_OPTION_FORCE_IMAGEEMBEDDING                           for 195         // default: False. Images added via the image dialog are always embedded. 
Define LL_OPTION_VARKEY_MAP_SHARP_S_TO_SS                       for 196         // default: False 
Define LL_OPTION_NO_LAYERED_WINDOWS                             for 197         // default: False 
Define LL_OPTION_SCALED_PERCENTAGEFORMATTER                     for 198         // default: False (0.1="0.1%", True: 0.1="10%") 
Define LL_OPTION_USE_ANTIALIAS                                  for 199         // default: True 
Define LL_OPTION_FORCETABLELINECALLBACK                         for 200         // LL_CMND_TABLE_LINE is called even when COLORINGMODE_LL ist Set, default: False 
Define LL_OPTION_EXPORTCONSUMER                                 for 201         // internal Use only 
Define LL_OPTION_TOC_IDX_ITEMID                                 for 202         // internal Use only 
Define LL_OPTION_FORCED2PASSMODE                                for 203         // default: False 
Define LL_OPTION_SETVAR_ONLY_SETS_IF_CONTAINER_PRINTS           for 204         // default: False 
Define LL_OPTION_SHOW_PREVIEW_AFTER_PRINT_END                   for 206         // "Export-ShowResult" sets this for PRV... 
Define LL_OPTION_PROPLIST_COMBOBOX_SCROLL_WRAPS                 for 207         // default: False 
Define LL_OPTION_ALWAYS_CALC_GROUPCHANGE_CONDITION              for 208         // default: False 
Define LL_OPTION_NULLHANDLING_SUPPORTED_IN_ENHMODE              for 209         // default: False  
Define LL_OPTION_RESETPROJECTSTATE_FORCES_NEW_PREVIEWJOB        for 210         // default: True 
Define LL_OPTION_USE_LEGACY_WORDWRAPPINGALGORITHM               for 211         // default: False 
Define LL_OPTION_PREVIEW_USES_PRINTTHREAD                       for 212         // default: True 
Define LL_OPTION_LL_SUPPLIES_MESSAGELOOP_WHILE_PRINTING_TO_PREVIEW for 213      // default: True 
Define LL_OPTION_PRINTERDCCACHE_TIMEOUT_SEC                     for 214         // default: 60 (0 -> no cache) 
Define LL_OPTION_DESIGNER_RIBBONBACKGROUNDCOLOR                 for 215         // default: 0 (system default) 
Define LL_OPTION_INTERNAL_EMFCLEANUP                            for 216         // no comment -> internal! 
Define LL_OPTION_RIBBON_DEFAULT_ENABLEDSTATE                    for 217         // default: True 
Define LL_OPTION_PRVFILEVERSION                                 for 218         // default: 0 (2 would optimized version, supported since LL18, possibly faster If > 5000 pages or so) 
Define LL_OPTION_TRY_REDUCE_BMPSIZE_BY_CONVERTING_TO_PNG_OR_JPEG for 219        // default: False 
Define LL_OPTION_NO_IMAGEFILEOPTIMIZATION                       for 220         // default: False. Set this to True If you know you're replacing an image file during printing that is used in a project using its file name 
Define LL_OPTION_NO_ENFORCED_GROUPFOOTERPRIORITY_FOR_LAST_GROUPFOOTER for 221   // default: False. Compatibility to LL 16.008. 
Define LL_OPTION_ALLOW_COMBINED_COLLECTING_OF_DATA_FOR_COLLECTIONCONTROLS for 222 // default: True 
Define LL_OPTION_SUPPRESS_LOADERRORMESSAGES                     for 223         // default: False. Please take care that this is a reference counted flag, so Add (True) and Subtract (False) the same Number of calls! [ChK] 
Define LL_OPTION_IGNOREFORMULARESULTMISMATCH_AT_LOADTIME        for 224         // default: False. Switches the r8117 (err #3535) change back to the old behavior 
Define LL_OPTION_MAX_SIZE_OF_PROJECTINFOCACHE                   for 225         // default: 1000 
Define LL_OPTION_DO_NOT_RESTORE_PREVSTATE_ON_FILTER_MISMATCH    for 228         
#ENDIF
#IF (USELLVERSION>18)
Define LL_OPTION_SUPPORT_USERDEFINED_REPORTPAGELAYOUT           for 229          //default: False
Define LL_OPTION_DESIGNER_RIBBONTEXTCOLOR                       for 230          // default: undefined (system default)
Define LL_PARTSHARINGFLAG_VARIABLES_TOC                         for |CI$01
Define LL_PARTSHARINGFLAG_VARIABLES_IDX                         for |CI$02
Define LL_OPTION_PARTSHARINGFLAGS                               for 231          // default: 0
Define LL_OPTION_PIECHARTORDER_COMPATIBLE_TO_PRE19              for 232          // default: 1 (LL18), 0 (>= LL19)
Define LL_OPTION_DATABASESTRUCTURE_SORT_DECLARATIONORDER        for 233          // default: False (sorted alphabetically)
Define LL_OPTION_REPORT_PARAMETERS_REALDATAJOBPARAMETER         for 234          // default: NULL 
Define LL_OPTION_EXPANDABLE_REGIONS_REALDATAJOBPARAMETER        for 235          // default: NULL
Define LL_OPTION_IMPROVED_TABLELINEANCHORING                    for 236          // default: False
Define LL_OPTION_INTERACTIVESORTING_REALDATAJOBPARAMETER        for 237          // default: NULL
Define LL_OPTION_TEMPFILESTRATEGY                               for 238          // default: LL_TEMPFILESTRATEGY_SPEED
Define LL_TEMPFILESTRATEGY_SPEED                                for 0
Define LL_TEMPFILESTRATEGY_SIZE                                 for 1
Define LL_TEMPFILESTRATEGY_SECURITY                             for 2
#ENDIF
#IF (USELLVERSION>19)
Define LL_OPTION_RTF_WHITE_BACKGROUND_IS_TRANSPARENT            for 239             // default: True (!)
Define LL_OPTION_NO_DOTTED_LINE_ON_SECONDARY_AXIS               for 240             // default: False 
Define LL_OPTION_NO_PREVIOUS_VARLIST                            for 241
Define LL_OPTION_COMMIT_FILE_ON_SAVE                            for 242             // default: False 
Define LL_OPTION_DO_NOT_RTRIM_CELLTEXT                          for 243             // default: False 
Define LL_OPTION_ALLOW_FCT_TEXTWIDTH                            for 244             // default: False
Define LL_OPTION_PASTEOBJECTS_TO_FIRST_VISIBLE_LAYER            for 245             // default: False 
Define LL_OPTION_EMPTY_FILE_TRIGGERS_PROJECT_WIZARD             for 246             // default: False
Define LL_OPTION_DELAY_UPDATE_REMAININGTABLESPACE               for 247             // default: False 
Define LL_OPTION_WIZARD_ADDS_ORGNAME_TO_UI                      for 248             // default: False
#IF (USELLVERSION<22)
Define LL_OPTION_PROHIBIT_EXTERNAL_SHAPEFILES                   for 249             // default: False
#ELSE
Define LL_OPTION_PROHIBIT_EXTERNAL_FILES                        for 249             // default: False
#ENDIF
Define LL_OPTION_DRAWINGS_INLINED                               for 250             // default: False
Define LL_OPTION_SERIALIZE_PRINTAPI                             for 251             // default: False
Define LL_OPTION_PROJECTFILELOCKTIMEOUT_IN_MS                   for 252             // default: 10000
Define LL_OPTION_ILLDATAPROVIDER                                for 253
Define LL_OPTION_RTF_SUPPORTS_PARABREAKOPTIONS                  for 254             // default: False 
Define LL_OPTION_FORCE_PDFEMBEDDING                             for 255             // default: False. PDF documents added via the pdf dialog are always embedde
Define LL_OPTION_IGNORE_NONSCALEABLEFONTPROPERTIES              for 256             // default: False. PDF documents added via the pdf dialog are always embedded
Define LL_DATAPROVIDERTHREADNESS_NONE                           for 0
Define LL_DATAPROVIDERTHREADNESS_ONE_INSTANCE_PER_THREAD        for 1
Define LL_DATAPROVIDERTHREADNESS_DONTCARE                       for 2               // default
Define LL_OPTION_DATAPROVIDER_THREADEDNESS                      for 257
Define LL_OPTION_SUBREPORT_BASE                                 for 258
Define LL_OPTION_SUBREPORT_CLIENT                               for 259
Define LL_OPTION_NO_IPICTURE_SUPPORT                            for 260             // default: False
Define LL_OPTION_FORCE_JPEG_RECOMPRESSION                       for 261             // default: False
Define LL_OPTION_TEXTWRAP_TOLERANCE_PERC                        for 262             // default: 0 (no tolerance)
Define LL_OPTION_NO_USERVARCHECK_ON_LOAD                        for 263             // default: False 
#ENDIF
#IF (USELLVERSION>20)
Define LL_OPTION_TOC_IDX_PAGE                                   for 264             // internal Use only
Define LL_OPTION_RTF_TAB_KEY_IS_TAB_FORMATTER                   for 265             // default: False */
Define LL_OPTION_VARLISTDISPLAY_LL_FOLDER_AT_END                for 266             // default: False
Define LL_OPTION_DOM_DO_NOT_KILL_EMPTY_TABLE                    for 267             // default: False
Define LL_OPTION_ENABLE_INPUTOBJECTS_IN_TABLES                  for 268             // default: True
Define LL_OPTION_MAX_ENTRIES_FOR_AUTOCOMPLETE                   for 269             // default: 200
Define LL_OPTION_DEFAULT_FOR_SHADOWPAGEWRAP                     for 270             // default: True
Define LL_OPTION_MAX_UNDO_STEPS                                 for 271             // default: 10
Define LL_OPTION_HTML_USE_MAILFORMAT                            for 272             // default: False
Define LL_OPTION_CLIP_LABELS_TO_PROJECTAREA                     for 273             // default: False (may paint beyond the border not to lose any data)
Define LL_OPTION_RESETPROJECTSTATE_FORCES_NEW_EXPORTJOB         for 274
Define LL_OPTION_SCRIPTENGINE_ENABLED                           for 276             // default: False
Define LL_OPTION_SCRIPTENGINE_TIMEOUTMS                         for 277             // default: 10000
Define LL_OPTION_SCRIPTENGINE_AUTOEXECUTE                       for 278             // default: False
#ENDIF
#IF (USELLVERSION>21)
Define LL_OPTION_SHAPEFILE_TIMEOUTMS                            for 279             // default: 1000  */
Define LL_OPTION_COUNTALLPRINTEDDATA_LASTPRINT                  for 280             // r/o
Define LL_OPTION_SAVE_AS_ACTS_AS_EXPORT                         for 281             // default: False
Define LL_OPTION_RESETPROJECTSTATE_TRIGGERS_NEW_SHEET           for 282             // default: True
Define LL_OPTION_HIDE_EXPORT_TAB_FROM_LAYOUT_CONFIG             for 283             // default: False
Define LL_OPTION_USE_VARLIST_NAMESORTINDEXCACHE                 for 284             // should be defined for job -1
Define LL_OPTION_NOCONTRASTOPTIMIZATION                         for 285             // default: False 
Define LL_OPTION_AUTORECOVERY_DISABLED                          for 286             // default: False 
Define LL_OPTION_AUTORECOVERY_SAVEOPTIONS                       for 287             // default: LL_AUTORECOVERY_SAVEOPTIONS_NEWFILE (value might be combination of following) */
Define LL_AUTORECOVERY_SAVEOPTIONS_NEWFILE                      for 1               //
Define LL_AUTORECOVERY_SAVEOPTIONS_OVERWRITE                    for 2               //
Define LL_OPTION_LINK_PRINTERQUEUES                             for 288             // default: False, does not work yet
Define LL_OPTION_FORCE_RTFMERGING                               for 289             // default: False, forces to merge RTF contents even If there is just one part to load, compatibility switch
Define LL_OPTION_W201512300001                                  for 290             // Do not check on empty bodylines for "ActivateNextLine" - Sort of "I know what I am doing in my print loop"
Define LL_OPTION_CALCLINEHEIGHT_COMPATIBLE_TO_19                for 291             // LL19 had a wrong line height calculation, force compatible mode. Default: False.
Define LL_OPTION_FORCE_UNIQUE_PARAMETERUISTRING                 for 292             // Report parameter UI strings will be forced as unique. Default: False.
Define LL_OPTION_AUTOMATICFOOTER                                for 293             // Creates automatically footer-line in table-line wizard. Default: True.
Define LL_OPTION_SUPPORT_PREDEFINED_COLORS                      for 294             // default: for design/Print job: always True. Otherwise False. 
Define LL_OPTION_FAVORITE_SETTINGS                              for 295             // default: display button and Use registry settings 
Define LL_FAVORITES_ENABLE_FAVORITES_BY_DEFAULT                 for |CI$0001        //
Define LL_FAVORITES_HIDE_FAVORITES_BUTTON                       for |CI$0002        //
Define LL_OPTION_NEWMODE_EXPRSTARTREPRESENTATIONCODE            for 296             // default: 0xab
Define LL_OPTION_NEWMODE_EXPRENDREPRESENTATIONCODE              for 297             // default: 0xbb
Define LL_OPTION_RESERVED_298                                   for 298             // outdated, not used any more
Define LL_OPTION_ILLREPOSITORY                                  for 299             // host repository 
Define LL_OPTION_VARLISTLOOKUP_ALLOWS_GLOBALNAME                for 300             // default: 0 
Define LL_OPTION_FORCESAVEDESIGNSCHEME                          for 301             // default: False 
Define LL_OPTION_REPOSITORY_SINGLEPROJECTMODE                   for 302             // default: False 
Define LL_OPTION_ANIMATIONS_DISABLED                            for 303             // default: False
#ENDIF
#IF (USELLVERSION>23)
Define LL_OPTION_UPDATE_INTERACTIONINFO_PER_PAGE                for 304             // default: False. "true" means some overhead per page
Define LL_OPTION_IS_REPORTSERVERDESIGNER                        for 305             // * internal
Define LL_OPTION_IMPROVED_FRAMEDRAWING                          for 306             // default: False
Define LL_OPTION_POSTPAINT_TABLESEPARATORS                      for 307             // default: True
Define LL_OPTION_CROSSTAB_USE_CELLVALUE_INSTEAD_OF_DISPLAYVALUE for 308             // default: False
Define LL_OPTION_SUPPORT_DELAYEDFIELDDEFINITION                 for 309             // default: False
Define LL_OPTION_SUPPRESS_REALDATAPREVIEW_IN_DESIGNER           for 310             // default: False
Define LL_OPTION_MAX_RTFCONTROLS_IN_CACHE                       for 311             // default: 50 
Define LL_OPTION_RDPEXPORT_CREATEMPFILEUNTILSAVEDONCE           for 312             // internal 
Define LL_OPTION_CRC32_ONLY_FOR_RTFDATA_ABOVE                   for 313             // limit of RTF stream size (in KB) up to which RTF text and BLOBs are compared using MD5 - above, it's CRC32 only. Default: 100 KB
Define LL_OPTION_PRINTER_FILE_SUPERSEDES_EXPORT_OPTIONS         for 314             // settings in printer file supersede explicit export options 
Define LL_OPTION_TRANSLATIONFLAGS                               for 315             // default: both directions. Right now, only the omittance of _SAVE works.
#ENDIF
#IF (USELLVERSION>24)
Define LL_TRANSLATION_LOAD                                                      for |CI$01              
Define LL_TRANSLATION_SAVE                                                      for |CI$02              
Define LL_OPTION_PREVIEW_SCALES_RELATIVE_TO_PHYSICAL_SIZE                       for 316                 // needs >= Windows 8.1. Stored in preview file to modify behaviour in viewer 
Define LL_PREVIEW_SCALE_PHYSICAL_DESIGNERPREVIEW                                for |CI$01              
Define LL_PREVIEW_SCALE_PHYSICAL_PREVIEW                                        for |CI$02              
Define LL_OPTION_NODEFAULTFONTOVERRIDE                                          for 317                 // default: False 
Define LL_OPTION_TREEVIEWFILTER_VISIBILITYFLAGS                                 for 318                 // default: LL_TREEVIEWFILTER_IN_ALL_TREES 
Define LL_TREEVIEWFILTER_IN_VARTREE                                             for |CI$0001            
Define LL_TREEVIEWFILTER_IN_FCTWIZARD_VARTREE                                   for |CI$0002            
Define LL_TREEVIEWFILTER_IN_ALL_TREES                                           for |CI$ffff            
Define LL_OPTION_COMPAT_ALLOW_INVALID_CHARS_IN_SINGLEFIELDFORMULA               for 319                 // default: False 
Define LL_OPTION_TREEVIEWFILTER_MAXIMUM_RECURSION_SEARCH_DEPTH                  for 320                 // default: 10 
Define LL_OPTION_USER_ABORT_CANCELS_POSTPRINTPROCESSING                         for 321                 // default: False 
Define LL_OPTION_NOTOCRESET_ON_RESETPROJECTSTATE                                for 322                 // default: False 
Define LL_OPTION_NOIDXRESET_ON_RESETPROJECTSTATE                                for 323                 // default: False 
Define LL_OPTION_SUPPRESS_FORMULASUBITEMS_IN_VARTREE                            for 324                 // default: False 
Define LL_OPTION_TEMPLATE_OVERRIDES_USER_DESIGNSCHEME                           for 325                 // default: True 
Define LL_OPTION_ALLOW_ASSUMPTION_PRINTERS_CAN_PRINT_MULTIPLE_JOBS_IN_ONE_HDC   for 326                 // default: True 
Define LL_OPTION_PERSISTENT_PRINTER_USE_FOR_OUTPUT                              for 327                 // default: False 
Define LL_OPTION_GET_CURRENT_PROJECTTYPE                                        for 328                 // R/O 
Define LL_OPTION_DELAY_CALC_OF_USED_VARS                                        for 329                 // default: False 
Define LL_OPTION_USE_FONT_SIZE_AS_MAXIMUM_SIZE_FOR_TEXTFITTING                  for 330                 // default: False 
Define LL_OPTION_CLIP_FIELDS_EXCEEDING_TABLE_WIDTH                              for 331                 // default: 0 
Define LL_CLIP_FIELDS_VISUALLY                                                  for 1                   
Define LL_CLIP_FIELDS_FIT_AT_LOAD_TIME                                          for 2                   
Define LL_CLIP_FIELDS_FIT_AT_LOAD_TIME_PRINTING_ONLY                            for 3                   
Define LL_CLIP_FIELDS_FIT_COMPAT                                                for 4                   
Define LL_CLIP_FIELDS_METHOD_MASK                                               for |CI$0f               
Define LL_CLIP_FIELDS_FLAG_IGNORE_APPEARANCE_CONDITION                          for |CI$10               
Define LL_CLIP_FIELDS_FLAG_INCLUDE_NONCONST_WIDTH                               for |CI$20               
Define LL_OPTION_COMPAT_ALLOW_FIELDS_IN_PROJECT_FILTER                          for 332                 // default: False 
Define LL_OPTION_SUPPRESS_CELLCLIPPING_TO_REPORTCONTAINER                       for 333                 // default: False 
Define LL_OPTION_RSCRIPT_MULTIJOBEXECUTION                                      for 334                 // default: 0 
Define LL_OPTION_RETRIES_FOR_STARTDOC                                           for 335                 // INT, default: 1 
Define LL_OPTION_PRN_FORCE_PROJECTSIZE_AS_PAPERSIZE                             for 336                 // default: False (True: If "ForcePaperFormat"=True, Do not iterate available paper formats and look up a matching one, just put the selected size in the DEVMODE structure and hope for the printer to accept it) 
Define LL_OPTION_IS_PRINTING                                                    for 337                 // r/o, Returns If there's an active print job for the current job 
Define LL_OPTION_IDLEITERATIONCHECK_MAX_ITERATIONS                              for 338                 // 0 = no check. default: 0 
Define LL_REPOSITORYTHREADNESS_NONE                                             for 0                   
Define LL_REPOSITORYTHREADNESS_DONTCARE                                         for 1                   // default  
Define LL_REPOSITORYTHREADNESS_QUERY                                            for 2                   
Define LL_OPTION_REPOSITORY_THREADEDNESS                                        for 339                 
Define LL_OPTION_ALLOW_EMPTY_STRING_IN_XLAT                                     for 340                 // default: False 
Define LL_OPTION_GTC_LASTPOSITION_CONSIDER_INDEX                                for 341                 // default: False 
Define LL_OPTION_DESIGNERACTIONMESSAGE                                          for 342                 // r/o - joba Handle can be any value, this is Global 
Define LL_DESIGNERACTION_REFRESH_VARTREE                                        for 1                   
Define LL_OPTION_DESIGNERFRAME_HWND                                             for 343                 // r/o 
Define LL_OPTION_MULTISECTIONPRINT_MERGE                                        for 344                 // r/o 
Define LL_OPTION_COMPAT_ALLOW_FIELDS_IN_STATIC_TABLE                            for 345                 // default: False 
Define LL_OPTION_COMPAT_GROUPHEADER_SAME_PAGE_LOCAL_ONLY                        for 346                 // default: False (must be Set to True to behave as LL24) 
Define LL_OPTION_RESERVED_348                                                   for 348                 // see #37979 
Define LL_OPTION_COMPAT_PROHIBITFILTERRELATIONS                                 for 349                 // default: False 
Define LL_OPTION_ONLY_SHOW_EXISTING_PAPERSIZES_FOR_PRINTER                      for 350                 // default: False... Do not Add system defined papers to the ist of the printer's paper sizes unless the driver does not return any 
Define LL_OPTION_DEFAULT_DECIMALS                                               for 351                 // default: settings from registry/2. ATTENTION: Global option 
Define LL_OPTION_ILLPREPRINTTEXTPROCESSOR                                       for 353                 // ILLPrePrintTextProcessor 
Define LL_OPTION_USERVAR_TRACKTEMPLATEOVERRIDE                                  for 354                 // default: False 
#ENDIF
#IF (USELLVERSION>25)
Define LL_OPTION_PROJECTVAR_IGNOREEMPTY                                         for 355                 // default: False
Define LL_OPTION_SUPPRESS_FUNCTION_POPUP                                        for 356                 // default: False 
Define LL_OPTION_SUPPRESS_SYMBOLFONTMAPPING                                     for 357                 // default: False - attn: Global option!
Define LL_OPTION_COMPAT_ENABLE_FORCEWRAP_ON_EXPORT                              for 358                 // default: False 
Define LL_OPTION_SORTINDEX_LCMAP_INITFLAGVALUE                                  for 359                 // default: 0x1400 
Define LL_OPTION_EXPANDABLE_REGIONS_FORCE_STATE                                 for 360                 // default: 0
Define LL_OPTION_EXPANDABLE_REGIONS_FORCE_STATE_NEUTRAL                         for 0                   // default 
Define LL_OPTION_EXPANDABLE_REGIONS_FORCE_STATE_OPEN                            for 1                   //
Define LL_OPTION_EXPANDABLE_REGIONS_FORCE_STATE_CLOSE                           for 2                   
#ENDIF
Define LL_OPTIONSTR_LABEL_PRJEXT                        FOR 0                   // internal... (compatibility to L6)
Define LL_OPTIONSTR_LABEL_PRVEXT                        FOR 1                   // internal... (compatibility to L6)
Define LL_OPTIONSTR_LABEL_PRNEXT                        FOR 2                   // internal... (compatibility to L6)
Define LL_OPTIONSTR_CARD_PRJEXT                         FOR 3                   // internal... (compatibility to L6)
Define LL_OPTIONSTR_CARD_PRVEXT                         FOR 4                   // internal... (compatibility to L6)
Define LL_OPTIONSTR_CARD_PRNEXT                         FOR 5                   // internal... (compatibility to L6)
Define LL_OPTIONSTR_LIST_PRJEXT                         FOR 6                   // internal... (compatibility to L6)
Define LL_OPTIONSTR_LIST_PRVEXT                         FOR 7                   // internal... (compatibility to L6)
Define LL_OPTIONSTR_LIST_PRNEXT                         FOR 8                   // internal... (compatibility to L6)
Define LL_OPTIONSTR_LLXPATHLIST                         FOR 12
Define LL_OPTIONSTR_SHORTDATEFORMAT                     FOR 13
Define LL_OPTIONSTR_DECIMAL                             FOR 14                  // Decimal point, default: system
Define LL_OPTIONSTR_THOUSAND                            FOR 15                  // thousands separator, default: system
Define LL_OPTIONSTR_CURRENCY                            FOR 16                  // Currency symbol, default: system
Define LL_OPTIONSTR_EXPORTS_AVAILABLE                   FOR 17                  // r/o
Define LL_OPTIONSTR_EXPORTS_ALLOWED                     FOR 18
Define LL_OPTIONSTR_DEFDEFFONT                          FOR 19                  // In "{(r,g,b),size,<logfont>}"
Define LL_OPTIONSTR_EXPORTFILELIST                      FOR 20
Define LL_OPTIONSTR_VARALIAS                            FOR 21                  // "<local>=<global>"
Define LL_OPTIONSTR_MAILTO                              FOR 24                  // default to: Address FOR mailing From viewer
Define LL_OPTIONSTR_MAILTO_CC                           FOR 25                  // default CC: Address FOR mailing From viewer
Define LL_OPTIONSTR_MAILTO_BCC                          FOR 26                  // default BCC: Address FOR mailing From viewer
Define LL_OPTIONSTR_MAILTO_SUBJECT                      FOR 27                  // default subject FOR mailing From viewer
Define LL_OPTIONSTR_SAVEAS_PATH                         FOR 28                  // default filename FOR saving the LL file From viewer
Define LL_OPTIONSTR_LABEL_PRJDESCR                      FOR 29                  // "Etikett" ...
Define LL_OPTIONSTR_CARD_PRJDESCR                       FOR 30
Define LL_OPTIONSTR_LIST_PRJDESCR                       FOR 31
Define LL_OPTIONSTR_LLFILEDESCR                         FOR 32                  // "Vorschau-Datei"
Define LL_OPTIONSTR_PROJECTPASSWORD                     FOR 33                  // w/o, Of course :)
Define LL_OPTIONSTR_FAX_RECIPNAME                       FOR 34                  // NYI
Define LL_OPTIONSTR_FAX_RECIPNUMBER                     FOR 35                  // NYI
Define LL_OPTIONSTR_FAX_QUEUENAME                       FOR 36                  // NYI
Define LL_OPTIONSTR_FAX_SENDERNAME                      FOR 37                  // NYI
Define LL_OPTIONSTR_FAX_SENDERCOMPANY                   FOR 38                  // NYI
Define LL_OPTIONSTR_FAX_SENDERDEPT                      FOR 39                  // NYI
Define LL_OPTIONSTR_FAX_SENDERBILLINGCODE               FOR 40                  // NYI
Define LL_OPTIONSTR_FAX_AVAILABLEQUEUES                 FOR 42                  // NYI, r/o (Tab-separated) [job can be -1 Or a valid job]
Define LL_OPTIONSTR_LOGFILEPATH                         FOR 43                
Define LL_OPTIONSTR_LICENSINGINFO                       FOR 44                  // w/o, SERNO to Define licensing state
Define LL_OPTIONSTR_PRINTERALIASLIST                    FOR 45                  // multiple "PrnOld=PrnNew1[;PrnNew2[;...]]", erase with NULL Or ""
Define LL_OPTIONSTR_PREVIEWFILENAME                     FOR 46                  // path Of preview file (directory will be overridden by LlSetPrinterDefaultsDir(), If given)
Define LL_OPTIONSTR_EXPORTS_ALLOWED_IN_PREVIEW          FOR 47                  // Set In preview file
Define LL_OPTIONSTR_HELPFILENAME                        FOR 48                
Define LL_OPTIONSTR_NULLVALUE                           FOR 49                  // String which represents the NULL value
Define LL_OPTIONSTR_DEFAULT_EXPORT                      for 50                  // default export medium for new projects
Define LL_OPTIONSTR_ORIGINALPROJECTFILENAME             for 51                  // fixup project path for relative paths in realdata preview/export in designer 
Define LL_OPTIONSTR_HIERARCHICALDATASOURCE_ROOT         for 52                  // internal Use only 
#IF (USELLVERSION>15)
Define LL_OPTIONSTR_PRINTERDEFINITIONFILENAME           for 53                  // override for P file name
Define LL_OPTIONSTR_DOCINFO_DATATYPE                    for 54                  // DOCINFO.lpszDatatype
#ENDIF
#IF (USELLVERSION>17)
Define LL_OPTIONSTR_IDX_PRJEXT                          for 55                  // 
Define LL_OPTIONSTR_IDX_PRVEXT                          for 56                  // 
Define LL_OPTIONSTR_IDX_PRNEXT                          for 57                  // 
Define LL_OPTIONSTR_TOC_PRJDESCR                        for 58                  // 
Define LL_OPTIONSTR_IDX_PRJDESCR                        for 59                  // 
Define LL_OPTIONSTR_TOC_PRJEXT                          for 60                  // 
Define LL_OPTIONSTR_TOC_PRVEXT                          for 61                  // 
Define LL_OPTIONSTR_TOC_PRNEXT                          for 62                  // 
Define LL_OPTIONSTR_DEFAULTSCHEME                       for 63                  // default: empty (summertime)
Define LL_OPTIONSTR_DEFAULTPROJECTNAME                  for 64                  // DOCINFO.lpszDatatype 
Define LL_OPTIONSTR_GTC_PRJEXT                          for 65                  // 
Define LL_OPTIONSTR_GTC_PRVEXT                          for 66                  // 
Define LL_OPTIONSTR_GTC_PRNEXT                          for 67                  // 
Define LL_OPTIONSTR_GTC_PRJDESCR                        for 68                  // 
#ENDIF
#IF (USELLVERSION>19) 
Define LL_OPTIONSTR_ERRORTEXT_FROM_EXPORT               for 69                  // r/o
Define LL_OPTIONSTR_DEFAULTPRJDESCR                     for 70                  // default: empty (localized version of 'List & Label project file')
Define LL_OPTIONSTR_DEFAULTPRINTER                      for 71                  // If Set, this printer is used instead of the system's default printer (applies to ALL JOBS, so job ID must be "-1"!)
Define LL_OPTIONSTR_QUERY_LICENSINGINFO                 for 72                  // r/o, Returns serial Number in return value
#ENDIF
#IF (USELLVERSION>21)
Define LL_OPTIONSTR_RESERVED73                          for 73                  //
Define LL_OPTIONSTR_REPRESENTATION_BOOL_TRUE            for 74                  //
Define LL_OPTIONSTR_REPRESENTATION_BOOL_FALSE           for 75                  //
Define LL_OPTIONSTR_DEFAULT_FILENAME_FOR_SAVEAS         for 76                  // If Set, this filename is used as a default name when "Save as" is chosen from the menu
#ENDIF
#IF (USELLVERSION>23)
Define LL_OPTIONSTR_LABEL_PRJDESCR_SINGULAR             for 77
Define LL_OPTIONSTR_LIST_PRJDESCR_SINGULAR              for 78
Define LL_OPTIONSTR_CARD_PRJDESCR_SINGULAR              for 79
Define LL_OPTIONSTR_TOC_PRJDESCR_SINGULAR               for 80
Define LL_OPTIONSTR_IDX_PRJDESCR_SINGULAR               for 81
Define LL_OPTIONSTR_GTC_PRJDESCR_SINGULAR               for 82
Define LL_OPTIONSTR_DEFAULTIMAGEPATH                    for 83
Define LL_OPTIONSTR_EMBEDDED_EXPORTS                    for 84                  // ';' separated list of exports, for example "DOCX;XLSX;PDF". default: none. not COMPATIBLE WITH LL_QUERY_FILENAME_FOR_EXPORTJOB (!)
#ENDIF
Define LL_SYSCOMMAND_MINIMIZE                           for -1
Define LL_SYSCOMMAND_MAXIMIZE                           FOR -2
Define LL_DLGBOXMODE_3DBUTTONS                          FOR |CI$8000            // 'or'ed
Define LL_DLGBOXMODE_3DFRAME2                           FOR |CI$4000            // 'OR'ed
Define LL_DLGBOXMODE_3DFRAME                            FOR |CI$1000            // 'OR'ed
Define LL_DLGBOXMODE_NOBITMAPS                          FOR |CI$2000            // 'or'ed
Define LL_DLGBOXMODE_DONTCARE                           FOR |CI$0000            // load From INI
Define LL_DLGBOXMODE_SAA                                FOR |CI$0001
Define LL_DLGBOXMODE_ALT1                               FOR |CI$0002
Define LL_DLGBOXMODE_ALT2                               FOR |CI$0003
Define LL_DLGBOXMODE_ALT3                               FOR |CI$0004
Define LL_DLGBOXMODE_ALT4                               FOR |CI$0005
Define LL_DLGBOXMODE_ALT5                               FOR |CI$0006
Define LL_DLGBOXMODE_ALT6                               FOR |CI$0007
Define LL_DLGBOXMODE_ALT7                               FOR |CI$0008
Define LL_DLGBOXMODE_ALT8                               FOR |CI$0009            // Win95
Define LL_DLGBOXMODE_ALT9                               FOR |CI$000A            // Win98
Define LL_DLGBOXMODE_ALT10                              FOR |CI$000B            // Win98 with gray/color button bitmaps like IE4
Define LL_DLGBOXMODE_TOOLTIPS98                         FOR |CI$0800            // 'OR'ed - sliding tooltips
Define LL_CTL_ADDTOSYSMENU                              FOR |CI$00000004        // From CTL
Define LL_CTL_ALSOCHILDREN                              FOR |CI$00000010
Define LL_CTL_CONVERTCONTROLS                           FOR |CI$00010000
Define LL_GROUP_ALWAYSFOOTER                            FOR |CI$40000000
Define LL_PRINTERCONFIG_SAVE                            FOR 1
Define LL_PRINTERCONFIG_RESTORE                         for 2
#IF (USELLVERSION>15)
Define LL_PRJTYPE_OPTION_FORCEDEFAULTSETTINGS           for |CI$8000              
#ENDIF
#IF (USELLVERSION>17)
Define LL_PRJTYPE_OPTION_CREATEPARTSFROMPROJECT         for |CI$4000
#ENDIF
#IF (USELLVERSION>24)
Define LL_PRJTYPE_OPTION_NOMERGEPRINTERSETTINGS         for |CI$2000
#ENDIF
Define LL_RTFTEXTMODE_RTF                               FOR |CI$0000
Define LL_RTFTEXTMODE_PLAIN                             FOR |CI$0001
Define LL_RTFTEXTMODE_EVALUATED                         FOR |CI$0000
Define LL_RTFTEXTMODE_RAW                               for |CI$0002
#IF (USELLVERSION>18)
Define LL_RTFTEXTFLAG_ALL                               for |CI$0000
Define LL_RTFTEXTFLAG_SELECTION                         for |CI$0004
#ENDIF
#IF (USELLVERSION>25)
Define LL_ENUMFLAG_INCLUDE_INTERNAL                     for 1                   // include internal variables/fields
#ENDIF
Define LL_ERR_BAD_JOBHANDLE                             FOR -1                  // bad jobhandle
Define LL_ERR_TASK_ACTIVE                               FOR -2                  // LlDefineLayout() only once In a job
Define LL_ERR_BAD_OBJECTTYPE                            FOR -3                  // nObjType must be one Of the allowed values (obsolete constant)
Define LL_ERR_BAD_PROJECTTYPE                           FOR -3                  // nObjType must be one Of the allowed values
Define LL_ERR_PRINTING_JOB                              FOR -4                  // print job Not opened, no print Object
Define LL_ERR_NO_BOX                                    FOR -5                  // LlPrintSetBoxText(...) called when no abort box exists!
Define LL_ERR_ALREADY_PRINTING                          FOR -6                  // LlPrintWithBoxStart(...): another print job is being done, please wait Or try LlPrintStart(...)
Define LL_ERR_NOT_YET_PRINTING                          FOR -7                  // LlPrintGetOptionString...
Define LL_ERR_NO_PROJECT                                FOR -10                 // Object with requested name does Not exist (former ERR_NO_OBJECT)
Define LL_ERR_NO_PRINTER                                FOR -11                 // printer couldn't be opened
Define LL_ERR_PRINTING                                  FOR -12                 // error While printing
Define LL_ERR_EXPORTING                                 FOR -13                 // error While exporting
Define LL_ERR_NEEDS_VB                                  FOR -14                 // '11...' needs VB.EXE
Define LL_ERR_BAD_PRINTER                               FOR -15                 // PrintOptionsDialog(): no printer available
Define LL_ERR_NO_PREVIEWMODE                            FOR -16                 // Preview functions: Not In preview mode
Define LL_ERR_NO_PREVIEWFILES                           FOR -17                 // PreviewDisplay(): no file found
Define LL_ERR_PARAMETER                                 FOR -18                 // bad parameter (usually NULL Pointer)
Define LL_ERR_BAD_EXPRESSION                            FOR -19                 // bad expression In LlExprEvaluate() And LlExprType()
Define LL_ERR_BAD_EXPRMODE                              FOR -20                 // bad expression mode (LlSetExpressionMode())
Define LL_ERR_NO_TABLE                                  FOR -21                 // Not used
Define LL_ERR_CFGNOTFOUND                               FOR -22                 // on LlPrintStart(), LlPrintWithBoxStart() [Not found]
Define LL_ERR_EXPRESSION                                FOR -23                 // on LlPrintStart(), LlPrintWithBoxStart()
Define LL_ERR_CFGBADFILE                                FOR -24                 // on LlPrintStart(), LlPrintWithBoxStart() [read error, bad format]
Define LL_ERR_BADOBJNAME                                FOR -25                 // on LlPrintEnableObject() - Not a ':' at the beginning
Define LL_ERR_NOOBJECT                                  FOR -26                 // on LlPrintEnableObject() - "*" And no Object In project
Define LL_ERR_UNKNOWNOBJECT                             FOR -27                 // on LlPrintEnableObject() - Object with that name Not existing
Define LL_ERR_NO_TABLEOBJECT                            FOR -28                 // LlPrint...Start() And no list In Project, Or:
Define LL_ERR_NO_OBJECT                                 FOR -29                 // LlPrint...Start() And no Object In project
Define LL_ERR_NO_TEXTOBJECT                             FOR -30                 // LlPrintGetTextCharsPrinted() And no printable text In Project!
Define LL_ERR_UNKNOWN                                   FOR -31                 // LlPrintIsVariableUsed(), LlPrintIsFieldUsed()
Define LL_ERR_BAD_MODE                                  FOR -32                 // LlPrintFields(), LlPrintIsFieldUsed() called on non-OBJECT_LIST
Define LL_ERR_CFGBADMODE                                FOR -33                 // on LlDefineLayout(), LlPrint...Start(): file is In wrong expression mode
Define LL_ERR_ONLYWITHONETABLE                          FOR -34                 // on LlDefinePageSeparation(), LlDefineGrouping()
Define LL_ERR_UNKNOWNVARIABLE                           FOR -35                 // on LlGet4Contents()
Define LL_ERR_UNKNOWNFIELD                              FOR -36                 // on LlGetFieldContents()
Define LL_ERR_UNKNOWNSORTORDER                          FOR -37                 // on LlGetFieldContents()
Define LL_ERR_NOPRINTERCFG                              FOR -38                 // on LlPrintCopyPrinterConfiguration() - no Or bad file
Define LL_ERR_SAVEPRINTERCFG                            FOR -39                 // on LlPrintCopyPrinterConfiguration() - file could Not be saved
Define LL_ERR_RESERVED                                  FOR -40                 // Function Not yet implemeted
Define LL_ERR_NOVALIDPAGES                              FOR -41                 // could also be that 16 bit Viewer tries to Open 32bit-only storage
Define LL_ERR_NOTINHOSTPRINTERMODE                      FOR -42                 // cannot be done In Host Printer Mode (LlSetPrinterInPrinterFile())
Define LL_ERR_NOTFINISHED                               FOR -43                 // appears when a project reset() is done, but the table Not finished
Define LL_ERR_BUFFERTOOSMALL                            FOR -44                 // LlXXGetOptionStr()
Define LL_ERR_BADCODEPAGE                               FOR -45                 // LL_OPTION_CODEPAGE
Define LL_ERR_CANNOTCREATETEMPFILE                      FOR -46                 // cannot create temporary file
Define LL_ERR_NODESTINATION                             FOR -47                 // no valid export destination
Define LL_ERR_NOCHART                                   FOR -48                 // no chart control present
Define LL_ERR_TOO_MANY_CONCURRENT_PRINTJOBS             FOR -49                 // WebServer: Not enough print process licenses
Define LL_ERR_BAD_WEBSERVER_LICENSE                     FOR -50                 // WebServer: bad license file
Define LL_ERR_NO_WEBSERVER_LICENSE                      FOR -51                 // WebServer: no license file
Define LL_ERR_INVALIDDATE                               FOR -52                 // LlSystemTimeFromLocaleString(): Date Not valid!
Define LL_ERR_DRAWINGNOTFOUND                           FOR -53                 // only If LL_OPTION_ERR_ON_FILENOTFOUND Set
Define LL_ERR_NOUSERINTERACTION                         FOR -54                 // a call is used which would show a dialog, but LL is In Webserver mode
Define LL_ERR_BADDATABASESTRUCTURE                      FOR -55                 // the project that is loading has a table that is Not supported by the database
Define LL_ERR_UNKNOWNPROPERTY                           FOR -56               
Define LL_ERR_INVALIDOPERATION                          FOR -57               
Define LL_ERR_PROPERTY_ALREADY_DEFINED                  FOR -58               
Define LL_ERR_CFGFOUND                                  FOR -59                 // on LlPrjOpne() with CREATE_NEW disposition
Define LL_ERR_SAVECFG                                   for -60                 // error While saving (LlProjectSave())
Define LL_ERR_WRONGTHREAD                               for -61                 // internal (.NET)
#IF (USELLVERSION>19) 
Define LL_ERR_NO_SUCH_INFORMATION                       for -62
#ENDIF
#IF (USELLVERSION>21)
Define LL_ERR_SINK_ALREADY_PRESENT                      for -63
Define LL_ERR_SINK_NOT_PRESENT                          for -64
Define LL_ERR_ACCESS_DENIED                             for -65
#ENDIF
Define LL_ERR_USER_ABORTED                              FOR -99                 // user aborted printing
Define LL_ERR_BAD_DLLS                                  FOR -100                // DLLs Not up to Date (CTL, DWG, UTIL)
Define LL_ERR_NO_LANG_DLL                               FOR -101                // no Or out-Of-Date language resource DLL
Define LL_ERR_NO_MEMORY                                 FOR -102                // out Of memory
Define LL_ERR_WIN32ONLY                                 FOR -103                // this Function is only available In Win32
Define LL_ERR_EXCEPTION                                 FOR -104                // there was a GPF during the API execution. Any action that follows might cause problems!
Define LL_ERR_LICENSEVIOLATION                          for -105                // your license does Not allow this call (see LL_OPTIONSTR_LICENSINGINFO)
#IF (USELLVERSION>18)
Define LL_ERR_NOT_SUPPORTED_IN_THIS_OS                  for -106                // the OS does not support this Function
#ENDIF
#IF (USELLVERSION>19) 
Define LL_ERR_NO_MORE_DATA                              for -107
#ENDIF
#IF (USELLVERSION>24)
Define LL_WRN_FIRSTWARNING                              for -900
#ENDIF
#IF (USELLVERSION>18)
Define LL_WRN_REPORTPARAMETERS_COLLECTION_FINISHED      for -994                // internal Use
#ENDIF
Define LL_WRN_ISNULL                                    FOR -995                // LlExprEvaluate[Var]()
Define LL_WRN_TABLECHANGE                               FOR -996
Define LL_WRN_PRINTFINISHED                             FOR -997                // LlRTFDisplay()
Define LL_WRN_REPEAT_DATA                               FOR -998                // notification: page is full, prepare FOR next page
Define LL_CHAR_TEXTQUOTE                                for 1
#IF (USELLVERSION>20) 
Define LL_CHAR_PHANTOMSPACE                             for |CI$200b
Define LL_CHAR_LOCK                                     for |CI$2060
#ELSE
Define LL_CHAR_PHANTOMSPACE                             FOR 2
Define LL_CHAR_LOCK                                     for 3
#ENDIF
Define LL_CHAR_NEWLINE                                  FOR 182                 // ""
Define LL_CHAR_EXPRSEP                                  FOR 164                 // ""
Define LL_CHAR_TAB                                      FOR 247                 // "~"
Define LL_CHAR_EAN128NUL                                FOR 255
Define LL_CHAR_EAN128FNC1                               FOR 254
Define LL_CHAR_EAN128FNC2                               FOR 253
Define LL_CHAR_EAN128FNC3                               FOR 252
Define LL_CHAR_EAN128FNC4                               FOR 251
Define LL_CHAR_CODE93NUL                                FOR 255
Define LL_CHAR_CODE93EXDOLLAR                           FOR 254
Define LL_CHAR_CODE93EXPERC                             FOR 253
Define LL_CHAR_CODE93EXSLASH                            FOR 252
Define LL_CHAR_CODE93EXPLUS                             FOR 251
Define LL_CHAR_CODE39NUL                                FOR 255                   
Define LL_DLGEXPR_VAREXTBTN_ENABLE                      FOR |CI$00000001        // callback FOR simple Wizard extension
Define LL_DLGEXPR_VAREXTBTN_DOMODAL                     FOR |CI$00000002
Define LL_LLX_EXTENSIONTYPE_EXPORT                      FOR 1
Define LL_LLX_EXTENSIONTYPE_BARCODE                     FOR 2
Define LL_LLX_EXTENSIONTYPE_OBJECT                      FOR 3                   // nyi
Define LL_LLX_EXTENSIONTYPE_WIZARD                      for 4                   // nyi
#IF (USELLVERSION>21)
Define LL_LLX_EXTENSIONTYPEFLAG_FORCE_PUBLIC            for |CI$00010000
Define LL_LLX_EXTENSIONTYPEFLAG_FORCE_PRIVATE           for |CI$00020000
Define LL_LLX_EXTENSIONTYPE_TYPEMASK                    for |CI$0000000f
#ENDIF
Define LL_DECLARECHARTROW_FOR_OBJECTS                   FOR |CI$00000001
Define LL_DECLARECHARTROW_FOR_TABLECOLUMNS              FOR |CI$00000002        // body only
Define LL_DECLARECHARTROW_FOR_TABLECOLUMNS_FOOTERS      FOR |CI$00000004
Define LL_GETCHARTOBJECTCOUNT_CHARTOBJECTS              FOR 1
Define LL_GETCHARTOBJECTCOUNT_CHARTOBJECTS_BEFORE_TABLE FOR 2
Define LL_GETCHARTOBJECTCOUNT_CHARTCOLUMNS              FOR 3                   // body only
Define LL_GETCHARTOBJECTCOUNT_CHARTCOLUMNS_FOOTERS      FOR 4
Define LL_VARIANTFLAG_NEUTRAL                           FOR |CI$00000000
Define LL_VARIANTFLAG_USE_JULIAN_DATE                   FOR |CI$00000001
Define LL_GRIPT_DIM_SCM                                 FOR 1                 
Define LL_GRIPT_DIM_PERC                                FOR 2                 
Define LL_PARAMETERFLAG_PUBLIC                          FOR |CI$00000000
Define LL_PARAMETERFLAG_SAVEDEFAULT                     FOR |CI$00010000
Define LL_PARAMETERFLAG_PRIVATE                         FOR |CI$40000000
Define LL_PARAMETERFLAG_FORMULA                         FOR |CI$00000000
Define LL_PARAMETERFLAG_VALUE                           FOR |CI$20000000
Define LL_PARAMETERFLAG_GLOBAL                          FOR |CI$00000000
Define LL_PARAMETERFLAG_LOCAL                           FOR |CI$10000000
Define LL_PARAMETERFLAG_MASK                            FOR |CI$FFFF0000
Define LL_PARAMETERTYPE_USER                            FOR 0                 
Define LL_PARAMETERTYPE_FAX                             FOR 1                 
Define LL_PARAMETERTYPE_MAIL                            FOR 2
Define LL_PARAMETERTYPE_LLINTERNAL                      FOR 4
Define LL_PARAMETERTYPE_MASK                            FOR |CI$0000000F
Define LL_LOCCONVERSION_LCID                            FOR 0
Define LL_LOCCONVERSION_COUNTRYPREFIX                   FOR 1
Define LL_LOCCONVERSION_COUNTRYISONAME                  FOR 2
Define LL_LOCCONVERSION_DIALPREFIX                      FOR 3                   // Not yet implemented
Define LL_PRJOPEN_AM_READWRITE                          FOR |CI$40000000
Define LL_PRJOPEN_AM_READONLY                           FOR |CI$00000000        // default
Define LL_PRJOPEN_AM_MASK                               FOR |CI$40000000        
Define LL_PRJOPEN_CD_OPEN_EXISTING                      FOR |CI$00000000        // fails If it does Not exist - default
Define LL_PRJOPEN_CD_CREATE_ALWAYS                      FOR |CI$10000000        // Open (but do Not read contents) If exists, create If Not
Define LL_PRJOPEN_CD_CREATE_NEW                         FOR |CI$20000000        // fails If already exists
Define LL_PRJOPEN_CD_OPEN_ALWAYS                        FOR |CI$30000000        // Open (And load) If exists, create If Not
Define LL_PRJOPEN_CD_MASK                               FOR |CI$30000000        // fails If it does Not exist
Define LL_PRJOPEN_EM_IGNORE_FORMULAERRORS               FOR |CI$08000000        
Define LL_PRJOPEN_EM_MASK                               for |CI$08000000 
Define LL_PRJOPEN_FLG_NOINITPRINTER                             for |CI$04000000
Define LL_PRJOPEN_FLG_NOOBJECTLOAD                              for |CI$02000000
#IF (USELLVERSION>15)
Define LL_PRJOPEN_FLG_RESERVED                                  for |CI$01000000          // internal use 
#ENDIF
Define LL_ASSOCIATEPREVIEWCONTROLFLAG_DELETE_ON_CLOSE           for |CI$0001
Define LL_ASSOCIATEPREVIEWCONTROLFLAG_HANDLE_IS_ATTACHINFO      for |CI$0002
Define LL_ASSOCIATEPREVIEWCONTROLFLAG_PRV_REPLACE               for |CI$0000
Define LL_ASSOCIATEPREVIEWCONTROLFLAG_PRV_ADD_TO_CONTROL_STACK  for |CI$0004
Define LL_ASSOCIATEPREVIEWCONTROLFLAG_PRV_ADD_TO_CONTROL_IN_TAB for |CI$0008
Define LL_ASSOCIATEPREVIEWCONTROLMASK_ATTACHLOCATION            for |CI$003c
Define LL_DESFILEOPEN_OPEN_EXISTING                     FOR |CI$00000000        // fails If it does not exist - default
Define LL_DESFILEOPEN_CREATE_ALWAYS                     FOR |CI$10000000        // Open (but do not Read contents) If exists, create If not
Define LL_DESFILEOPEN_CREATE_NEW                        FOR |CI$20000000        // fails If already exists
Define LL_DESFILEOPEN_OPEN_ALWAYS                       FOR |CI$30000000        // Open (and load) If exists, create If not
Define LL_DESFILEOPEN_OPEN_IMPORT                       FOR |CI$40000000        // fails If it does not exist - only imports data
Define LL_DESFILEOPEN_OPENMASK                          FOR |CI$70000000        
Define LL_DESFILEOPENFLAG_SUPPRESS_SAVEDIALOG           FOR |CI$00000001        
Define LL_DESFILEOPENFLAG_SUPPRESS_SAVE                 FOR |CI$00000002        
Define LL_DESFILESAVE_DEFAULT                           FOR |CI$00000000        // default
Define LLDESADDACTIONFLAG_ADD_TO_TOOLBAR                FOR |CI$20000000        
Define LLDESADDACTION_MENUITEM_APPEND                   FOR |CI$00000000        
Define LLDESADDACTION_MENUITEM_INSERT                   FOR |CI$10000000        
Define LLDESADDACTION_MENUITEM_POSITIONMASK             FOR |CI$10000000        
Define LLDESADDACTION_ACCEL_CONTROL                     FOR |CI$00010000        
Define LLDESADDACTION_ACCEL_SHIFT                       FOR |CI$00020000        
Define LLDESADDACTION_ACCEL_ALT                         FOR |CI$00040000        
Define LLDESADDACTION_ACCEL_VIRTKEY                     FOR |CI$00080000        
Define LLDESADDACTION_ACCEL_KEYMODIFIERMASK             FOR |CI$000f0000        
Define LLDESADDACTION_ACCEL_KEYCODEMASK                 FOR |CI$0000ffff        
Define LL_DESIGNEROPTSTR_PROJECTFILENAME                FOR 1
Define LL_DESIGNEROPTSTR_WORKSPACETITLE                 FOR 2
Define LL_DESIGNEROPTSTR_PROJECTDESCRIPTION             for 3
Define LL_USEDIDENTIFIERSFLAG_VARIABLES                 for |CI$0001
Define LL_USEDIDENTIFIERSFLAG_FIELDS                    for |CI$0002
Define LL_USEDIDENTIFIERSFLAG_CHARTFIELDS               for |CI$0004
Define LL_USEDIDENTIFIERSFLAG_TABLES                    for |CI$0008
Define LL_USEDIDENTIFIERSFLAG_RELATIONS                 for |CI$0010
Define LL_TEMPFILENAME_DEFAULT                          for |CI$0000
Define LL_TEMPFILENAME_ENSURELONGPATH                   for |CI$0001
#IF (USELLVERSION>15)
Define LL_DICTIONARY_TYPE_STATIC                        for 1
Define LL_DICTIONARY_TYPE_IDENTIFIER                    for 2
Define LL_DICTIONARY_TYPE_TABLE                         for 3
Define LL_DICTIONARY_TYPE_RELATION                      for 4
Define LL_DICTIONARY_TYPE_SORTORDER                     for 5
#ENDIF
#IF (USELLVERSION>17)   
Define LL_DICTIONARY_TYPE_ALL                           for 0                   // only valid for NULL, NULL to Clear all dictionaries in one run
Define LL_UILANGUAGETYPE_NORMAL                         for |CI$00000001
Define LL_UILANGUAGETYPE_TRIAL                          for |CI$00000002
Define LL_ADDTABLEOPT_SUPPORTSSTACKEDSORTORDERS         for |CI$00000001
Define LL_INPLACEDESIGNERINTERACTION_QUERY_CANCLOSE     for 1                   // wParam = 0, lParam = &BOOL
Define LL_JOBSTATEFLAG_VARLIST                          for |CI$00000001
Define LL_JOBSTATEFLAG_FIELDLIST                        for |CI$00000002
Define LL_JOBSTATEFLAG_CHARTFIELDLIST                   for |CI$00000004
Define LL_JOBSTATEFLAG_DATABASESTRUCT                   for |CI$00000008
Define LL_JOBSTATEFLAG_DICTIONARIES                     for |CI$00000010
Define LL_JOBSTATEFLAG_JOBSETTINGS                      for |CI$00000020
Define LL_JOBSTATEFLAG_ALL                              for |CI$0000003F
#ENDIF
#IF (USELLVERSION>19)
Define LL_EXPRXLATRESULT_OPTIMAL                        for |CI$00000000
Define LL_EXPRXLATRESULT_PARTIAL                        for |CI$00000001
Define LL_EXPRXLATRESULT_FAIL                           for |CI$00000002
Define LL_EXPRXLATRESULT_MASK                           for |CI$00000007        // some reserve
Define LLSTGTESTSTGCMP_MASK_PAGECOUNT                   for |CI$000000ff
Define LLSTGTESTSTGCMP_FLAG_PRVSINGLEPAGE               for |CI$00000100
#ENDIF
#IF (USELLVERSION>23)
Define LLSTGTESTSTGCMP_FLAG_EXCLUDE_EMBEDDEDSTORAGES    for |CI$00000200
#ENDIF
#IF (USELLVERSION>20)
Define LLJOBOPENCOPYEXFLAG_NO_COPY_FIELDLIST            for |CI$0001
Define LLJOBOPENCOPYEXFLAG_NO_COPY_DBSTRUCTS            for |CI$0002
Define LLJOBOPENCOPYEXFLAG_NO_COPY_XLATTABLES           for |CI$0004
#ENDIF

#IF (USELLVERSION>15)
Define LLR_LCID_GERMAN                                  for |CI$07
Define LLR_LCID_ENGLISH                                 for |CI$09
Define LLR_LCID_ARABIC                                  for |CI$01
Define LLR_LCID_ALBANIAN                                for |CI$1C
Define LLR_LCID_BASQUE                                  for |CI$2D
Define LLR_LCID_BULGARIAN                               for |CI$02
Define LLR_LCID_CATALAN                                 for |CI$03
Define LLR_LCID_CHINESE                                 for |CI$04
Define LLR_LCID_CROATIAN                                for |CI$1A
Define LLR_LCID_CZECH                                   for |CI$05
Define LLR_LCID_DANISH                                  for |CI$06
Define LLR_LCID_DUTCH                                   for |CI$13
Define LLR_LCID_ESTONIAN                                for |CI$25
Define LLR_LCID_FAEROESE                                for |CI$38
Define LLR_LCID_FARSI                                   for |CI$29
Define LLR_LCID_FINNISH                                 for |CI$0B
Define LLR_LCID_FRENCH                                  for |CI$0C
Define LLR_LCID_GREEK                                   for |CI$08
Define LLR_LCID_HEBREW                                  for |CI$0D
Define LLR_LCID_HUNGARIAN                               for |CI$0E
Define LLR_LCID_ICELANDIC                               for |CI$0F
Define LLR_LCID_INDONESIAN                              for |CI$21
Define LLR_LCID_ITALIAN                                 for |CI$10
Define LLR_LCID_JAPANESE                                for |CI$11
Define LLR_LCID_KOREAN                                  for |CI$12
Define LLR_LCID_LATVIAN                                 for |CI$26
Define LLR_LCID_LITHUANIAN                              for |CI$27
Define LLR_LCID_NORWEGIAN                               for |CI$14
Define LLR_LCID_POLISH                                  for |CI$15
Define LLR_LCID_PORTUGUESE                              for |CI$16
Define LLR_LCID_ROMANIAN                                for |CI$18
Define LLR_LCID_RUSSIAN                                 for |CI$19
Define LLR_LCID_SLOVAK                                  for |CI$1B
Define LLR_LCID_SLOVENIAN                               for |CI$24
Define LLR_LCID_SERBIAN                                 for |CI$1A
Define LLR_LCID_SPANISH                                 for |CI$0A
Define LLR_LCID_SWEDISH                                 for |CI$1D
Define LLR_LCID_THAI                                    for |CI$1E
Define LLR_LCID_TURKISH                                 for |CI$1F
Define LLR_LCID_UKRAINIAN                               for |CI$22
#ENDIF


// **********************************************************************************************************    
// Defines the needed Types: Only the needed ones are defined and tested
// **********************************************************************************************************

#IF (!@>199)
Struct scLLCallback
    UInteger nSize
    #IFDEF Is$Win64
    Integer  iAlign1
    #ENDIF
    Longptr lParam
    Longptr lResult
    Longptr lUserParameter
End_Struct
#ELSE
Struct scLLCallback
    Integer nSize
    Integer lParam
    Integer lResult
    Integer lUserParameter
End_Struct
#ENDIF

Struct scLLMeterinfo
    Integer nSize
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF            
    Handle  hWnd
    Integer nTotal
    Integer nCurrent
    Integer nJob
End_Struct

#IF (!@>199)
Struct scLLExtFct
    Integer nSize
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF    
    Pointer pSzContent
    Integer bEvaluate
    Char[32772] szNewValue
    Integer bError
    Char[256] szError
    #IFDEF Is$Win64
    Integer iAlign2
    #ENDIF        
End_Struct
#ELSE
Struct scLLExtFct
    Integer nSize
    Pointer pSzContent
    Integer bEvaluate
    Char[16388] szNewValue
    Integer bError
    Char[128] szError
End_Struct
#ENDIF

Struct scLLObject
    Integer nSize
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF            
    Pointer pszName
    Integer nType
    Integer bPreDraw
    Handle  hRefDC
    Handle  hPaintDC
    tWinRect rcPaint
End_Struct

#IF (!@>199)
Struct scLLPage
    Integer nSize
    Integer bDesignerPerview
    Integer bPreDraw
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF
    Handle  hRefDC
    Handle  hPaintDC
End_Struct
#ELSE
Struct scLLPage
    Integer nSize
    Integer bDesignerPerview
    Integer bPreDraw
    Handle  hRefDC
    Handle  hPaintDC
End_Struct
#ENDIF

Struct scLLProjectUserData
    Integer nSize
    Integer bdesignerPreview
    Integer bPreDraw
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF            
    Handle  hRefDC
    Handle  hPaintDC
    tWinRect rcPaint
End_Struct

Struct scLLUserObject
    Integer nSize
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF            
    Pointer pszName
    Pointer pszContents
    DWord   lPara
    #IFDEF Is$Win64
    Integer iAlign2
    #ENDIF            
    Pointer lpPtr
    Handle  hPara
    Integer bIsotropic
    Pointer pszParameters
    Handle  hRefDC
    Handle  hPaintDC
    tWinRect rcPaint
    Integer nPaintMode
End_Struct

Struct scLLEditUserObj
    Integer nSize
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF            
    Pointer pszName
    DWord   lPara
    #IFDEF Is$Win64
    Integer iAlign2
    #ENDIF            
    Pointer lpPtr
    Handle  hPara
    Integer bIsotropic
    #IFDEF Is$Win64
    Integer iAlign3
    #ENDIF            
    Handle  hWnd
    Pointer pszParameters
    Integer nParaBufSize
End_Struct

Struct scLLTableLine
    Integer nSize
    Integer nType
    Handle  hRefDC
    Handle  hPaintDC
    tWinRect rcPaint
    Integer nPageLine
    Integer nLine
    Integer nLineDef
    Integer bZebra
    tWinRect rcSpacing
End_Struct

Struct scLLTableField
    Integer nSize
    Integer nType
    Handle  hRefDC
    Handle  hPaintDC 
    tWinRect rcPaint
    Integer nLineDef
    Integer nIndex
    tWinRect rcSpacing
End_Struct

#IF (!@>199)
Struct scLLPrinter
    Integer nSize
    Integer bFirst
    Integer nCmd
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF
    Handle  hwnd
    Handle  hDC
    Integer nOrientation
    Integer bPhysPage
    Integer nBufSize
    #IFDEF Is$Win64
    Integer iAlign2
    #ENDIF
    Pointer pszBuffer
    Integer UniqueNumber 
    Integer UniqueNumberCompare 
    Integer nPaperformat 
    Integer xPapersize 
    Integer yPapersize 
    #IFDEF Is$Win64
    Integer iAlign3
    #ENDIF    
End_Struct
#ELSE
Struct scLLPrinter
    Integer nSize
    Integer bFirst
    Integer nCmd
    Handle  hwnd
    Handle  hDC
    Integer nOrientation
    Integer bPhysPage
    Integer nBufSize
    Pointer pszBuffer
    Integer UniqueNumber 
    Integer UniqueNumberCompare 
    Integer nPaperformat 
    Integer xPapersize 
    Integer yPapersize 
End_Struct
#ENDIF
#IF (!@>191)
Struct scLLMenuItemInfo      
    Integer cbSize
    Integer fMask
    Integer fType
    Integer fState
    Integer wID 
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF
    Handle  hSubMenu
    Handle  hBmpChecked 
    Handle  hBmpUnchecked
    Pointer dwItemData
    Pointer dwTypeData
    Integer cch
    #IFDEF Is$Win64
    Integer iAlign2
    #ENDIF    
    Handle hBmpItem
End_Struct
#ELSE
Struct scLLMenuItemInfo      
    Integer cbSize
    Integer fMask
    Integer fType
    Integer fState
    Integer wID 
    Handle  hSubMenu
    Handle  hBmpChecked 
    Handle  hBmpUnchecked
    DWord   dwItemData
    Pointer dwTypeData
    Integer cch
End_Struct
#ENDIF
#IF (!@>109)
Struct scLLDrilldownJob
    Integer  nSize
    Integer  nFunction
    Pointer  pUserParameter
    Pointer  pszTableID
    Pointer  pszRelationID
    Pointer  pszSubreportTableID
    Pointer  pszKeyField
    Pointer  pszSubreportKeyField
    Pointer  pszKeyValue
    Pointer  pszProjectFileName
    Pointer  pszPreviewFileName
    Pointer  pszTooltipText
    Pointer  pszTabText
    Handle   hWnd
    Integer  nID
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF        
    Handle   hAttachInfo
#IF (USELLVERSION>19)
    Pointer  pszSRID
    Pointer  pszExportFormat
#ENDIF    
End_Struct
#IF (!@>199)
Struct scLLDesginerPrintJob
    Integer nSize
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF    
    Pointer nUserParam
    Pointer pszProjectFileName
    Pointer pszOriginalProjectFileName
    Integer nPages
    Integer nFunction
    Handle  hWnd
    Handle  hEvent
    Pointer pszExportFormat
    Integer bWithoutDialog
    #IFDEF Is$Win64
    Integer iAlign2
    #ENDIF    
End_Struct
#ELSE
Struct scLLDesginerPrintJob
    Integer nSize
    Integer nUserParam
    Pointer pszProjectFileName
    Pointer pszOriginalProjectFileName
    Integer nPages
    Integer nFunction
    Handle  hWnd
    Handle  hEvent
End_Struct
#ENDIF
Struct scLLDDFilterInfo
    Integer nSize
    Integer hLlJob
    Pointer pszParentTableID
    Pointer pszSubreportTableID
    Pointer pszRelationID
    Pointer pszAllowedTables
    Integer nBufSize // size of buffer '_pszAllowedTables' points to. If a larger buffer is needed, _pszAllowedTables must be changed to point to that (static) buffer in the host application
    #IFDEF Is$Win64
    Integer iAlign2
    #ENDIF        
End_Struct
#ENDIF
#IF (USELLVERSION>19)
Struct scLLNtfyHyperlink
   Integer nSize
   Integer nAction
   Pointer pvHoverTooltip
   Pointer pwszProtocol
   Pointer pwszData
End_Struct  
Define HLACTION_Q_RBUTTONALLOWED for 1
Define HLACTION_LCLICKED for 2
Define HLACTION_RCLICKED for 3    
#ENDIF

Define LL_REPORT_USEDEFAULT for -101
Define LL_REPORT_RECORDFOUND for 0
Define LL_REPORT_EOF for -102
Define LL_REPORT_SKIPRECORD for -103
Define LL_REPORT_CANCELPRINT for -104
Define LL_REPORT_SKIPTABLE for -105
Define LL_INDEX_OPTIMIZED_UP for 9998
Define LL_INDEX_OPTIMIZED_DOWN for 9999 
Define LL_DRILLDOWN_SHOWTABLE for -106
Define LL_DRILLDOWN_HIDETABLE for -107




// **********************************************************************************************************
// Some more available types: Not needed so far
// **********************************************************************************************************

//
// typedef LRESULT (FAR PASCAL *LLNOTIFICATION)(UINT nMessage, LPARAM lParam, UINT32 lUserParam); // use MakeProcInstance or smart callbacks
//

// typedef struct                    // for VC++
//   {
//   UINT32   FAR *ppStruct;
//  LPVOID nIndex;
//   } PTRPARAM;
// typedef struct                    // for VC++
//   {
//  INT  FAR *ppnID;
//  INT  FAR *ppnType;
//  LPVOID nIndex;
//   } HELPPARAM;
// typedef struct                    // for VC++
//   {
//   INT     FAR *ppnFunction;
//  LPVOID nIndex;
//   } NTFYBTNPARAM;
// typedef struct
//  {
//  UINT  _nSize;     // size of the structure
//  UINT _nFunction;    // function code (LL_DLGEXPR_VAREXTBTN_xxx)
//   HWND _hWndDialog;   // dialog handle
//  LPCSTR _pszPage;    // "CondDlgVar"
//   Char _szValue[0x4000+1];  // new value
//   UINT _bFields;    // FALSE
//  UINT32 _nMask;     // LL_TEXT, ... OR LL_FOOTERFIELD...
//  } scLlDlgExprVarExtA;
// #If WIN16
//   typedef scLlDlgExprVarExtA scLlDlgExprVarExt, FAR* PSCLLDLGEXPRVAREXT;
// #ELSE
//   typedef struct
//    {
//    UINT     _nSize;
//    UINT  _nFunction;
//     HWND  _hWndDialog;
//    LPCWSTR _pszPage;
//     WCHAR  _szValue[0x4000+1];
//     UINT  _bFields;
//    UINT32 _nMask;
//    } scLlDlgExprVarExtW;
//   #IFDEF UNICODE
//     typedef scLlDlgExprVarExtW scLlDlgExprVarExt, FAR* PSCLLDLGEXPRVAREXT;
//    #ELSE
//     typedef scLlDlgExprVarExtA scLlDlgExprVarExt, FAR* PSCLLDLGEXPRVAREXT;
//   #ENDIF
// #ENDIF
//
// typedef struct
//  {
//  UINT _nSize;
//  HWND _hWnd;
//  UINT _nType;
//  HMENU _hMenu;
//  UINT _nParam;
//  } scLlToolbar, FAR *PSCLLTOOLBAR;
//
// #ENDIF // ifndef IMPLEMENTATION
//
//
// #IFDEF _DEF_LLXINTERFACE // LL internal
//   #Include "lxoem.h"
// #ENDIF // _DEF_LLXINTERFACE
// struct scLlDlgEditLineExParams
//   {
//   INT   _nSize;
//   BOOL  _bEnableAskString;
//  };
// struct scLlDlgEditLineExParams8
//   {
//   INT   _nSize;
//   BOOL  _bEnableAskString;
//   UINT  _bIncludeChartFields;
//  };

// **********************************************************************************************************
// Defines the DLL-Calls to List & Label
// **********************************************************************************************************

external_function LlJobOpenEf "LlJobOpen" LLDllName Integer nLanguage Returns Integer
external_function LlJobOpenLCIDEf "LlJobOpenLCID" LLDllName Integer nLCID Returns Integer
external_function LlJobCloseEf "LlJobClose" LLDllName Integer hLLJob Returns Integer
external_function LlSetDebugEf "LlSetDebug" LLDllName Integer nOnOff Returns Integer
external_function LlGetVersionEf "LlGetVersion" LLDllName Integer nCmd Returns Integer
external_function LlGetNotificationMessageEf "LlGetNotificationMessage" LLDllName Integer hLLJob Returns Integer
External_Function LlSetNotificationMessageEf "LlSetNotificationMessage" LLDllName Integer hLLJob Integer nMessage Returns Integer
// New Unicode Defines starting with DataFlex 20.0
#IF (!@>199)  
External_Function LlDefineLayoutEf "LlDefineLayoutW" LLDllName Integer hLLJob Handle hWnd WString wTitle Integer nObjType WString wObjName Returns Integer
External_Function LlSetNotificationCallbackEf "LlSetNotificationCallback" LLDllName Integer hLLJob Longptr lpfnNotify Returns Longptr
External_Function LlDefineField "LlDefineFieldW" LLDllName Integer hLLJob WString wVarName WString wContents Returns Integer
External_Function LlDefineFieldEf "LlDefineFieldW" LLDllName Integer hLLJob WString wVarName WString wContents Returns Integer
External_Function LlDefineFieldExtEf "LlDefineFieldExtW" LLDllName Integer hLLJob WString wVarName Pointer lpbufContents Integer lPara Pointer lpPtr Returns Integer
External_Function LlDefineFieldExtHandleEf "LlDefineFieldExtHandleW" LLDllName Integer hLLJob WString wVarName Handle hContents Integer lPara Pointer lpPtr Returns Integer
External_Function LlDefineVariableEf "LlDefineVariableW" LLDllName Integer hLLJob WString wVarName WString wContents Returns Integer
External_Function LlDefineVariableExtEf "LlDefineVariableExtW" LLDllName Integer hLLJob WString wVarName Pointer lpbufContents Integer lPara Pointer lpPtr Returns Integer
External_Function LlDefineVariableExtHandleEf "LlDefineVariableExtHandleW" LLDllName Integer hLLJob WString wVarName Handle hContents Integer lPara Pointer lpPtr Returns Integer
External_Function LlDefineVariableNameEf "LlDefineVariableNameW" LLDllName Integer hLLJob WString wVarName Returns Integer
External_Function LlDefineSumVariableEf "LlDefineSumVariableW" LLDllName Integer hLLJob WString wVarName WString wContents Returns Integer
External_Function LlDlgEditLineEf "LlDlgEditLineW" LLDllName Integer hLLJob Handle hWnd Pointer lpBuf Integer nBufSize Returns Integer
External_Function LlDlgEditLineExEf "LlDlgEditLineExW" LLDllName Integer hLLJob Handle hWnd Pointer pszBuffer Integer nBufSize Integer nParaTypes WString wTitle Integer bTable Pointer pvReserved Returns Integer
External_Function LlPreviewSetTempPathEf "LlPreviewSetTempPathW" LLDllName Integer hLLJob WString wPath Returns Integer
External_Function LlPreviewDeleteFilesEf "LlPreviewDeleteFilesW" LLDllName Integer hLLJob WString wObjName WString wPath Returns Integer
External_Function LlPreviewDisplayEf "LlPreviewDisplayW" LLDllName Integer hLLJob WString wObjName WString wPath Handle hWnd Returns Integer
External_Function LlPreviewDisplayExEf "LlPreviewDisplayExW" LLDllName Integer hLLJob WString wObjName WString wPath Handle hWnd Integer nOptions Pointer pOptions Returns Integer
External_Function LlPrintGetRemainingItemsPerTableEf "LlPrintGetRemainingItemsPerTableW" LLDllName Integer hLLJob WString wField Returns Integer
External_Function LlPrintGetRemItemsPerTableEf "LlPrintGetRemItemsPerTableW" LLDllName Integer hLLJob WString wField Returns Integer
External_Function LlPrintOptionsDialogEf "LlPrintOptionsDialogW" LLDllName Integer hLLJob Handle hWnd WString wText Returns Integer
External_Function LlPrintGetPrinterInfoEf "LlPrintGetPrinterInfoW" LLDllName Integer hLLJob Pointer pszPrn Integer nPrnLen Pointer pszPort Integer nPortLen Returns Integer
External_Function LlPrintWithBoxStartEf "LlPrintWithBoxStartW" LLDllName Integer hLLJob Integer nObjType WString wObjName Integer nPrintOptions Integer nBoxType Handle hWnd WString wTitle Returns Integer
External_Function LlPrintSetBoxTextEf "LlPrintSetBoxTextW" LLDllName Integer hLLJob WString wText Integer nPercentage Returns Integer
External_Function LlPrintStartEf "LlPrintStartW" LLDllName Integer hLLJob Integer nObjType WString wObjName Integer nPrintOptions Integer iDummy Returns Integer
External_Function LlPrinterSetupEf "LlPrinterSetupW" LLDllName Integer hLLJob Handle hWnd Integer nObjType WString wObjName Returns Integer
External_Function LlSelectFileDlgTitleExEf "LlSelectFileDlgTitleExW" LLDllName Integer hLLJob Handle hWnd WString wTitle Integer nObjType Pointer pszObjName Integer nBufSize Pointer pReserved Returns Integer
External_Function LlExprParseEf "LlExprParseW" LLDllName Integer hLLJob WString wExprText Integer bIncludeFields Returns Pointer
External_Function LlExprErrorEf "LlExprErrorW" LLDllName Integer hLLJob Pointer pszBuf Integer nBufSize Returns Integer
External_Function LlExprEvaluateEf "LlExprEvaluateW" LLDllName Integer hLLJob Pointer lpExpr Pointer pszBuf Integer nBufSize Returns Integer
External_Function LlExprGetUsedVarsEf "LlExprGetUsedVarsW" LLDllName Integer hLLJob Pointer lpExpr Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlSetOptionStringEf "LlSetOptionStringW" LLDllName Integer hLLJob Integer nIndex WString wBuffer Returns Integer
External_Function LlGetOptionStringEf "LlGetOptionStringW" LLDllName Integer hLLJob Integer nIndex Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlPrintSetOptionStringEf "LlPrintSetOptionStringW" LLDllName Integer hLLJob Integer nIndex WString wBuffer Returns Integer
External_Function LlPrintGetOptionStringEf "LlPrintGetOptionStringW" LLDllName Integer hLLJob Integer nIndex Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlDesignerProhibitFunctionEf "LlDesignerProhibitFunctionW" LLDllName Integer hLLJob WString wFunction Returns Integer
External_Function LlPrintEnableObjectEf "LlPrintEnableObjectW" LLDllName Integer hLLJob WString wObjectName Integer bEnable Returns Integer
External_Function LlSetFileExtensionsEf "LlSetFileExtensionsW" LLDllName Integer hLLJob Integer nObjType WString wObjectExt WString wPrinterExt WString wSketchExt Returns Integer
External_Function LlPrintGetTextCharsPrintedEf "LlPrintGetTextCharsPrintedW" LLDllName Integer hLLJob WString wObjectName Returns Integer
External_Function LlPrintGetFieldCharsPrintedEf "LlPrintGetFieldCharsPrintedW" LLDllName Integer hLLJob WString wObjectName WString wField Returns Integer
External_Function LlPrintIsVariableUsedEf "LlPrintIsVariableUsedW" LLDllName Integer hLLJob WString wVarName Returns Integer
External_Function LlPrintIsFieldUsedEf "LlPrintIsFieldUsedW" LLDllName Integer hLLJob WString wFieldName Returns Integer
External_Function LlPrintOptionsDialogTitleEf "LlPrintOptionsDialogTitleW" LLDllName Integer hLLJob Handle hWnd WString wTitle WString wText Returns Integer
External_Function LlSetPrinterToDefaultEf "LlSetPrinterToDefaultW" LLDllName Integer hLLJob Integer nObjType WString wObjName Returns Integer
External_Function LlDefineSortOrderEf "LlDefineSortOrderW" LLDllName Integer hLLJob WString wIdentifier WString wText Returns Integer
External_Function LlPrintGetSortOrderEf "LlPrintGetSortOrderW" LLDllName Integer hLLJob Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlDefineGroupingEf "LlDefineGroupingW" LLDllName Integer hLLJob WString wSortorder WString wIdentifier WString wText Returns Integer
External_Function LlPrintGetGroupingEf "LlPrintGetGroupingW" LLDllName Integer hLLJob Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlAddCtlSupportEf "LlAddCtlSupportW" LLDllName Handle hWnd Integer nFlags WString wInifile Returns Integer
External_Function LlPrintGetFilterExpressionEf "LlPrintGetFilterExpressionW" LLDllName Integer hLLJob Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlGetFieldContentsEf "LlGetFieldContentsW" LLDllName Integer hLLJob WString wName Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlGetVariableContentsEf "LlGetVariableContentsW" LLDllName Integer hLLJob WString wName Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlGetSumVariableContentsEf "LlGetSumVariableContentsW" LLDllName Integer hLLJob WString wName Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlGetUserVariableContentsEf "LlGetUserVariableContentsW" LLDllName Integer hLLJob WString wName Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlGetVariableTypeEf "LlGetVariableTypeW" LLDllName Integer hLLJob WString wName Returns Integer
External_Function LlGetFieldTypeEf "LlGetFieldTypeW" LLDllName Integer hLLJob WString wName Returns Integer
External_Function LlPrintGetColumnInfoEf "LlPrintGetColumnInfoW" LLDllName Integer hLLJob WString wObjectName Integer nCol Pointer pCol Returns Integer
External_Function LlSetPrinterDefaultsDirEf "LlSetPrinterDefaultsDirW" LLDllName Integer hLLJob WString wDir Returns Integer
External_Function LlCreateSketchEf "LlCreateSketchW" LLDllName Integer hLLJob Integer nObjType WString wObjName Returns Integer
External_Function LlPrintCopyPrinterConfigurationEf "LlPrintCopyPrinterConfigurationW" LLDllName Integer hLLJob WString wFilename Integer nFunction Returns Integer
External_Function LlSetPrinterInPrinterFileEf "LlSetPrinterInPrinterFileW" LLDllName Integer hLLJob Integer nObjType WString wObjName Integer nPrinter WString wPrinter Pointer pDevMode Returns Integer
External_Function LlRTFSetTextEf "LlRTFSetTextW" LLDllName Integer hLLJob Handle hRTF WString wText Returns Integer
External_Function LlRTFGetTextEf "LlRTFGetTextW" LLDllName Integer hLLJob Handle hRTF Integer nFlags Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlDebugOutputEf "LlDebugOutputW" LLDllName Integer nIndent WString wText Returns Integer
External_Function LlEnumGetEntryEf "LlEnumGetEntryW" LLDllName Integer hLLJob Integer nPos Pointer pszNameBuf Integer nNameBufSize Pointer pszContBuf Integer nContBufSize Pointer pHandle Pointer pType Returns Integer
External_Function LlXSetParameterEf "LlXSetParameterW" LLDllName Integer hLLJob Integer nExtensionType WString wExtensionName WString wKey WString wValue Returns Integer
External_Function LlXGetParameterEf "LlXGetParameterW" LLDllName Integer hLLJob Integer nExtensionType WString wExtensionName WString wKey Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlDefineChartFieldExtEf "LlDefineChartFieldExtW" LLDllName Integer hLLJob WString wVarName WString wContents Integer lPara Pointer lpPtr Returns Integer
External_Function LlPrintIsChartFieldUsedEf "LlPrintIsChartFieldUsedW" LLDllName Integer hLLJob WString wFieldName Returns Integer
External_Function LlGetChartFieldContentsEf "LlGetChartFieldContentsW" LLDllName Integer hLLJob WString wName Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlGetPrinterFromPrinterFileEf "LlGetPrinterFromPrinterFileW" LLDllName Integer hJob Integer nObjType WString wObjectName Integer nPrinter Pointer pszPrinter Pointer pnPrinterBufSize Pointer pDevMode Pointer pnDevModeBufSize Returns Integer
External_Function LlPrintGetRemainingSpacePerTableEf "LlPrintGetRemainingSpacePerTableW" LLDllName Integer hLLJob WString wField Integer nDimension Returns Integer
External_Function LlSetDefaultProjectParameterEf "LlSetDefaultProjectParameterW" LLDllName Integer hLLJob WString wParameter WString wValue Integer nFlags Returns Integer
External_Function LlGetDefaultProjectParameterEf "LlGetDefaultProjectParameterW" LLDllName Integer hLLJob WString wParameter Pointer pszBuffer Integer nBufSize Pointer pnFlags Returns Integer
External_Function LlPrintSetProjectParameterEf "LlPrintSetProjectParameterW" LLDllName Integer hLLJob WString wParameter WString wValue Integer nFlags Returns Integer
External_Function LlPrintGetProjectParameterEf "LlPrintGetProjectParameterW" LLDllName Integer hLLJob WString wParameter Integer bEvaluated Pointer pszBuffer Integer nBufSize Pointer pnFlags Returns Integer
External_Function LlExprContainsVariableEf "LlExprContainsVariableW" LLDllName Integer hLLJob Pointer hExpr WString wVariable Returns Integer
External_Function LlLocSystemTimeFromLocaleStringEf "LlLocSystemTimeFromLocaleStringW" LLDllName Integer nLCID Pointer pszDateTime Pointer pST Integer bAddCentury Returns Integer
External_Function LlLocSystemTimeToLocaleStringEf "LlLocSystemTimeToLocaleStringW" LLDllName Integer nLCID Pointer pST Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlLocConvertCountryToEf "LlLocConvertCountryToW" LLDllName Integer hJob Pointer pszCountryID Integer nIndex Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlProfileStartEf "LlProfileStartW" LLDllName Handle hThread WString wDescr WString wFilename Integer nTicksMS Returns Integer
External_Function LlDbAddTableEf "LlDbAddTableW" LLDllName Integer hJob WString wTableID WString wDisplayName Returns Integer
External_Function LlDbAddTableRelationEf "LlDbAddTableRelationW" LLDllName Integer hJob WString wTableID WString wParentTableID WString wRelationID WString wRelationDisplayName Returns Integer
External_Function LlDbAddTableSortOrderEf "LlDbAddTableSortOrderW" LLDllName Integer hJob WString wTableID WString wSortOrderID WString wSortOrderDisplayName Returns Integer
External_Function LlPrintDbGetCurrentTableEf "LlPrintDbGetCurrentTableW" LLDllName Integer hJob Pointer pszTableID Integer nTableIDLength Integer bCompletePath Returns Integer
External_Function LlPrintDbGetCurrentTableRelationEf "LlPrintDbGetCurrentTableRelationW" LLDllName Integer hJob Pointer pszRelationID Integer nRelationIDLength Returns Integer
External_Function LlPrintDbGetCurrentTableSortOrderEf "LlPrintDbGetCurrentTableSortOrderW" LLDllName Integer hJob Pointer pszSortOrderID Integer nSortOrderIDLength Returns Integer
External_Function LlDbSetMasterTableEf "LlDbSetMasterTableW" LLDllName Integer hJob WString wTableID Returns Integer
External_Function LlDbGetMasterTableEf "LlDbGetMasterTableW" LLDllName Integer hJob Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlXSetExportParameterEf "LlXSetExportParameterW" LLDllName Integer hLLJob WString wExtensionName WString wKey WString wValue Returns Integer
External_Function LlXGetExportParameterEf "LlXGetExportParameterW" LLDllName Integer hLLJob WString wExtensionName WString wKey Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlXlatNameEf "LlXlatNameW" LLDllName Integer hLLJob WString wName Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlGetUsedIdentifiersEf "LlGetUsedIdentifiersW" LLDllName Integer hLLJob WString wProjectName Pointer lpszBuffer Integer nBuffSize Returns Integer
External_Function LlDomGetPropertyEf "LlDomGetPropertyW" LLDllName Handle hDOMObj WString wName Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlDomSetPropertyEf "LlDomSetPropertyW" LLDllName Handle hDOMObj WString wName WString wValue Returns Integer
External_Function LlDomGetObjectEf "LlDomGetObjectW" LLDllName Handle hDOMObj WString wName Pointer phDOMSubObj Returns Integer
External_Function LlDomCreateSubobjectEf "LlDomCreateSubobjectW" LLDllName Handle hDOMObj Integer nPosition WString wType Pointer phDOMSubObj Returns Integer
External_Function LlProjectOpenEf "LlProjectOpenW" LLDllName Integer hLlJob Integer nObjType WString wObjName Integer nOpenMode Returns Integer
External_Function LlProjectSaveEf "LlProjectSaveW" LLDllName Integer hLlJob WString wObjName Returns Integer
External_Function LlGetErrortextEf "LlGetErrortextW" LLDllName Integer nError Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlDesignerFileOpenEf "LlDesignerFileOpenW" LLDllName Integer hLlJob WString wFilename Integer nFlags Returns Integer
External_Function LlDesignerAddActionEf "LlDesignerAddActionW" LLDllName Integer hLlJob Integer nID Integer nFlags WString wMenuText WString wMenuHierarchy WString wTooltipText Integer nIcon Pointer pvReserved Returns Integer
External_Function LlDesignerGetOptionString "LlDesignerGetOptionStringW" LLDllName Integer hLlJob Integer nIndex Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlDesignerSetOptionStringEf "LlDesignerSetOptionStringW" LLDllName Integer hLlJob Integer nIndex WString wBuffer Returns Integer
External_Function LlGetProjectParameterEf "LlGetProjectParameterW" LLDllName Integer hLlJob WString wProjectName WString wParameter Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlConvertBLOBToStringEf "LlConvertBLOBToStringW" LLDllName Pointer pBytes Integer nBytes Pointer pszBuffer Integer nBufSize Integer bWithCompression Returns Integer
External_Function LlConvertStringToBLOBEf "LlConvertStringToBLOBW" LLDllName WString wText Pointer pBytes Integer nBytes Returns Integer
External_Function LlConvertStreamToStringEf "LlConvertStreamToStringW" LLDllName Pointer pStream Pointer pszBuffer Integer nBufSize Integer bWithCompression Returns Integer
External_Function LlConvertStringToStreamEf "LlConvertStringToStreamW" LLDllName WString wText Pointer pStream Returns Integer
External_Function LlDbAddTableRelationExEf "LlDbAddTableRelationExW" LLDllName Integer hJob WString wTableID WString wParentTableID WString wRelationID WString wRelationDisplayName WString wKeyField WString wParentKeyField Returns Integer
External_Function LlDbAddTableSortOrderExEf "LlDbAddTableSortOrderExW" LLDllName Integer hJob WString wTableID WString wSortOrderID WString wSortOrderDisplayName WString wField Returns Integer
External_Function LlGetUsedIdentifiersExEf "LlGetUsedIdentifiersExW" LLDllName Integer hLlJob WString wProjectName Integer nIdentifierTypes Pointer pszBuffer	Integer nBufSize Returns Integer
External_Function LlLocAddDictionaryEntryEf "LlLocAddDictionaryEntryW" LLDllName Integer hLlJob Integer nLcId WString wKey WString wValue Integer nType Returns Integer
External_Function LlGetTempFileNameEf "LlGetTempFileNameW" LLDllName WString wPrefix WString wExt Pointer pszBuffer Integer nBufSize Integer nOptions Returns Integer

External_Function LLPostMessageEf "PostMessageW" User32.dll Integer hwnd Integer uMsg Integer wParam Integer lParam Returns Integer
External_Function LLGetLocaleInfoEf "GetLocaleInfoW" kernel32.dll Integer lLocal Integer lcType Pointer lpcData Integer cchData Returns Integer
#ELSE 
// OEM/Ansi Defines for DataFlex <20.0
external_function LlDefineLayoutEf "LlDefineLayoutA" LLDllName Integer hLLJob Handle hWnd Pointer pszTitle Integer nObjType Pointer pszObjName Returns Integer
External_Function LlSetNotificationCallbackEf "LlSetNotificationCallback" LLDllName Integer hLLJob Pointer lpfnNotify Returns Pointer
external_function LlDefineField "LlDefineFieldA" LLDllName Integer hLLJob Pointer pszVarName Pointer lpbufContents Returns Integer
external_function LlDefineFieldEf "LlDefineFieldA" LLDllName Integer hLLJob Pointer pszVarName Pointer lpbufContents Returns Integer
external_function LlDefineFieldExtEf "LlDefineFieldExtA" LLDllName Integer hLLJob Pointer pszVarName Pointer lpbufContents Integer lPara Pointer lpPtr Returns Integer
external_function LlDefineFieldExtHandleEf "LlDefineFieldExtHandleA" LLDllName Integer hLLJob Pointer pszVarName Handle hContents Integer lPara Pointer lpPtr Returns Integer
external_function LlDefineVariableEf "LlDefineVariableA" LLDllName Integer hLLJob Pointer pszVarName Pointer lpbufContents Returns Integer
external_function LlDefineVariableExtEf "LlDefineVariableExtA" LLDllName Integer hLLJob Pointer pszVarName Pointer lpbufContents Integer lPara Pointer lpPtr Returns Integer
external_function LlDefineVariableExtHandleEf "LlDefineVariableExtHandleA" LLDllName Integer hLLJob Pointer pszVarName Handle hContents Integer lPara Pointer lpPtr Returns Integer
external_function LlDefineVariableNameEf "LlDefineVariableNameA" LLDllName Integer hLLJob Pointer pszVarName Returns Integer
External_Function LlDefineSumVariableEf "LlDefineSumVariableA" LLDllName Integer hLLJob Pointer pszVarName Pointer lpbufContents Returns Integer
External_Function LlDlgEditLineEf "LlDlgEditLineA" LLDllName Integer hLLJob Handle hWnd Pointer lpBuf Integer nBufSize Returns Integer
External_Function LlDlgEditLineExEf "LlDlgEditLineExA" LLDllName Integer hLLJob Handle hWnd Pointer pszBuffer Integer nBufSize Integer nParaTypes Pointer pszTitle Integer bTable Pointer pvReserved Returns Integer
External_Function LlPreviewSetTempPathEf "LlPreviewSetTempPathA" LLDllName Integer hLLJob Pointer pszPath Returns Integer
external_function LlPreviewDeleteFilesEf "LlPreviewDeleteFilesA" LLDllName Integer hLLJob Pointer pszObjName Pointer pszPath Returns Integer
external_function LlPreviewDisplayEf "LlPreviewDisplayA" LLDllName Integer hLLJob Pointer pszObjName Pointer pszPath Handle hWnd Returns Integer
external_function LlPreviewDisplayExEf "LlPreviewDisplayExA" LLDllName Integer hLLJob Pointer pszObjName Pointer pszPath Handle hWnd Integer nOptions Pointer pOptions Returns Integer
external_function LlPrintGetRemainingItemsPerTableEf "LlPrintGetRemainingItemsPerTableA" LLDllName Integer hLLJob Pointer pszField Returns Integer
external_function LlPrintGetRemItemsPerTableEf "LlPrintGetRemItemsPerTableA" LLDllName Integer hLLJob Pointer pszField Returns Integer
external_function LlPrintOptionsDialogEf "LlPrintOptionsDialogA" LLDllName Integer hLLJob Handle hWnd Pointer pszText Returns Integer
external_function LlPrintGetPrinterInfoEf "LlPrintGetPrinterInfoA" LLDllName Integer hLLJob Pointer pszPrn Integer nPrnLen Pointer pszPort Integer nPortLen Returns Integer
external_function LlPrintWithBoxStartEf "LlPrintWithBoxStartA" LLDllName Integer hLLJob Integer nObjType Pointer pszObjName Integer nPrintOptions Integer nBoxType Handle hWnd Pointer pszTitle Returns Integer
external_function LlPrintSetBoxTextEf "LlPrintSetBoxTextA" LLDllName Integer hLLJob Pointer szText Integer nPercentage Returns Integer
external_function LlPrintStartEf "LlPrintStartA" LLDllName Integer hLLJob Integer nObjType Pointer pszObjName Integer nPrintOptions Integer iDummy Returns Integer
external_function LlPrinterSetupEf "LlPrinterSetupA" LLDllName Integer hLLJob Handle hWnd Integer nObjType Pointer pszObjName Returns Integer
external_function LlSelectFileDlgTitleExEf "LlSelectFileDlgTitleExA" LLDllName Integer hLLJob Handle hWnd Pointer pszTitle Integer nObjType Pointer pszObjName Integer nBufSize Pointer pReserved Returns Integer
External_Function LlExprParseEf "LlExprParseA" LLDllName Integer hLLJob Pointer lpExprText Integer bIncludeFields Returns Pointer
external_function LlExprErrorEf "LlExprErrorA" LLDllName Integer hLLJob Pointer pszBuf Integer nBufSize Returns Integer
external_function LlExprEvaluateEf "LlExprEvaluateA" LLDllName Integer hLLJob Pointer lpExpr Pointer pszBuf Integer nBufSize Returns Integer
external_function LlExprGetUsedVarsEf "LlExprGetUsedVarsA" LLDllName Integer hLLJob Pointer lpExpr Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlSetOptionStringEf "LlSetOptionStringA" LLDllName Integer hLLJob Integer nIndex Pointer pszBuffer Returns Integer
external_function LlGetOptionStringEf "LlGetOptionStringA" LLDllName Integer hLLJob Integer nIndex Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlPrintSetOptionStringEf "LlPrintSetOptionStringA" LLDllName Integer hLLJob Integer nIndex Pointer pszBuffer Returns Integer
external_function LlPrintGetOptionStringEf "LlPrintGetOptionStringA" LLDllName Integer hLLJob Integer nIndex Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlDesignerProhibitFunctionEf "LlDesignerProhibitFunctionA" LLDllName Integer hLLJob Pointer pszFunction Returns Integer
external_function LlPrintEnableObjectEf "LlPrintEnableObjectA" LLDllName Integer hLLJob Pointer pszObjectName Integer bEnable Returns Integer
external_function LlSetFileExtensionsEf "LlSetFileExtensionsA" LLDllName Integer hLLJob Integer nObjType Pointer pszObjectExt Pointer pszPrinterExt Pointer pszSketchExt Returns Integer
external_function LlPrintGetTextCharsPrintedEf "LlPrintGetTextCharsPrintedA" LLDllName Integer hLLJob Pointer pszObjectName Returns Integer
external_function LlPrintGetFieldCharsPrintedEf "LlPrintGetFieldCharsPrintedA" LLDllName Integer hLLJob Pointer pszObjectName Pointer pszField Returns Integer
external_function LlPrintIsVariableUsedEf "LlPrintIsVariableUsedA" LLDllName Integer hLLJob Pointer pszVarName Returns Integer
external_function LlPrintIsFieldUsedEf "LlPrintIsFieldUsedA" LLDllName Integer hLLJob Pointer pszFieldName Returns Integer
external_function LlPrintOptionsDialogTitleEf "LlPrintOptionsDialogTitleA" LLDllName Integer hLLJob Handle hWnd Pointer pszTitle Pointer pszText Returns Integer
external_function LlSetPrinterToDefaultEf "LlSetPrinterToDefaultA" LLDllName Integer hLLJob Integer nObjType Pointer pszObjName Returns Integer
external_function LlDefineSortOrderEf "LlDefineSortOrderA" LLDllName Integer hLLJob Pointer pszIdentifier Pointer pszText Returns Integer
external_function LlPrintGetSortOrderEf "LlPrintGetSortOrderA" LLDllName Integer hLLJob Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlDefineGroupingEf "LlDefineGroupingA" LLDllName Integer hLLJob Pointer pszSortorder Pointer pszIdentifier Pointer pszText Returns Integer
external_function LlPrintGetGroupingEf "LlPrintGetGroupingA" LLDllName Integer hLLJob Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlAddCtlSupportEf "LlAddCtlSupportA" LLDllName Handle hWnd Integer nFlags Pointer pszInifile Returns Integer
external_function LlPrintGetFilterExpressionEf "LlPrintGetFilterExpressionA" LLDllName Integer hLLJob Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlGetFieldContentsEf "LlGetFieldContentsA" LLDllName Integer hLLJob Pointer pszName Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlGetVariableContentsEf "LlGetVariableContentsA" LLDllName Integer hLLJob Pointer pszName Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlGetSumVariableContentsEf "LlGetSumVariableContentsA" LLDllName Integer hLLJob Pointer pszName Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlGetUserVariableContentsEf "LlGetUserVariableContentsA" LLDllName Integer hLLJob Pointer pszName Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlGetVariableTypeEf "LlGetVariableTypeA" LLDllName Integer hLLJob Pointer pszName Returns Integer
external_function LlGetFieldTypeEf "LlGetFieldTypeA" LLDllName Integer hLLJob Pointer pszName Returns Integer
external_function LlPrintGetColumnInfoEf "LlPrintGetColumnInfoA" LLDllName Integer hLLJob Pointer pszObjectName Integer nCol Pointer pCol Returns Integer
external_function LlSetPrinterDefaultsDirEf "LlSetPrinterDefaultsDirA" LLDllName Integer hLLJob Pointer pszDir Returns Integer
external_function LlCreateSketchEf "LlCreateSketchA" LLDllName Integer hLLJob Integer nObjType Pointer lpszObjName Returns Integer
external_function LlPrintCopyPrinterConfigurationEf "LlPrintCopyPrinterConfigurationA" LLDllName Integer hLLJob Pointer lpszFilename Integer nFunction Returns Integer
external_function LlSetPrinterInPrinterFileEf "LlSetPrinterInPrinterFileA" LLDllName Integer hLLJob Integer nObjType Pointer pszObjName Integer nPrinter Pointer pszPrinter Pointer pDevMode Returns Integer
External_Function LlRTFSetTextEf "LlRTFSetTextA" LLDllName Integer hLLJob Handle hRTF Pointer pszText Returns Integer
External_Function LlRTFGetTextEf "LlRTFGetTextA" LLDllName Integer hLLJob Handle hRTF Integer nFlags Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlDebugOutputEf "LlDebugOutputA" LLDllName Integer nIndent Pointer pszText Returns Integer
external_function LlEnumGetEntryEf "LlEnumGetEntryA" LLDllName Integer hLLJob Integer nPos Pointer pszNameBuf Integer nNameBufSize Pointer pszContBuf Integer nContBufSize Pointer pHandle Pointer pType Returns Integer
external_function LlXSetParameterEf "LlXSetParameterA" LLDllName Integer hLLJob Integer nExtensionType Pointer pszExtensionName Pointer pszKey Pointer pszValue Returns Integer
external_function LlXGetParameterEf "LlXGetParameterA" LLDllName Integer hLLJob Integer nExtensionType Pointer pszExtensionName Pointer pszKey Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlDefineChartFieldExtEf "LlDefineChartFieldExtA" LLDllName Integer hLLJob Pointer pszVarName Pointer pszContents Integer lPara Pointer lpPtr Returns Integer
external_function LlPrintIsChartFieldUsedEf "LlPrintIsChartFieldUsedA" LLDllName Integer hLLJob Pointer pszFieldName Returns Integer
external_function LlGetChartFieldContentsEf "LlGetChartFieldContentsA" LLDllName Integer hLLJob Pointer pszName Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlGetPrinterFromPrinterFileEf "LlGetPrinterFromPrinterFileA" LLDllName Integer hJob Integer nObjType Pointer pszObjectName Integer nPrinter Pointer pszPrinter Pointer pnPrinterBufSize Pointer pDevMode Pointer pnDevModeBufSize Returns Integer
external_function LlPrintGetRemainingSpacePerTableEf "LlPrintGetRemainingSpacePerTableA" LLDllName Integer hLLJob Pointer pszField Integer nDimension Returns Integer
external_function LlSetDefaultProjectParameterEf "LlSetDefaultProjectParameterA" LLDllName Integer hLLJob Pointer pszParameter Pointer pszValue Integer nFlags Returns Integer
external_function LlGetDefaultProjectParameterEf "LlGetDefaultProjectParameterA" LLDllName Integer hLLJob Pointer pszParameter Pointer pszBuffer Integer nBufSize Pointer pnFlags Returns Integer
external_function LlPrintSetProjectParameterEf "LlPrintSetProjectParameterA" LLDllName Integer hLLJob Pointer pszParameter Pointer pszValue Integer nFlags Returns Integer
external_function LlPrintGetProjectParameterEf "LlPrintGetProjectParameterA" LLDllName Integer hLLJob Pointer pszParameter Integer bEvaluated Pointer pszBuffer Integer nBufSize Pointer pnFlags Returns Integer
external_function LlExprContainsVariableEf "LlExprContainsVariableA" LLDllName Integer hLLJob Pointer hExpr Pointer pszVariable Returns Integer
external_function LlLocSystemTimeFromLocaleStringEf "LlLocSystemTimeFromLocaleStringA" LLDllName Integer nLCID Pointer pszDateTime Pointer pST Integer bAddCentury Returns Integer
external_function LlLocSystemTimeToLocaleStringEf "LlLocSystemTimeToLocaleStringA" LLDllName Integer nLCID Pointer pST Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlLocConvertCountryToEf "LlLocConvertCountryToA" LLDllName Integer hJob Pointer pszCountryID Integer nIndex Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlProfileStartEf "LlProfileStartA" LLDllName Handle hThread Pointer pszDescr Pointer pszFilename Integer nTicksMS Returns Integer
external_function LlDbAddTableEf "LlDbAddTableA" LLDllName Integer hJob Pointer pszTableID Pointer pszDisplayName Returns Integer
external_function LlDbAddTableRelationEf "LlDbAddTableRelationA" LLDllName Integer hJob Pointer pszTableID Pointer pszParentTableID Pointer pszRelationID Pointer pszRelationDisplayName Returns Integer
External_Function LlDbAddTableSortOrderEf "LlDbAddTableSortOrderA" LLDllName Integer hJob Pointer pszTableID Pointer pszSortOrderID Pointer pszSortOrderDisplayName Returns Integer
external_function LlPrintDbGetCurrentTableEf "LlPrintDbGetCurrentTableA" LLDllName Integer hJob Pointer pszTableID Integer nTableIDLength Integer bCompletePath Returns Integer
external_function LlPrintDbGetCurrentTableRelationEf "LlPrintDbGetCurrentTableRelationA" LLDllName Integer hJob Pointer pszRelationID Integer nRelationIDLength Returns Integer
external_function LlPrintDbGetCurrentTableSortOrderEf "LlPrintDbGetCurrentTableSortOrderA" LLDllName Integer hJob Pointer pszSortOrderID Integer nSortOrderIDLength Returns Integer
external_function LlDbSetMasterTableEf "LlDbSetMasterTableA" LLDllName Integer hJob Pointer pszTableID Returns Integer
external_function LlDbGetMasterTableEf "LlDbGetMasterTableA" LLDllName Integer hJob Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlXSetExportParameterEf "LlXSetExportParameterA" LLDllName Integer hLLJob Pointer pszExtensionName Pointer pszKey Pointer pszValue Returns Integer
external_function LlXGetExportParameterEf "LlXGetExportParameterA" LLDllName Integer hLLJob Pointer pszExtensionName Pointer pszKey Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlXlatNameEf "LlXlatNameA" LLDllName Integer hLLJob Pointer pszName Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlGetUsedIdentifiersEf "LlGetUsedIdentifiersA" LLDllName Integer hLLJob Pointer pszProjectName Pointer lpszBuffer Integer nBuffSize Returns Integer
external_function LlDomGetPropertyEf "LlDomGetPropertyA" LLDllName Integer hDOMObj Pointer pszName Pointer pszBuffer Integer nBufSize Returns Integer
external_function LlDomSetPropertyEf "LlDomSetPropertyA" LLDllName Integer hDOMObj Pointer pszName Pointer pszValue Returns Integer
external_function LlDomGetObjectEf "LlDomGetObjectA" LLDllName Integer hDOMObj Pointer pszName Pointer phDOMSubObj Returns Integer
external_function LlDomCreateSubobjectEf "LlDomCreateSubobjectA" LLDllName Integer hDOMObj Integer nPosition Pointer pszType Pointer phDOMSubObj Returns Integer
external_function LlProjectOpenEf "LlProjectOpenA" LLDllName Integer hLlJob Integer nObjType Pointer pszObjName Integer nOpenMode Returns Integer
external_function LlProjectSaveEf "LlProjectSaveA" LLDllName Integer hLlJob Pointer pszObjName Returns Integer
External_Function LlGetErrortextEf "LlGetErrortextA" LLDllName Integer nError Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlDesignerFileOpenEf "LlDesignerFileOpenA" LLDllName Integer hLlJob Pointer pszFilename Integer nFlags Returns Integer
External_Function LlDesignerAddActionEf "LlDesignerAddActionA" LLDllName Integer hLlJob Integer nID Integer nFlags Pointer pszMenuText Pointer pszMenuHierarchy Pointer pszTooltipText Integer nIcon Pointer pvReserved Returns Integer
External_Function LlDesignerGetOptionString "LlDesignerGetOptionStringA" LLDllName Integer hLlJob Integer nIndex Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlDesignerSetOptionStringEf "LlDesignerSetOptionStringA" LLDllName Integer hLlJob Integer nIndex Pointer pszBuffer Returns Integer
External_Function LlGetProjectParameterEf "LlGetProjectParameterA" LLDllName Integer hLlJob Pointer pszProjectName Pointer pszParameter Pointer pszBuffer Integer nBufSize Returns Integer
External_Function LlConvertBLOBToStringEf "LlConvertBLOBToStringA" LLDllName Pointer pBytes Integer nBytes Pointer pszBuffer Integer nBufSize Integer bWithCompression Returns Integer
External_Function LlConvertStringToBLOBEf "LlConvertStringToBLOBA" LLDllName Pointer pszText Pointer pBytes Integer nBytes Returns Integer
External_Function LlConvertStreamToStringEf "LlConvertStreamToStringA" LLDllName Pointer pStream Pointer pszBuffer Integer nBufSize Integer bWithCompression Returns Integer
External_Function LlConvertStringToStreamEf "LlConvertStringToStreamA" LLDllName Pointer pszText Pointer pStream Returns Integer
External_Function LlDbAddTableRelationExEf "LlDbAddTableRelationExA" LLDllName Integer hJob Pointer pszTableID Pointer pszParentTableID Pointer pszRelationID Pointer pszRelationDisplayName Pointer pszKeyField Pointer pszParentKeyField Returns Integer
External_Function LlDbAddTableSortOrderExEf "LlDbAddTableSortOrderExA" LLDllName Integer hJob Pointer pszTableID Pointer pszSortOrderID Pointer pszSortOrderDisplayName Pointer pszField Returns Integer
External_Function LlGetUsedIdentifiersExEf "LlGetUsedIdentifiersExA" LLDllName Integer hLlJob Pointer pszProjectName Integer nIdentifierTypes Pointer pszBuffer	Integer nBufSize Returns Integer
External_Function LlLocAddDictionaryEntryEf "LlLocAddDictionaryEntryA" LLDllName Integer hLlJob Integer nLcId Pointer pszKey Pointer pszValue Integer nType Returns Integer
External_Function LlGetTempFileNameEf "LlGetTempFileNameA" LLDllName Pointer pszPrefix Pointer pszExt Pointer pszBuffer Integer nBufSize Integer nOptions Returns Integer

External_Function LLPostMessageEf "PostMessageA" User32.dll Integer hwnd Integer uMsg Integer wParam Integer lParam Returns Integer
External_Function LLGetLocaleInfoEf "GetLocaleInfoA" kernel32.dll Integer lLocal Integer lcType Pointer lpcData Integer cchData Returns Integer
// End of OEM/Ansi Defines for DataFlex <20.0
#ENDIF
external_function LlDefineFieldStartEf "LlDefineFieldStart" LLDllName Integer hLLJob Returns Integer
external_function LlDefineVariableStartEf "LlDefineVariableStart" LLDllName Integer hLLJob Returns Integer
external_function LlPrintEf "LlPrint" LLDllName Integer hLLJob Returns Integer
external_function LlPrintAbortEf "LlPrintAbort" LLDllName Integer hLLJob Returns Integer
external_function LlPrintCheckLineFitEf "LlPrintCheckLineFit" LLDllName Integer hLLJob Returns Integer
external_function LlPrintEndEf "LlPrintEnd" LLDllName Integer hLLJob Integer nPages Returns Integer
external_function LlPrintFieldsEf "LlPrintFields" LLDllName Integer hLLJob Returns Integer
external_function LlPrintFieldsEndEf "LlPrintFieldsEnd" LLDllName Integer hLLJob Returns Integer
external_function LlPrintGetCurrentPageEf "LlPrintGetCurrentPage" LLDllName Integer hLLJob Returns Integer
external_function LlPrintGetItemsPerPageEf "LlPrintGetItemsPerPage" LLDllName Integer hLLJob Returns Integer
external_function LlPrintGetItemsPerTableEf "LlPrintGetItemsPerTable" LLDllName Integer hLLJob Returns Integer
external_function LlPrintGetOptionEf "LlPrintGetOption" LLDllName Integer hLLJob Integer nIndex Returns Integer
external_function LlPrintSelectOffsetExEf "LlPrintSelectOffsetEx" LLDllName Integer hLLJob Handle hWnd Returns Integer
external_function LlPrintSetOptionEf "LlPrintSetOption" LLDllName Integer hLLJob Integer nIndex Integer nValue Returns Integer
external_function LlPrintUpdateBoxEf "LlPrintUpdateBox" LLDllName Integer hLLJob Returns Integer
external_function LlSetDlgboxModeEf "LlSetDlgboxMode" LLDllName Integer nMode Returns Integer
external_function LlGetDlgboxModeEf "LlGetDlgboxMode" LLDllName Returns Integer
external_function LlExprTypeEf "LlExprType" LLDllName Integer hLLJob Pointer lpExpr Returns Integer
external_function LlExprFreeEf "LlExprFree" LLDllName Integer hLLJob Pointer lpExpr Returns Integer
external_function LlSetOptionEf "LlSetOption" LLDllName Integer hLLJob Integer nMode Integer nValue Returns Integer
external_function LlGetOptionEf "LlGetOption" LLDllName Integer hLLJob Integer nMode Returns Integer
external_function LlDesignerProhibitActionEf "LlDesignerProhibitAction" LLDllName Integer hLLJob Integer nMenuID Returns Integer
external_function LlDefineSortOrderStartEf "LlDefineSortOrderStart" LLDllName Integer hLLJob Returns Integer
external_function LlPrintBeginGroupEf "LlPrintBeginGroup" LLDllName Integer hLLJob Integer lParam Pointer lpParam Returns Integer
external_function LlPrintEndGroupEf "LlPrintEndGroup" LLDllName Integer hLLJob Integer lParam Pointer lpParam Returns Integer
external_function LlPrintGroupLineEf "LlPrintGroupLine" LLDllName Integer hLLJob Integer lParam Pointer lpParam Returns Integer
external_function LlPrintGroupHeaderEf "LlPrintGroupHeader" LLDllName Integer hLLJob Integer lParam Returns Integer
external_function LlPrintWillMatchFilterEf "LlPrintWillMatchFilter" LLDllName Integer hLLJob Returns Integer
external_function LlPrintDidMatchFilterEf "LlPrintDidMatchFilter" LLDllName Integer hLLJob Returns Integer
external_function LlViewerProhibitActionEf "LlViewerProhibitAction" LLDllName Integer hLLJob Integer nMenuID Returns Integer
external_function LlRTFCreateObjectEf "LlRTFCreateObject" LLDllName Integer hLLJob Returns Integer
External_Function LlRTFDeleteObjectEf "LlRTFDeleteObject" LLDllName Integer hLLJob Handle hRTF Returns Integer
external_function LlRTFGetTextLengthEf "LlRTFGetTextLength" LLDllName Integer hLLJob Handle hRTF Integer nFlags Returns Integer
external_function LlRTFEditObjectEf "LlRTFEditObject" LLDllName Integer hLLJob Handle hRTF Handle hWnd Handle hPrnDC Integer nProjectType Integer bModal Returns Integer
External_Function LlRTFCopyToClipboardEf "LlRTFCopyToClipboard" LLDllName Integer hLLJob Handle hRTF Returns Integer
External_Function LlRTFDisplayEf "LlRTFDisplay" LLDllName Integer hLLJob Handle hRTF Handle hDC Pointer pRC Integer bRestart Pointer pnState Returns Integer
External_Function LlRTFEditorProhibitActionEf "LlRTFEditorProhibitAction" LLDllName Integer hLLJob Handle hRTF Integer nControlID Returns Integer
External_Function LlRTFEditorInvokeActionEf "LlRTFEditorInvokeAction" LLDllName Integer hLLJob Handle hRTF Integer nControlID Returns Integer
external_function LlEnumGetFirstVarEf "LlEnumGetFirstVar" LLDllName Integer hLLJob Integer nFlags Returns Integer
External_Function LlEnumGetFirstFieldEf "LlEnumGetFirstField" LLDllName Integer hLLJob Integer nFlags Returns Integer
#IF (USELLVERSION>25)
External_Function LlEnumGetFirstConstantEf "LlEnumGetFirstConstant" LLDllName Integer hLLJob Integer nFlags Returns Integer
#ENDIF
external_function LlEnumGetNextEntryEf "LlEnumGetNextEntry" LLDllName Integer hLLJob Integer nPos Integer nFlags Returns Integer
external_function LlPrintResetObjectStatesEf "LlPrintResetObjectStates" LLDllName Integer hLLJob Returns Integer
external_function LlPrintResetProjectStateEf "LlPrintResetProjectState" LLDllName Integer hJob Returns Integer
external_function LlDefineChartFieldStartEf "LlDefineChartFieldStart" LLDllName Integer hLLJob Returns Integer
external_function LlPrintDeclareChartRowEf "LlPrintDeclareChartRow" LLDllName Integer hLLJob Integer nFlags Returns Integer
external_function LlPrintGetChartObjectCountEf "LlPrintGetChartObjectCount" LLDllName Integer hLLJob Integer nType Returns Integer
external_function LlEnumGetFirstChartFieldEf "LlEnumGetFirstChartField" LLDllName Integer hLLJob Integer nFlags Returns Integer
external_function LlSetNotificationCallbackExtEf "LlSetNotificationCallbackExt" LLDllName Integer hLLJob Integer nEvent Pointer lpfnNotify Returns Pointer
External_Function LlExprTypeVarEf "LlExprTypeVar" LLDllName Integer hLLJob Pointer lpExpr Returns Integer
external_function LlDrawToolbarBackgroundEf "LlDrawToolbarBackground" LLDllName Handle hDC Pointer pRC Integer bHorz Integer nTBMode Returns Integer
external_function LlCreateObjectEf "LlCreateObject" LLDllName Integer pIID Pointer ppI Returns Integer
external_function LlExprIsConstantEf "LlExprIsConstant" LLDllName Integer hLLJob Pointer hExpr Returns Integer
external_function LlProfileEndEf "LlProfileEnd" LLDllName Handle hThread Returns Integer
external_function LlDumpMemoryEf "LlDumpMemory" LLDllName Integer bDumpAll Returns Integer
external_function LlDbDumpStructureEf "LlDbDumpStructure" LLDllName Integer hJob Returns Integer
external_function LlPrintDbGetRootTableCountEf "LlPrintDbGetRootTableCount" LLDllName Integer hJob Returns Integer
external_function LlDomGetProjectEf "LlDomGetProject" LLDllName Integer hLlJob Pointer phDOMObj Returns Integer
external_function LlDomGetSubobjectCountEf "LlDomGetSubobjectCount" LLDllName Integer hDOMObj Pointer pnCount Returns Integer
external_function LlDomGetSubobjectEf "LlDomGetSubobject" LLDllName Integer hDOMObj Integer nPosition Pointer phDOMSubObj Returns Integer
external_function LlDomDeleteSubobjectEf "LlDomDeleteSubobject" LLDllName Integer hDOMObj Integer nPosition Returns Integer
external_function LlProjectCloseEf "LlProjectClose" LLDllName Integer hLlJob Returns Integer
External_Function LlAssociatePreviewControlEf "LlAssociatePreviewControl" LLDllName Integer hLlJob Handle hWndControl Integer nFlags Returns Integer
External_Function LlXOBStatJobOpenEf "LlXOBStatJobOpen" LLDllName Integer hJob Pointer pStatJob Returns Integer 
External_Function LlSetPreviewOptionEf "LlSetPreviewOption" LLDllName Integer hLlJob Integer nOption Integer nValue Returns Integer 
External_Function LlGetPreviewOptionEf "LlGetPreviewOption"	LLDllName Integer hLlJob Integer nOption Pointer pnValue Returns Integer 
External_Function LlDesignerFileSaveEf "LlDesignerFileSave" LLDllName Integer hLlJob Integer nFlags Returns Integer
External_Function LlDesignerInvokeActionEf "LlDesignerInvokeAction" LLDllName Integer hLlJob Integer nMenuID Returns Integer
External_Function LlDesignerRefreshWorkspaceEf "LlDesignerRefreshWorkspace" LLDllName Integer hLlJob Returns Integer 
External_Function LlJobOpenCopyEf "LlJobOpenCopy" LLDllName Integer hJob Returns Integer
External_Function LlAztecEncodeEf "LlAztecEncode" LLDllName Pointer lpin Pointer lpOut Integer nFill Returns Integer
External_Function LlLocAddDesignLCIDEf "LlLocAddDesignLCID" LLDllName Integer hLlJob Integer nLcId Returns Integer

External_Function LlGlobalAllocEf "GlobalAlloc" kernel32.dll Integer Flags DWord Bytes Returns Handle        
External_Function LlGlobalLockEf "GlobalLock" KERNEL32.DLL Handle MemObject Returns Pointer
External_Function LlGlobalUnlockEf "GlobalUnlock" KERNEL32.DLL Handle MemObject Returns Integer
External_Function LlGlobalFreeEf "GlobalFree" kernel32.dll Handle hMemObject Returns Integer
External_Function LLIsWindowEnabledEf "IsWindowEnabled" user32.dll Integer hWnd Returns Integer
External_Function LLGetActiveWindowEf "GetActiveWindow" user32.dll Returns Integer
External_Function LLSetActiveWindowEf "SetActiveWindow" user32.dll Integer hWnd Returns Integer
External_Function LLSetEventEf "SetEvent" kernel32.dll Handle hEvent Returns Integer


// **********************************************************************************************************
// Defines the needed List & Label Storage System Constants
// **********************************************************************************************************

#IF (USELLVERSION=15)
Define LLStgsysDllName for cmls15.dll
#ENDIF
#IF (USELLVERSION=16)
Define LLStgsysDllName for cmls16.dll
#ENDIF
#IF (USELLVERSION=17)
Define LLStgsysDllName for cmls17.dll
#ENDIF
#IF (USELLVERSION=18)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls18.dll
    #ELSE
    Define LLStgsysDllName for cmls18.dll
    #ENDIF
#ENDIF
#IF (USELLVERSION=19)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls19.dll
    #ELSE
    Define LLStgsysDllName for cmls19.dll
    #ENDIF
#ENDIF
#IF (USELLVERSION=20)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls20.dll
    #ELSE
    Define LLStgsysDllName for cmls20.dll
    #ENDIF
#ENDIF
#IF (USELLVERSION=21)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls21.dll
    #ELSE
    Define LLStgsysDllName for cmls21.dll
    #ENDIF
#ENDIF
#IF (USELLVERSION=22)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls22.dll
    #ELSE
    Define LLStgsysDllName for cmls22.dll
    #ENDIF
#ENDIF
#IF (USELLVERSION=23)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls23.dll
    #ELSE
    Define LLStgsysDllName for cmls23.dll
    #ENDIF
#ENDIF
#IF (USELLVERSION=24)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls24.dll
    #ELSE
    Define LLStgsysDllName for cmls24.dll
    #ENDIF
#ENDIF
#IF (USELLVERSION=25)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls25.dll
    #ELSE
    Define LLStgsysDllName for cmls25.dll
    #ENDIF
#ENDIF
#IF (USELLVERSION=26)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls26.dll
    #ELSE
    Define LLStgsysDllName for cmls26.dll
    #ENDIF
#ENDIF
#IF (USELLVERSION=27)
    #IFDEF Is$Win64
    Define LLStgsysDllName for cxls27.dll
    #ELSE
    Define LLStgsysDllName for cmls27.dll
    #ENDIF
#ENDIF
    
Define LL_STG_COMPAT4                                   FOR 0
Define LL_STG_STORAGE                                   for 1
#IF (USELLVERSION>17)
Define LL_STGSYS_VERSION_LL18                           for 2
#ENDIF                 
Define LL_ERR_STG_NOSTORAGE                             FOR -1000             
Define LL_ERR_STG_BADVERSION                            FOR -1001
Define LL_ERR_STG_READ                                  FOR -1002
Define LL_ERR_STG_WRITE                                 FOR -1003
Define LL_ERR_STG_UNKNOWNSYSTEM                         FOR -1004
Define LL_ERR_STG_BADHANDLE                             FOR -1005
Define LL_ERR_STG_ENDOFLIST                             FOR -1006
Define LL_ERR_STG_BADJOB                                FOR -1007
Define LL_ERR_STG_ACCESSDENIED                          FOR -1008
Define LL_ERR_STG_BADSTORAGE                            FOR -1009
Define LL_ERR_STG_CANNOTGETMETAFILE                     FOR -1010
Define LL_ERR_STG_OUTOFMEMORY                           FOR -1011
Define LL_ERR_STG_SEND_FAILED                           FOR -1012
Define LL_ERR_STG_DOWNLOAD_PENDING                      FOR -1013
Define LL_ERR_STG_DOWNLOAD_FAILED                       FOR -1014
Define LL_ERR_STG_WRITE_FAILED                          FOR -1015
Define LL_ERR_STG_UNEXPECTED                            FOR -1016
Define LL_ERR_STG_CANNOTCREATEFILE                      FOR -1017
Define LL_ERR_STG_UNKNOWN_CONVERTER                     FOR -1018
Define LL_ERR_STG_INET_ERROR                            FOR -1019
Define LL_WRN_STG_UNFAXED_PAGES                         FOR -1100
Define LS_OPTION_HAS16BITPAGES                          FOR 200                 // has job 16 bit pages? 
Define LS_OPTION_BOXTYPE                                FOR 201                 // wait meter box type 
Define LS_OPTION_UNITS                                  FOR 203                 // LL_UNITS_INCH_DIV_100 Or LL_UNITS_MM_DIV_10 
Define LS_OPTION_PRINTERCOUNT                           FOR 204                 // Number Of printers (1 Or 2) 
Define LS_OPTION_ISSTORAGE                              FOR 205                 // Returns whether file is STORAGE Or COMPAT4 
Define LS_OPTION_EMFRESOLUTION                          FOR 206                 // EMFRESOLUTION used to print the file 
Define LS_OPTION_JOB                                    FOR 207                 // Returns current job Number 
Define LS_OPTION_TOTALPAGES                             FOR 208                 // differs From GetPageCount() If print range In effect 
Define LS_OPTION_PAGESWITHFAXNUMBER                     FOR 209               
Define LS_OPTION_HASINPUTOBJECTS                        FOR 210               
Define LS_OPTION_HASFORCEDINPUTOBJECTS                  FOR 211               
Define LS_OPTION_INPUTOBJECTSFINISHED                   FOR 212
Define LS_OPTION_HASHYPERLINKS                          for 213               
#IF (USELLVERSION>19)
Define LS_OPTION_USED_PRINTERCOUNT                      for 214                 // count of printers actually used (compares DEVMODEs etc)
#ENDIF
Define LS_OPTION_PAGENUMBER                             FOR 0                   // page Number Of current page 
Define LS_OPTION_COPIES                                 FOR 1                   // Number Of copies (same FOR all pages at the moment) 
Define LS_OPTION_PRN_ORIENTATION                        FOR 2                   // orientation (DMORIENT_LANDSCAPE, DMORIENT_PORTRAIT) 
Define LS_OPTION_PHYSPAGE                               FOR 3                   // is page "physical page" oriented? 
Define LS_OPTION_PRN_PIXELSOFFSET_X                     FOR 4                   // this And the following values are 
Define LS_OPTION_PRN_PIXELSOFFSET_Y                     FOR 5                   // values Of the printer that the preview was 
Define LS_OPTION_PRN_PIXELS_X                           FOR 6                   // created on! 
Define LS_OPTION_PRN_PIXELS_Y                           FOR 7                 
Define LS_OPTION_PRN_PIXELSPHYSICAL_X                   FOR 8                 
Define LS_OPTION_PRN_PIXELSPHYSICAL_Y                   FOR 9                 
Define LS_OPTION_PRN_PIXELSPERINCH_X                    FOR 10                
Define LS_OPTION_PRN_PIXELSPERINCH_Y                    FOR 11                
Define LS_OPTION_PRN_INDEX                              FOR 12                  // printer index Of the page (0/1) 
Define LS_OPTION_PRN_PAPERTYPE                          FOR 13                
Define LS_OPTION_PRN_PAPERSIZE_X                        FOR 14                
Define LS_OPTION_PRN_PAPERSIZE_Y                        FOR 15                
Define LS_OPTION_PRN_FORCE_PAPERSIZE                    for 16
Define LS_OPTION_STARTNEWSHEET                          for 17
Define LS_OPTION_ISSUEINDEX                             for 18
#IF (USELLVERSION>17)
Define LS_OPTION_STARTNEWJOB                            for 19
#ENDIF
#IF (USELLVERSION>25)
Define LS_OPTION_PAGETYPE                               for 20                  // 0=normal, 1=GTC
Define LS_OPTION_CONBINATIONPRINT_INDEX                 for 21                  // r/o
Define LS_OPTION_CONBINATIONPRINT_COUNT                 for 22                  // r/o
#ENDIF
Define LS_OPTION_PROJECTNAME                            FOR 100                 // name Of the original project (Not page dependent) 
Define LS_OPTION_JOBNAME                                FOR 101                 // name Of the job (WindowTitle Of LlPrintWithBoxStart()) (Not page dependent) 
Define LS_OPTION_PRTNAME                                FOR 102                 // printer name ("HP Laserjet 4L") 
Define LS_OPTION_PRTDEVICE                              FOR 103                 // printer device ("PSCRIPT") 
Define LS_OPTION_PRTPORT                                FOR 104                 // printer port ("LPT1:" Or "\\server\printer") 
Define LS_OPTION_USER                                   FOR 105                 // user String (Not page dependent) 
Define LS_OPTION_CREATION                               FOR 106                 // creation Date (Not page dependent) 
Define LS_OPTION_CREATIONAPP                            FOR 107                 // creation application (Not page dependent) 
Define LS_OPTION_CREATIONDLL                            FOR 108                 // creation DLL (Not page dependent) 
Define LS_OPTION_CREATIONUSER                           FOR 109                 // creation user And computer name (Not page dependent) 
Define LS_OPTION_FAXPARA_QUEUE                          FOR 110                 // NYI 
Define LS_OPTION_FAXPARA_RECIPNAME                      FOR 111                 // NYI 
Define LS_OPTION_FAXPARA_RECIPNUMBER                    FOR 112                 // NYI 
Define LS_OPTION_FAXPARA_SENDERNAME                     FOR 113                 // NYI 
Define LS_OPTION_FAXPARA_SENDERCOMPANY                  FOR 114                 // NYI 
Define LS_OPTION_FAXPARA_SENDERDEPT                     FOR 115                 // NYI 
Define LS_OPTION_FAXPARA_SENDERBILLINGCODE              FOR 116                 // NYI 
Define LS_OPTION_FAX_AVAILABLEQUEUES                    FOR 118                 // NYI, nPageIndex=1 
Define LS_OPTION_PRINTERALIASLIST                       for 119                 // alternative printer list (taken From project) 
#IF (USELLVERSION>19)
Define LS_OPTION_PRTDEVMODE                             for 120                 // r/o, DEVMODEW structure, to be used with the LlConvertXxxx API */
Define LS_OPTION_USED_PRTDEVICE                         for 121                 // r/o, printer name that would actually be used */
Define LS_OPTION_USED_PRTDEVMODE                        for 122                 // r/o, DEVMODEW structure, to be used with the LlConvertXxxx API
Define LS_OPTION_REGIONNAME                             for 123                 // r/o 
#ENDIF
#IF (USELLVERSION>25)
Define LS_OPTION_CONBINATIONPRINT_PROJECT               for 126                 // r/o
Define LS_OPTION_CONBINATIONPRINT_DESCRIPTION           for 127                 // r/o
#ENDIF
Define LS_PRINTFLAG_FIT                                 FOR |CI$00000001
Define LS_PRINTFLAG_STACKEDCOPIES                       FOR |CI$00000002        // n times page1, n times page2, ... (Else n times (page 1...x)) 
Define LS_PRINTFLAG_TRYPRINTERCOPIES                    FOR |CI$00000004        // first try printer copies, then simulated ones... 
Define LS_PRINTFLAG_METER                               FOR |CI$00000010        
Define LS_PRINTFLAG_ABORTABLEMETER                      FOR |CI$00000020        
Define LS_PRINTFLAG_METERMASK                           FOR |CI$00000070        // allows 7 styles Of abort boxes... 
Define LS_PRINTFLAG_USEDEFPRINTERIFNULL                 FOR |CI$00000080
Define LS_PRINTFLAG_FAX                                 for |CI$00000100
#IF (USELLVERSION>17)
Define LS_PRINTFLAG_OVERRIDEPROJECTCOPYCOUNT            for |CI$00000200
#ENDIF
Define LS_VIEWERCONTROL_CLEAR                           for (WM_USER+1)
Define LS_VIEWERCONTROL_SET_HANDLE_EX                   for (WM_USER+2)         // wParam = Handle (NULL for RELEASE), lParam = internal Struct Handle;
Define LS_VIEWERCONTROL_SET_HANDLE                      for (WM_USER+3)         // lParam = Handle (NULL FOR RELEASE) 
Define LS_VIEWERCONTROLSETHANDLEFLAG_ADD                for |CI$0100
Define LS_VIEWERCONTROLSETHANDLEFLAG_DELETE_ON_CLOSE    for |CI$0200
Define LS_VIEWERCONTROL_GET_HANDLE                      FOR (WM_USER+4)         // lParam = Handle (NULL FOR none) 
Define LS_VIEWERCONTROL_SET_FILENAME                    FOR (WM_USER+5)         // lParam = LPCTSTR pszFilename (NULL FOR RELEASE), wParam = options 
Define LS_STGFILEOPEN_READONLY                          FOR |CI$00000000        
Define LS_STGFILEOPEN_READWRITE                         for |CI$00000001        
Define LS_STGFILEOPEN_FORCE_NO_READWRITE                for |CI$00000002        // never Open Read-Write, even If formula elements are present!
Define LS_STGFILEOPEN_DELETE_ON_CLOSE                   for |CI$00000004
Define LS_STGFILEOPENFLAG_ADD                           for |CI$00000100
Define LS_VIEWERCONTROL_SET_OPTION                      FOR (WM_USER+6)         
Define LS_OPTION_MESSAGE                                FOR 0                   // communication message 
Define LS_OPTION_PRINTERASSIGNMENT                      FOR 1                   // Set BEFORE setting the storage Handle/filename! 
Define LS_PRNASSIGNMENT_USEDEFAULT                      FOR |CI$00000000        
Define LS_PRNASSIGNMENT_ASKPRINTERIFNEEDED              FOR |CI$00000001        
Define LS_PRNASSIGNMENT_ASKPRINTERALWAYS                FOR |CI$00000002        
Define LS_PRNASSIGNMENT_ALWAYSUSEDEFAULT                FOR |CI$00000003        // default 
Define LS_OPTION_TOOLBAR                                FOR 2                   // TRUE to force viewer control to display a toolbar, FALSE otherwise (def: FALSE) 
Define LS_OPTION_SKETCHBAR                              FOR 3                   // TRUE to force viewer control to display a sketch bar (def: TRUE) 
Define LS_OPTION_SKETCHBARWIDTH                         FOR 4                   // TRUE to force viewer control to display a sketch bar (def: 50) 
Define LS_OPTION_TOOLBARSTYLE                           FOR 5                   // default: LS_OPTION_TOOLBARSTYLE_STANDARD, Set BEFORE LS_OPTION_TOOLBAR to TRUE! 
Define LS_OPTION_TOOLBARSTYLE_STANDARD                  FOR 0                   // OFFICE97 alike style 
Define LS_OPTION_TOOLBARSTYLE_OFFICEXP                  FOR 1                   // DOTNET/OFFICE_XP alike style 
Define LS_OPTION_TOOLBARSTYLE_OFFICE2003                FOR 2                 
Define LS_OPTION_TOOLBARSTYLEMASK                       FOR |CI$0f              
Define LS_OPTION_TOOLBARSTYLEFLAG_GRADIENT              FOR |CI$80              // starting with XP, Use gradient style 
Define LS_OPTION_CODEPAGE                               FOR 7                   // lParam = codepage FOR MBCS aware String operations - Set it If the system default is Not applicable
Define LS_OPTION_SAVEASFILEPATH                         FOR 8                   // w/o, lParam = "SaveAs" default filename (LPCTSTR!) 
Define LS_OPTION_USERDATA                               FOR 9                   // FOR LS_VIEWERCONTROL_SET_NTFYCALLBACK 
Define LS_OPTION_BGCOLOR                                FOR 10                  // background color 
Define LS_OPTION_ASYNC_DOWNLOAD                         FOR 11                  // download is ASYNC (def: TRUE) 
Define LS_OPTION_LANGUAGE                               FOR 12                  // CMBTLANG_xxx Or -1 FOR ThreadLocale 
Define LS_OPTION_IOLECLIENTSITE                         FOR 14                  // internal Use 
Define LS_OPTION_TOOLTIPS                               FOR 15                  // lParam = flag value
Define LS_OPTION_AUTOSAVE                               FOR 16                  // lParam = (BOOL)bAutoSave
Define LS_OPTION_CHANGEDFLAG                            for 17                  // lParam = flag value
Define LS_OPTION_SHOW_UNPRINTABLE_AREA                  for 18                  // lParam = flags, default: False */
Define LS_OPTION_NOUIRESET                              for 19                  // lParam = flags, default: True */
Define LS_OPTION_NAVIGATIONBAR                          for 20                  // True to force viewer control to display a sketch bar (def: True) */
Define LS_OPTION_NAVIGATIONBARWIDTH                     for 21                  // True to force viewer control to display a sketch bar (def: 50) */
Define LS_OPTION_IN_PREVIEWPANE                         for 22                  // True to disable unneeded message boxes */
Define LS_OPTION_IN_LLVIEWER                            for 23                  // internal */
Define LS_OPTION_TABBARSTYLE                            for 24
Define LS_OPTION_TABBARSTYLE_STANDARD                   for 0 
Define LS_OPTION_TABBARSTYLE_OFFICEXP                   for 1 
Define LS_OPTION_TABBARSTYLE_OFFICE2003                 for 2 
Define LS_OPTION_DESIGNERPREVIEW                        for 25
#IF (USELLVERSION>17)
Define LS_OPTION_MOUSEMODE                              for 26
Define LS_OPTION_MOUSEMODE_MOVE                         for 1
Define LS_OPTION_MOUSEMODE_ZOOM                         for 2
#ENDIF
#IF (USELLVERSION>24)
Define LS_OPTION_MOUSEMODE_SELECT                       for 3
#ENDIF
#IF (USELLVERSION>18)
Define LS_OPTION_ALLOW_RBUTTONUSAGE                     for 27                  // default: True 
Define LS_OPTION_TOOLBGCOLOR                            for 28
#ENDIF
#IF (USELLVERSION>23)
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_TYPE      for 29
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_TYPE_AREAFILL_SYSTEM for 0                   // system theming (fixed colors, fixed rounding)
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_TYPE_AREAFILL_WIN7ALIKE for 1                // like Windows 7 theming (fixed colors, fixed rounding)
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_TYPE_AREAFILL for 2
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_TYPE_FRAME for 3
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_HEIGHT_PX for 30                             // default: 5
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_WIDTH_PX  for 31                             // default: 5
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_FILLCOLOR_ARGB for 32
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_FILLCOLORHIGHLIGHTED_ARGB for 33
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_FRAMECOLOR_ARGB for 34
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_FRAMECOLORHIGHLIGHTED_ARGB for 35
Define LS_OPTION_PAGEITEM_SELECTED_ITEM_FRAME_ROUNDED_CORNER_PX for 36                     // default: 5
Define LS_OPTION_PAGEITEM_DROPSHADOW  for 37
Define LS_OPTION_PAGEITEM_DROPSHADOW_NONE for 0
Define LS_OPTION_PAGEITEM_DROPSHADOW_ONLY_NONSELECTED for 1
Define LS_OPTION_PAGEITEM_PAGENUMBER  for 38                                               // default: True (>=LS24)
Define LS_OPTION_SKETCHBAR_BGCOLOR for 39                                                  // default: ::GetSysColor(COLOR_WINDOW)
#ENDIF

Define LS_VIEWERCONTROL_GET_OPTION                      FOR (WM_USER+7)         
Define LS_VIEWERCONTROL_QUERY_ENDSESSION                FOR (WM_USER+8)
Define LS_VIEWERCONTROL_GET_ZOOM                        FOR (WM_USER+9)         
Define LS_VIEWERCONTROL_SET_ZOOM                        FOR (WM_USER+10)        // wParam = factor (lParam = 1 If In percent)
Define LS_VIEWERCONTROL_GET_ZOOMED                      FOR (WM_USER+11)        // TRUE If zoomed 
Define LS_VIEWERCONTROL_POP_ZOOM                        FOR (WM_USER+12)        
Define LS_VIEWERCONTROL_RESET_ZOOM                      FOR (WM_USER+13)        
Define LS_VIEWERCONTROL_SET_ZOOM_TWICE                  FOR (WM_USER+14)        
Define LS_VIEWERCONTROL_SET_PAGE                        FOR (WM_USER+20)        // wParam = page# (0..n-1) 
Define LS_VIEWERCONTROL_GET_PAGE                        FOR (WM_USER+21)        
Define LS_VIEWERCONTROL_GET_PAGECOUNT                   FOR (WM_USER+22)        
Define LS_VIEWERCONTROL_GET_PAGECOUNT_FAXPAGES          FOR (WM_USER+23)        
Define LS_VIEWERCONTROL_GET_JOB                         FOR (WM_USER+24)        
Define LS_VIEWERCONTROL_GET_JOBPAGEINDEX                FOR (WM_USER+25)        
Define LS_VIEWERCONTROL_GET_METAFILE                    FOR (WM_USER+26)        // wParam = page#, FOR IMMEDIATE Use (will be released by LS DLL at some undefined Time!) 
Define LS_VIEWERCONTROL_GET_ENABLED                     FOR (WM_USER+27)        // wParam = ID 
Define LS_VCITEM_SEARCH_FIRST                           FOR 0                 
Define LS_VCITEM_SEARCH_NEXT                            FOR 1                 
Define LS_VCITEM_SEARCH_OPTS                            for 2
#IF (USELLVERSION>21)
Define LS_VCITEM_SEARCHFLAG_CASEINSENSITIVE             for |CI$00008000
Define LS_VCITEM_SEARCHFLAG_UTF16                       for |CI$00004000
Define LS_VCITEM_SEARCHFLAGMASK                         for |CI$fffff000
#ELSE
Define LS_VCITEM_SEARCHFLAG_CASEINSENSITIVE             for |CI$8000            
#ENDIF
Define LS_VCITEM_SAVE_AS_FILE                           FOR 3                 
Define LS_VCITEM_SEND_AS_MAIL                           FOR 4                 
Define LS_VCITEM_SEND_AS_FAX                            FOR 5                 
Define LS_VCITEM_PRINT_ONE                              FOR 6
Define LS_VCITEM_PRINT_ALL                              FOR 7
Define LS_VCITEM_PAGENUMBER                             FOR 8
Define LS_VCITEM_ZOOM                                   FOR 9
Define LS_VCITEM_THEATERMODE                            for 10
Define LS_VCITEM_PREVSTG                                for 11
Define LS_VCITEM_NEXTSTG                                for 12
#IF (USELLVERSION>15)
Define LS_VCITEM_SEARCH_DONE                            for 13
#ENDIF
#IF (USELLVERSION>17)
Define LS_VCITEM_FIRSTPAGE                              for 14
Define LS_VCITEM_NEXTPAGE                               for 15
Define LS_VCITEM_PREVIOUSPAGE                           for 16
Define LS_VCITEM_LASTPAGE                               for 17
Define LS_VCITEM_MOUSEMODE_MOVE                         for 18
Define LS_VCITEM_MOUSEMODE_ZOOM                         for 19
#ENDIF
#IF (USELLVERSION>24)
Define LS_VCITEM_MOUSEMODE_SELECT                       for 20
#ENDIF
Define LS_VIEWERCONTROL_GET_SEARCHSTATE                 FOR (WM_USER+28)        // Returns TRUE If search In progress 
Define LS_VIEWERCONTROL_SEARCH                          for (WM_USER+29)        // wParam = LS_VCITEM_SEARCH_Xxxx enum, OR'ed optionally with LS_VCITEM_SEARCHFLAG_CASEINSENSITIVE, lParam=SearchText (NULL to stop) */ 
#IF (USELLVERSION>20)
Define LS_VIEWERCONTROL_SEARCHDLGACTIVE                 for (WM_USER+30)        // Returns Handle to common search dialog If it is currently being shown, otherwise NULL
#ENDIF
Define LS_VIEWERCONTROL_PRINT_CURRENT                   FOR (WM_USER+31)        // wParam = 0 (default printer), 1 (with printer selection) 
Define LS_VIEWERCONTROL_PRINT_ALL                       FOR (WM_USER+32)        // wParam = 0 (default printer), 1 (with printer selection) 
Define LS_VIEWERCONTROL_PRINT_TO_FAX                    FOR (WM_USER+33)        
Define LS_VIEWERCONTROL_UPDATE_TOOLBAR                  FOR (WM_USER+35)        // If LS_OPTION_TOOLBAR is TRUE 
Define LS_VIEWERCONTROL_GET_TOOLBAR                     FOR (WM_USER+36)        // If LS_OPTION_TOOLBAR is TRUE, Returns window Handle Of toolbar 
Define LS_VIEWERCONTROL_SAVE_TO_FILE                    FOR (WM_USER+37)        
Define LS_VIEWERCONTROL_SEND_AS_MAIL                    FOR (WM_USER+39)
Define LS_VIEWERCONTROL_SET_OPTIONSTR                   FOR (WM_USER+40)        // see docs, wParam = (LPCTSTR)key, lParam = (LPCTSTR)value 
Define LS_VIEWERCONTROL_GET_OPTIONSTR                   FOR (WM_USER+41)        // see docs, wParam = (LPCTSTR)key, lParam = (LPCTSTR)value 
Define LS_VIEWERCONTROL_GET_OPTIONSTRLEN                FOR (WM_USER+42)        // see docs, wParam = (LPCTSTR)key (Returns size In TCHARs) 
Define LS_VIEWERCONTROL_SET_NTFYCALLBACK                FOR (WM_USER+43)        // lParam = LRESULT ( WINAPI fn* )(UINT nMsg, LPARAM lParam, UINT nUserParameter); 
Define LS_VIEWERCONTROL_GET_NTFYCALLBACK                FOR (WM_USER+44)        // LRESULT ( WINAPI fn* )(UINT nMsg, LPARAM lParam, UINT nUserParameter); 
Define LS_VIEWERCONTROL_GET_TOOLBARBUTTONSTATE          FOR (WM_USER+45)        // wParam=nID -> -1=hidden, 1=enabled, 2=disabled (only when toobar present, to sync menu state) 
Define LS_VIEWERCONTROL_SET_FOCUS                       FOR (WM_USER+46)        
Define LS_VCSF_PREVIEW                                  FOR 1
Define LS_VCSF_SKETCHLIST                               FOR 2
Define LS_VIEWERCONTROL_ADDTOOLBARITEM                  FOR (WM_USER+47)            
Define LS_VIEWERCONTROL_INTERNAL_CHECKERRORLIST         FOR (WM_USER+48)        
Define LS_VIEWERCONTROL_SET_THEATERMODE                 FOR (WM_USER+49)        // 0=non-theater, 1=with frame, 2=without frame
Define LS_VIEWERCONTROL_SET_THEATERFLIPDELAY            FOR (WM_USER+50)        // ms FOR each page 
Define LS_VIEWERCONTROL_SET_THEATERFLIPMODE             FOR (WM_USER+51)        // wParam = mode 
Define LS_VCTFM_NONE                                    FOR 0                 
Define LS_VCTFM_LINEAR                                  FOR 1                   // lParam = (LPCTSTR)ProgID 
Define LS_VCTFM_FADE                                    FOR 2                 
Define LS_VCTFM_WHEEL                                   FOR 3                 
Define LS_VIEWERCONTROL_SELECT_THEATERXFORM             FOR (WM_USER+52)        
Define LS_VIEWERCONTROL_NTFY_PRVFSCHANGED               FOR (WM_USER+53)        // wParam = ILLPreviewFileSystemChangeNotifier::enPrvFSChange...
Define LS_VIEWERCONTROL_SET_PROGRESSINFO                FOR (WM_USER+54)        // wParam = nPercentage (-1=finished...), lParam = (LPCTSTR)sText
Define LS_VIEWERCONTROL_GET_FILENAME                    FOR (WM_USER+55)        // lParam = LPTSTR pszFilename, wParam = sizeofTSTR(pszBuffer). Returns size needed If NULL filename
Define LS_VIEWERCONTROL_QUERY_PRVFS_COMPLETE            FOR (WM_USER+56)        // indicates whether the STGSYS file is complete
Define LS_VIEWERCONTROL_ONSIZEMOVE                      FOR (WM_USER+57)        // wParam = 0 (ENTER), 1 (EXIT)
Define LS_VIEWERCONTROL_NTFY_SHOW                       FOR (WM_USER+58)        // internal Use 
Define LS_VIEWERCONTROL_GET_IDEVICEINFO                 for (WM_USER+59)        // internal Use
Define LS_VIEWERCONTROL_REMOVEFAILURETOOLTIPS           for (WM_USER+60)        // internal Use
Define LS_VIEWERCONTROL_SET_LLNTFYSINK                  for (WM_USER+61)        // internal Use
Define LS_VIEWERCONTROL_OPEN_PREVSTG                    for (WM_USER+62)
Define LS_VIEWERCONTROL_OPEN_NEXTSTG                    for (WM_USER+63)
#IF (USELLVERSION>15)
Define LS_VIEWERCONTROL_GET_THEATERSTATE                for (WM_USER+64)        // Returns True If in theater mode
#ENDIF
#IF (USELLVERSION>21)
Define LS_VIEWERCONTROL_SET_PROGRESSINFO_INTERNAL       for (WM_USER+65)
Define LS_VIEWERCONTROL_GET_THIS                        for (WM_USER+67)        // internal 
Define LS_VIEWERCONTROL_SEARCH_LINK                     for (WM_USER+68)        // wParam = LS_VCITEM_GOTO_LINK_ enum, lParam=SearchText in control's charset flavour (ANSI/UNICODE) (NULL or empty to stop)
Define LS_SEARCH_LINK_HYPERLINK                         for 0
Define LS_VIEWERCONTROL_QUERY_DRILLDOWN_ACTIVE          for (WM_USER+69)        // count of active drilldown jobs of visible storage - negative If Error
Define LS_VIEWERCONTROL_CMND_ABORT_DRILLDOWN_JOBS       for (WM_USER+70)
#ENDIF
#IF (USELLVERSION>23)
Define LS_VIEWERCONTROL_STORAGE_CONTAINS_EXPORTFILE     for (WM_USER+71)        // lParam = (LPCTSTR)format, Returns 1 If yes, 0 If no, negative If Error
#ENDIF
#IF (USELLVERSION>24)
Define LS_VIEWERCONTROL_SELECTION_COPY                  for (WM_USER+72)        // lParam == &scLSSelectionOptions (null, or _pvText == null -> to clipboard)
Define LS_VIEWERCONTROL_GET_HAS_SELECTION               for (WM_USER+73)        //
Define LS_VIEWERCONTROL_SELECTION_SELECT                for (WM_USER+74)        // wParam = page index#, -1 for All; lParam = 0 (select only this), 1 (Add to selection)
#ENDIF
Define LS_VIEWERCONTROL_NTFY_PAGELOADED                 for 1                   // lParam = page# 
Define LS_VIEWERCONTROL_NTFY_UPDATETOOLBAR              FOR 2                   // called when control does Not have an own toolbar. lParam = 1 If count Of pages did change
Define LS_VIEWERCONTROL_NTFY_PRINT_START                FOR 3                   // lParam = &scViewerControlPrintData, return 1 to abort print 
Define LS_VIEWERCONTROL_NTFY_PRINT_PAGE                 FOR 4                   // lParam = &scViewerControlPrintData, return 1 to abort Loop 
Define LS_VIEWERCONTROL_NTFY_PRINT_END                  FOR 5                   // lParam = &scViewerControlPrintData 
Define LS_VIEWERCONTROL_NTFY_TOOLBARUPDATE              FOR 6                   // lParam = toolbar Handle, called when control has an own toolbar 
Define LS_VIEWERCONTROL_NTFY_EXITBTNPRESSED             FOR 7                 
Define LS_VIEWERCONTROL_NTFY_BTNPRESSED                 FOR 8                   // lParam = control ID 
Define LS_VIEWERCONTROL_QUEST_BTNSTATE                  FOR 9                   // lParam = control ID, -1 to hide, 1 to show, 2 to disable (0 to Use default) 
Define LS_VIEWERCONTROL_NTFY_ERROR                      FOR 10                  // lParam = &scVCError. Return != 0 to suppress error mbox From control. 
Define LS_VIEWERCONTROL_NTFY_MAIL_SENT                  FOR 11                  // lParam = Stream* Of EML mail contents 
Define LS_VIEWERCONTROL_NTFY_DOWNLOADFINISHED           FOR 12                  // lParam = 0 (failed), 1 (ok) 
Define LS_VIEWERCONTROL_NTFY_KEYBOARDMESSAGE            FOR 13                  // lParam = const MSG*. Return TRUE If message should be taken out Of the input queue
Define LS_VIEWERCONTROL_NTFY_VIEWCHANGED                FOR 14                  // lParam = const scViewChangedInfo
Define LS_VIEWERCONTROL_CMND_SAVEDATA                   FOR 15                  // return: 0 = OK, -1 = failure, 1 = Save In LL file too [event used only If AUTOSAVE is TRUE]
Define LS_VIEWERCONTROL_NTFY_DATACHANGED                FOR 16
Define LS_VIEWERCONTROL_NTFY_PROGRESS                   FOR 17                  // lParam = percentage (-1=finished). return: 1 If internal progress bar shall be suppressed
Define LS_VIEWERCONTROL_QUEST_SUPPORTCONTINUATION       FOR 18                  // return: 1 If continuation button () should be displayed
Define LS_VIEWERCONTROL_CMND_CONTINUE                   for 19                  // continue report! 
Define LS_VIEWERCONTROL_NTFY_VIEWERDRILLDOWN            for 20                  // lParam: 
Define LS_VIEWERCONTROL_QUEST_DRILLDOWNSUPPORT          for 21                  // 1 to allow (default), 0 to deny (If provider cannot Handle multiple threads or so) 
#IF (USELLVERSION>17)
Define LS_VIEWERCONTROL_QUEST_HOST_WANTS_KEY            for 22                  // lParam: MSG-structure (message = WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, WM_SYSKEYUP, WM_CHAR), wParam = key code, lParam = snoop (0), action (1)
Define LS_VIEWERCONTROL_INTERNALSYNC                    for 23                  // reserved, internal
#ENDIF
#IF (USELLVERSION>18)
Define LS_VIEWERCONTROL_NTFY_RP_REALDATAJOB             for 24
Define LS_VIEWERCONTROL_QUEST_RP_REALDATAJOBSUPPORT     for 25                  // 1 to allow (default), 0 to deny (If provider cannot Handle multiple threads or so)
Define LS_VIEWERCONTROL_QUEST_PROJECTFILENAME           for 26                  // reserved, internal
Define LS_VIEWERCONTROL_QUEST_ORGPROJECTFILENAME        for 27                  // reserved, internal 
Define LS_VIEWERCONTROL_NTFY_EXPANDABLEREGIONSJOB       for 28
Define LS_VIEWERCONTROL_QUEST_EXPANDABLEREGIONSJOBSUPPORT for 29                // 1 to allow (default), 0 to deny (If provider cannot Handle multiple threads or so) 
Define LS_VIEWERCONTROL_NTFY_INTERACTIVESORTINGJOB      for 30
Define LS_VIEWERCONTROL_QUEST_INTERACTIVESORTINGJOBSUPPORT for 31               // 1 to allow (default), 0 to deny (If provider cannot Handle multiple threads or so) */
#ENDIF
#IF (USELLVERSION>19)
Define LS_VIEWERCONTROL_QUEST_ANYREALDATAJOBSUPPORT     for 32                  // 1 to allow (default), 0 to deny (If provider cannot Handle multiple threads or so)
Define LS_VIEWERCONTROL_NTFY_HYPERLINK                  for 33                  // 1 to tell viewer it has been processed
#ENDIF
#IF (USELLVERSION>21)
Define LS_VIEWERCONTROL_NTFY_ZOOMCHANGED                for 34                  // triggered whenever the zoom factor was updated
Define LS_VIEWERCONTROL_OPEN_STORAGE_IN_NEW_WINDOW      for 32                  // lParam = &scOpenStorageInNewWindow. Reply with 1 If done. 
#ELSE
Define LS_VIEWERCONTROL_OPEN_STORAGE_IN_NEW_WINDOW      for 22                  // lParam = &scOpenStorageInNewWindow. Reply with 1 If done. 
#ENDIF
#IF (USELLVERSION>24)
Define LS_VIEWERCONTROL_NTFY_ACTIONRESULT               for 35                  // lParam = &scLSNtfyActionResult 
Define LS_VIEWERCONTROL_NTFY_RESETSEARCHSTATE           for 36                  // reserved, internal 
Define LS_VIEWERCONTROL_NTFY_SELECTION_CHANGED          for 37                  
#ENDIF
Define LS_VIEWERCONTROL_NTFY_SETDFFOCUS                 for 9999                
Define LS_MAILCONFIG_GLOBAL                             for |CI$0001            
Define LS_MAILCONFIG_USER                               FOR |CI$0002            
Define LS_MAILCONFIG_PROVIDER                           FOR |CI$0004            
Define LS_DIO_CHECKBOX                                  FOR 0                 
Define LS_DIO_PUSHBUTTON                                for 1    
Define LS_GOTFG_FLAG_REORDER                            for |CI$00000001
Define LSMAILVIEW_HTMLRIGHT_ALLOW_NONE                  for |CI$0000
Define LSMAILVIEW_HTMLRIGHT_ALLOW_NEW_WINDOW            for |CI$0001
Define LSMAILVIEW_HTMLRIGHT_ALLOW_NAVIGATION            for |CI$0002
Define LSMAILVIEW_HTMLRIGHT_ALLOW_JAVA                  for |CI$0004
Define LSMAILVIEW_HTMLRIGHT_ALLOW_SCRIPTING             for |CI$0008
Define LSMAILVIEW_HTMLRIGHT_ALLOW_ACTIVEX               for |CI$0010
Define LSMAILVIEW_HTMLRIGHT_ALLOW_ONLINE                for |CI$0020
Define LSMAILVIEW_HTMLRIGHT_ALLOW_BROWSERCONTEXTMENU    for |CI$0040
Define LSMAILVIEW_HTMLRIGHT_ALLOW_PRINT                 for |CI$0080
#IF (USELLVERSION>15)
Define LS_CONVERT_IS_TO_JPEGFILE                        for 0
Define LS_CONVERT_IS_TO_DIBFILE                         for 1
Define LS_CONVERT_IS_TO_EMRSTRETCHDIBITS                for 2
Define LS_CONVERT_IS_TYPEMASK                           for |CI$0000000f
Define LS_CONVERT_IS_NOPERPIXELALPHA                    for |CI$00000010
#ENDIF
#IF (USELLVERSION>20)
Define LS_CONVERT_IS_TO_PNGFILE                         for 3
Define LS_CONVERT_IS_TO_PNG_OR_JPEG_FILE                for 4
#ENDIF
#IF (USELLVERSION>19)
Define LS_CONVERT_IS_SRCCOPY                            for |CI$00000020
Define LS_CONVERT_IS_NO_JPEGCONVERSION                  for |CI$00000040         // for PDF Conversion (PDF export handles these itself)
#ENDIF
#IF (USELLVERSION>15)
Define LS_STGPRINTEX_OPTION_FORCE_SIMPLEX               for |CI$00000001
Define LS_STGPRINTEX_OPTION_FORCE_DUPLEX_VERT           for |CI$00000002
Define LS_STGPRINTEX_OPTION_FORCE_DUPLEX_HORZ           for |CI$00000003
Define LS_STGPRINTEX_OPTIONMASK_DUPLEX                  for |CI$00000003
Define LS_STGPRINTEX_OPTION_FORCE_PHYSPAGE              for |CI$00000004
Define LS_STGPRINTEX_OPTION_FORCE_LOGPAGE               for |CI$00000008
Define LS_STGPRINTEX_OPTIONMASK_PAGEAREA                for |CI$0000000C
#ENDIF
    
// **********************************************************************************************************
// Defines the DLL-Calls to List & Label Storage System
// **********************************************************************************************************
#IF (!@>199)
External_Function LlStgsysStorageOpenEf "LlStgsysStorageOpenW" LLStgsysDllName WString wFilename WString wTempPath Integer bReadOnly Integer bOneJobTranslation Returns Longptr
External_Function LlStgsysGetFilenameEf "LlStgsysGetFilenameW" LLStgsysDllName Longptr hStg Integer nJob Integer nFile Pointer pszBuffer Integer nBufSize Returns Integer  
External_Function LlStgsysGetPageOptionStringEf "LlStgsysGetPageOptionStringW" LLStgsysDllName Longptr hStg Integer nPageIndex Integer nOption Pointer pszBuffer Integer nBufSize Returns Integer  
External_Function LlStgsysSetPageOptionStringEf "LlStgsysSetPageOptionStringW" LLStgsysDllName Longptr hStg Integer nPageIndex Integer nOption WString wBuffer Returns Integer  
External_Function LlStgsysPrintEf "LlStgsysPrintW" LLStgsysDllName Longptr hStg WString wPrinterName1 WString wPrinterName2 Integer nStartPageIndex Integer nEndPageIndex Integer nCopies Integer nFlags WString wMessage Handle hWndParent Returns Integer
External_Function LlStgsysStoragePrintEf "LlStgsysStoragePrintW" LLStgsysDllName WString wFilename WString wTempPath WString wPrinterName1 WString wPrinterName2 Integer nStartPageIndex Integer nEndPageIndex Integer nCopies Integer nFlags WString wMessage Handle hWndParent Returns Integer
External_Function LlStgsysGetPagePrinterEf "LlStgsysGetPagePrinterW" LLStgsysDllName Longptr hStg Integer nPageIndex Pointer pszDeviceName Integer nDeviceNameSize Pointer phDevMode Returns Integer  
External_Function LlStgsysStorageCloseEf "LlStgsysStorageClose" LLStgsysDllName Longptr hStg Returns Integer  
External_Function LlStgsysGetAPIVersionEf "LlStgsysGetAPIVersion" LLStgsysDllName Longptr hStg Returns Integer  
External_Function LlStgsysGetFileVersionEf "LlStgsysGetFileVersion" LLStgsysDllName Longptr hStg Returns Integer  
External_Function LlStgsysGetJobCountEf "LlStgsysGetJobCount" LLStgsysDllName Longptr hStg Returns Integer  
External_Function LlStgsysSetJobEf "LlStgsysSetJob" LLStgsysDllName Longptr hStg Integer nJob Returns Integer  
External_Function LlStgsysGetJobEf "LlStgsysGetJob" LLStgsysDllName Longptr hStg Returns Integer  
External_Function LlStgsysGetPageCountEf "LlStgsysGetPageCount" LLStgsysDllName Longptr hStg Returns Integer  
External_Function LlStgsysGetJobOptionValueEf "LlStgsysGetJobOptionValue" LLStgsysDllName Longptr hStg Integer nOption Returns Integer  
External_Function LlStgsysGetPageOptionValueEf "LlStgsysGetPageOptionValue" LLStgsysDllName Longptr hStg Integer nPageIndex Integer nOption Returns Integer  
External_Function LlStgsysAppendEf "LlStgsysAppend" LLStgsysDllName Longptr hStg Longptr hStgToAppend Returns Integer  
External_Function LlStgsysDeleteJobEf "LlStgsysDeleteJob" LLStgsysDllName Longptr hStg Integer nPageIndex Returns Integer  
External_Function LlStgsysDeletePageEf "LlStgsysDeletePage" LLStgsysDllName Longptr hStg Integer nPageIndex Returns Integer  
External_Function LlStgsysGetPageMetafileEf "LlStgsysGetPageMetafile" LLStgsysDllName Longptr hStg Integer nPageIndex Returns Handle  
External_Function LlStgsysGetPageMetafile16Ef "LlStgsysGetPageMetafile16" LLStgsysDllName Longptr hStg Integer nPageIndex Returns Handle  
External_Function LlStgsysDestroyMetafileEf "LlStgsysDestroyMetafile" LLStgsysDllName Handle hMF Returns Integer  
External_Function LlStgsysDrawPageEf "LlStgsysDrawPage" LLStgsysDllName Longptr hStg Handle hDC Handle hPrnDC Integer bAskPrinter Pointer pRC Integer nPageIndex Integer bFit Pointer pReserved Returns Integer  
External_Function LlStgsysGetLastErrorEf "LlStgsysGetLastError" LLStgsysDllName Longptr hStg Returns Integer  
External_Function LlStgsysDeleteFilesEf "LlStgsysDeleteFiles" LLStgsysDllName Longptr hStg Returns Integer  
External_Function LlStgsysConvertEf "LlStgsysConvertW" LLStgsysDllName Longptr hStg WString wDstFilename WString wFormat Returns Integer  
External_Function LlStgsysStorageConvertEf "LlStgsysStorageConvertW" LLStgsysDllName WString wStgFilename WString wDstFilename WString wFormat Returns Integer  
External_Function LlStgsysGetLLFilenameEf "LlStgsysGetLLFilenameW" LLStgsysDllName WString wFilename WString wTempPath Pointer pszBuffer Integer nSize Returns Integer  
External_Function LlStgsysStorageCreateEf "LlStgsysStorageCreateW" LLStgsysDllName WString wFilename WString wTempPath Handle hRefDC Pointer prcArea Integer bPhysicalPage Returns Integer  
External_Function LlStgsysAppendEMFEf "LlStgsysAppendEMF" LLStgsysDllName Longptr hStg Handle hEMFToAppend Handle hRefDC Pointer prcArea Integer bPhysicalPage Returns Integer  
External_Function LlStgsysGetJobOptionStringExEf "LlStgsysGetJobOptionStringExW" LLStgsysDllName Longptr hStg WString wKey Pointer pszBuffer Integer nBufSize Returns Integer  
External_Function LlStgsysSetJobOptionStringExEf "LlStgsysSetJobOptionStringExW" LLStgsysDllName Longptr hStg WString wKey WString wBuffer Returns Integer  
External_Function LlStgsysStorageOpenExEf "LlStgsysStorageOpenExW" LLStgsysDllName WString wFilename Pointer pSOI Returns Integer
External_Function LsGetViewerControlClassNameEf "LsGetViewerControlClassNameW" LLStgsysDllName Returns Pointer  
External_Function LsConversionJobOpenEf "LsConversionJobOpenW" LLStgsysDllName Handle hWndParent Integer nLanguage WString wFormat Returns Longptr
External_Function LsConversionPrintEf "LsConversionPrintW" LLStgsysDllName Longptr hCnvJob Pointer pStream Pointer pszBufFilename Integer nBufSize Returns Integer  
External_Function LsConversionSetOptionStringEf "LsConversionSetOptionStringW" LLStgsysDllName Longptr hCnvJob WString wKey WString wData Returns Integer  
External_Function LsConversionJobCloseEf "LsConversionJobClose" LLStgsysDllName Longptr hCnvJob Returns Integer  
External_Function LsConversionConvertEMFToStreamEf "LsConversionConvertEMFToStream" LLStgsysDllName Longptr hCnvJob Handle hEMF Pointer pStream Returns Integer  
External_Function LsConversionConvertStgToStreamEf "LsConversionConvertStgToStream" LLStgsysDllName Longptr hCnvJob Longptr hStg Pointer pStream Returns Integer  
External_Function LsConversionConfigurationDlgEf "LsConversionConfigurationDlg" LLStgsysDllName Longptr hCnvJob Handle hWndParent Returns Integer  
External_Function LsConversionGetOptionStringEf "LsConversionGetOptionStringW" LLStgsysDllName Longptr hCnvJob WString wKey Pointer pszBuffer Integer nBufSize Returns Integer  
External_Function LsConversionConvertEMFToFileEf "LsConversionConvertEMFToFileW" LLStgsysDllName Longptr hCnvJob Handle hEMF WString wFilename Returns Integer  
External_Function LsConversionConvertStgToFileEf "LsConversionConvertStgToFileW" LLStgsysDllName Longptr hCnvJob Longptr hStg WString wFilename Returns Integer  
External_Function LsCreateViewerControlOverParentEf "LsCreateViewerControlOverParent" LLStgsysDllName Longptr hStg Handle hParentControl Returns Integer  
External_Function LsMailConfigurationDialogEf "LsMailConfigurationDialogW" LLStgsysDllName Handle hWndParent WString wSubkey Integer nFlags Integer nLanguage Returns Integer  
External_Function LsMailJobOpenEf "LsMailJobOpen" LLStgsysDllName Integer nLanguage Returns Longptr
External_Function LsMailJobCloseEf "LsMailJobClose" LLStgsysDllName Longptr hJob Returns Integer  
External_Function LsMailSetOptionStringEf "LsMailSetOptionStringW" LLStgsysDllName Longptr hJob WString wKey WString wValue Returns Integer  
External_Function LsMailGetOptionStringEf "LsMailGetOptionStringW" LLStgsysDllName Longptr hJob WString wKey Pointer pszBuffer Integer nBufSize Returns Integer  
External_Function LsMailSendFileEf "LsMailSendFile" LLStgsysDllName Longptr hJob Handle hWndParent Returns Integer  
External_Function LsMailViewEf "LsMailViewW" LLStgsysDllName Handle hWndParent WString wMailFile Integer nRights Integer nLanguage Returns Integer
External_Function LsProfileStartEf "LsProfileStartW" LLStgsysDllName Handle hThread WString wDescr WString wFilename Integer nTicksMS Returns Integer  
#ELSE
External_Function LlStgsysStorageOpenEf "LlStgsysStorageOpenA" LLStgsysDllName Pointer lpszFilename Pointer pszTempPath Integer bReadOnly Integer bOneJobTranslation Returns Handle
external_function LlStgsysGetFilenameEf "LlStgsysGetFilenameA" LLStgsysDllName Integer hStg Integer nJob Integer nFile Pointer pszBuffer Integer nBufSize Returns Integer  
external_function LlStgsysGetPageOptionStringEf "LlStgsysGetPageOptionStringA" LLStgsysDllName Integer hStg Integer nPageIndex Integer nOption Pointer pszBuffer Integer nBufSize Returns Integer  
external_function LlStgsysSetPageOptionStringEf "LlStgsysSetPageOptionStringA" LLStgsysDllName Integer hStg Integer nPageIndex Integer nOption Pointer pszBuffer Returns Integer  
external_function LlStgsysPrintEf "LlStgsysPrintA" LLStgsysDllName Integer hStg Pointer pszPrinterName1 Pointer pszPrinterName2 Integer nStartPageIndex Integer nEndPageIndex Integer nCopies Integer nFlags Pointer pszMessage Handle hWndParent Returns Integer  
external_function LlStgsysStoragePrintEf "LlStgsysStoragePrintA" LLStgsysDllName Pointer lpszFilename Pointer pszTempPath Pointer pszPrinterName1 Pointer pszPrinterName2 Integer nStartPageIndex Integer nEndPageIndex Integer nCopies Integer nFlags Pointer pszMessage Handle hWndParent Returns Integer  
External_Function LlStgsysGetPagePrinterEf "LlStgsysGetPagePrinterA" LLStgsysDllName Integer hStg Integer nPageIndex Pointer pszDeviceName Integer nDeviceNameSize Pointer phDevMode Returns Integer  
External_Function LsGetViewerControlClassNameEf "LsGetViewerControlClassNameA" LLStgsysDllName Returns Pointer  
External_Function LlStgsysGetJobOptionStringExEf "LlStgsysGetJobOptionStringExA" LLStgsysDllName Integer hStg Pointer pszKey Pointer pszBuffer Integer nBufSize Returns Integer  
External_Function LlStgsysSetJobOptionStringExEf "LlStgsysSetJobOptionStringExA" LLStgsysDllName Integer hStg Pointer pszKey Pointer pszBuffer Returns Integer  
External_Function LlStgsysStorageCloseEf "LlStgsysStorageClose" LLStgsysDllName Integer hStg Returns Integer  
External_Function LlStgsysGetAPIVersionEf "LlStgsysGetAPIVersion" LLStgsysDllName Integer hStg Returns Integer  
External_Function LlStgsysGetFileVersionEf "LlStgsysGetFileVersion" LLStgsysDllName Integer hStg Returns Integer  
External_Function LlStgsysGetJobCountEf "LlStgsysGetJobCount" LLStgsysDllName Integer hStg Returns Integer  
External_Function LlStgsysSetJobEf "LlStgsysSetJob" LLStgsysDllName Integer hStg Integer nJob Returns Integer  
External_Function LlStgsysGetJobEf "LlStgsysGetJob" LLStgsysDllName Integer hStg Returns Integer  
External_Function LlStgsysGetPageCountEf "LlStgsysGetPageCount" LLStgsysDllName Integer hStg Returns Integer  
External_Function LlStgsysGetJobOptionValueEf "LlStgsysGetJobOptionValue" LLStgsysDllName Integer hStg Integer nOption Returns Integer  
External_Function LlStgsysGetPageOptionValueEf "LlStgsysGetPageOptionValue" LLStgsysDllName Integer hStg Integer nPageIndex Integer nOption Returns Integer  
External_Function LlStgsysAppendEf "LlStgsysAppend" LLStgsysDllName Integer hStg Integer hStgToAppend Returns Integer  
External_Function LlStgsysDeleteJobEf "LlStgsysDeleteJob" LLStgsysDllName Integer hStg Integer nPageIndex Returns Integer  
External_Function LlStgsysDeletePageEf "LlStgsysDeletePage" LLStgsysDllName Integer hStg Integer nPageIndex Returns Integer  
External_Function LlStgsysGetPageMetafileEf "LlStgsysGetPageMetafile" LLStgsysDllName Integer hStg Integer nPageIndex Returns Handle  
External_Function LlStgsysGetPageMetafile16Ef "LlStgsysGetPageMetafile16" LLStgsysDllName Integer hStg Integer nPageIndex Returns Handle  
External_Function LlStgsysDestroyMetafileEf "LlStgsysDestroyMetafile" LLStgsysDllName Handle hMF Returns Integer  
External_Function LlStgsysDrawPageEf "LlStgsysDrawPage" LLStgsysDllName Integer hStg Handle hDC Handle hPrnDC Integer bAskPrinter Pointer pRC Integer nPageIndex Integer bFit Pointer pReserved Returns Integer  
External_Function LlStgsysGetLastErrorEf "LlStgsysGetLastError" LLStgsysDllName Integer hStg Returns Integer  
External_Function LlStgsysDeleteFilesEf "LlStgsysDeleteFiles" LLStgsysDllName Integer hStg Returns Integer  
External_Function LlStgsysConvertEf "LlStgsysConvertA" LLStgsysDllName Integer hStg Pointer pszDstFilename Pointer pszFormat Returns Integer  
External_Function LlStgsysStorageConvertEf "LlStgsysStorageConvertA" LLStgsysDllName Pointer pszStgFilename Pointer pszDstFilename Pointer pszFormat Returns Integer  
External_Function LlStgsysGetLLFilenameEf "LlStgsysGetLLFilenameA" LLStgsysDllName Pointer pszFilename Pointer pszTempPath Pointer pszBuffer Integer nSize Returns Integer  
External_Function LlStgsysStorageCreateEf "LlStgsysStorageCreateA" LLStgsysDllName Pointer lpszFilename Pointer pszTempPath Handle hRefDC Pointer prcArea Integer bPhysicalPage Returns Integer  
External_Function LlStgsysAppendEMFEf "LlStgsysAppendEMF" LLStgsysDllName Integer hStg Handle hEMFToAppend Handle hRefDC Pointer prcArea Integer bPhysicalPage Returns Integer  
External_Function LlStgsysStorageOpenExEf "LlStgsysStorageOpenExA" LLStgsysDllName Pointer lpszFilename Pointer pSOI Returns Integer
External_Function LsConversionJobOpenEf "LsConversionJobOpenA" LLStgsysDllName Handle hWndParent Integer nLanguage Pointer pszFormat Returns Integer  
External_Function LsConversionPrintEf "LsConversionPrintA" LLStgsysDllName Integer hCnvJob Pointer pStream Pointer pszBufFilename Integer nBufSize Returns Integer  
External_Function LsConversionSetOptionStringEf "LsConversionSetOptionStringA" LLStgsysDllName Integer hCnvJob Pointer pszKey Pointer pszData Returns Integer  
External_Function LsConversionJobCloseEf "LsConversionJobClose" LLStgsysDllName Integer hCnvJob Returns Integer  
External_Function LsConversionConvertEMFToStreamEf "LsConversionConvertEMFToStream" LLStgsysDllName Integer hCnvJob Handle hEMF Pointer pStream Returns Integer  
External_Function LsConversionConvertStgToStreamEf "LsConversionConvertStgToStream" LLStgsysDllName Integer hCnvJob Integer hStg Pointer pStream Returns Integer  
External_Function LsConversionConfigurationDlgEf "LsConversionConfigurationDlg" LLStgsysDllName Integer hCnvJob Handle hWndParent Returns Integer  
External_Function LsConversionGetOptionStringEf "LsConversionGetOptionStringA" LLStgsysDllName Integer hCnvJob Pointer pszKey Pointer pszBuffer Integer nBufSize Returns Integer  
External_Function LsConversionConvertEMFToFileEf "LsConversionConvertEMFToFileA" LLStgsysDllName Integer hCnvJob Handle hEMF Pointer pszFilename Returns Integer  
External_Function LsConversionConvertStgToFileEf "LsConversionConvertStgToFileA" LLStgsysDllName Integer hCnvJob Integer hStg Pointer pszFilename Returns Integer  
External_Function LsCreateViewerControlOverParentEf "LsCreateViewerControlOverParent" LLStgsysDllName Integer hStg Handle hParentControl Returns Integer  
External_Function LsMailConfigurationDialogEf "LsMailConfigurationDialogA" LLStgsysDllName Handle hWndParent Pointer pszSubkey Integer nFlags Integer nLanguage Returns Integer  
External_Function LsMailJobOpenEf "LsMailJobOpen" LLStgsysDllName Integer nLanguage Returns Integer  
External_Function LsMailJobCloseEf "LsMailJobClose" LLStgsysDllName Integer hJob Returns Integer  
External_Function LsMailSetOptionStringEf "LsMailSetOptionStringA" LLStgsysDllName Integer hJob Pointer pszKey Pointer pszValue Returns Integer  
External_Function LsMailGetOptionStringEf "LsMailGetOptionStringA" LLStgsysDllName Integer hJob Pointer pszKey Pointer pszBuffer Integer nBufSize Returns Integer  
External_Function LsMailSendFileEf "LsMailSendFile" LLStgsysDllName Integer hJob Handle hWndParent Returns Integer  
External_Function LsMailViewEf "LsMailViewA" LLStgsysDllName Handle hWndParent Pointer pszMailFile Integer nRights Integer nLanguage Returns Integer
External_Function LsProfileStartEf "LsProfileStartA" LLStgsysDllName Handle hThread Pointer pszDescr Pointer pszFilename Integer nTicksMS Returns Integer  
#ENDIF
// OEM/Ansi Defines for DataFlex <20.0
External_Function LsSetDebugEf "LsSetDebug" LLStgsysDllName Integer bOn Returns Integer  
#IF (USELLVERSION>15)
External_Function LSConvertImageStreamEf "LSConvertImageStream" LLStgsysDLLName Pointer pGDICommentData Handle hGlobal Integer nOptions Returns Integer
#ENDIF
External_Function LsGetViewerControlDefaultMessageEf "LsGetViewerControlDefaultMessage" LLStgsysDllName Returns Integer  

external_function LsDrawInputObjectEf "LsDrawInputObject" LLStgsysDllName Handle hDC Pointer pRC Integer nType Pointer pOptions Returns Integer  
External_Function LsProfileEndEf "LsProfileEnd" LLStgsysDllName Handle hThread Returns Integer
External_Function LsGetDDXFormsEf "LsGetDDXForms" LLStgsysDllName Pointer ppEnumString Returns Integer
External_Function LlStgsysStorageOpen13Ef "LlStgsysStorageOpen13" LLStgsysDllName Pointer pFileSys Returns Integer
External_Function LsInternalCreateViewerControlOverParent13Ef "LsInternalCreateViewerControlOverParent13" LLStgsysdllName Handle hParentControl Integer nFlags Returns Integer
External_Function LsInternalGetViewerControlFromParent13Ef "LsInternalGetViewerControlFromParent13" LLStgsysDllName Integer hParentControl Returns Integer
External_Function LsSetDlgboxModeEf "LsSetDlgboxMode" LLStgsysDllName Integer nMode Returns Integer
External_Function LsGetDlgboxModeEf "LsGetDlgboxMode" LLStgsysDllName Returns Integer

Struct scStorageOpenInfo
    Integer nSize
    Pointer pszTempPath
    Pointer pApp
    Boolean bReadOnly
    Boolean bOneJobTranslation
End_Struct

Struct scViewerKeyboardMSG
    Handle hWnd
    Integer message
    Integer wParam
    Integer lParam
    DWord Time
    DWord ptX
    DWord ptY
End_Struct

Struct scViewerControlPrintData
    Integer nSize
    Integer nPages
    Integer nAbcAbcCopies
    Integer nPage
    Integer nCopy
    Integer nAbcAbcCopy
    Pointer pszDevice
    Pointer pszProject
    Pointer pszJobName
    Integer nAAABBBCCCCopies
    #IFDEF Is$Win64
    Integer iAlign1
    #ENDIF            
End_Struct

Struct scViewChangedInfo
    Integer nSize
    DWord   fZoom
    DWord   fOffsetX
    DWord   fOffsetY
    Integer bPresentationMode
End_Struct


// **********************************************************************************************************
// Some helper functions
// **********************************************************************************************************

Function LLZeroString Global Integer iLen Returns String
    Function_Return (Repeat(Character(0),iLen))
End_Function

#IFDEF GET_COPYMEMORYE
#ELSE
Function CopyMemoryE Global Pointer pDest Pointer pSrc Integer iL Returns Integer
    If (pDest=0) ;
        Function_Return 0     // Catch NULL-Pointers
    If (pSrc=0) ;
        Function_Return 0     //      ...
    Function_Return (CopyMemory(pDest,pSrc,iL))
End_Function
#ENDIF

#IFDEF GET_TEMPDIRECTORY
#ELSE
#IF (!@>199)
External_Function GetTempPath "GetTempPathW" kernel32.dll Integer dwBufferLen Pointer lpBuffer Returns Integer
Function TempDirectory Global Returns String
    String sTempDir
    Pointer pTempDir
    WString wBuff
    Integer iRet
    Move (Repeat(Character(0),240)) to wBuff
    Move (GetTempPath(240,(AddressOf(wBuff)))) to iRet
    If (iRet<>0) Begin
        Move (CString(wBuff)) to sTempDir
        If (Right(sTempDir,1)="\") ;
            Move (Left(sTempDir,( (length(sTempDir)) -1 ))) to sTempDir 
        Function_Return sTempDir
    End
    Function_Return "."
End_Function
#ELSE
External_Function GetTempPath "GetTempPathA" kernel32.dll Integer dwBufferLen Pointer lpBuffer Returns Integer
Function TempDirectory GLOBAL Returns String
    String sTempDir
    Pointer pTempDir
    Integer iRet
    Move (Repeat(Character(0),120)) to sTempDir
    Move (AddressOf(sTempDir)) to pTempDir
    Move (GetTempPath(120,pTempDir)) to iRet
    If (iRet<>0) Begin
        Move (AnsiToOem(pTempDir,pTempDir)) to iRet
        Move (cString(sTempDir)) to sTempDir
        If (Right(sTempDir,1)="\") ;
            Move (Left(sTempDir,( (length(sTempDir)) -1 ))) to sTempDir 
        Function_Return sTempDir
    End
    Function_Return "."
End_Function
#ENDIF
#ENDIF  

#IFDEF GET_DELETEMENUEF
#ELSE
external_function DeleteMenuEf "DeleteMenu" user32.dll Handle hMenu Integer uPosition Integer uFlags Returns Integer
#ENDIF

#IFDEF GET_ENABLEMENUITEMEF
#ELSE
external_function EnableMenuItemEf "EnableMenuItem" user32.dll Handle hMenu Integer uItem Integer uEnable Returns Integer
#ENDIF

#IFDEF GET_INSERTMENUITEMEF
#ELSE
external_function InsertMenuItemEf "InsertMenuItemA" user32.dll Handle hMenu Integer uItem Integer fByPosition Pointer lpMnItem Returns Integer
#ENDIF

#IFDEF GET_GETFOCUSEF
#ELSE
external_function GetFocusEf "GetFocus" user32.dll Returns Handle
#ENDIF

#IFDEF GET_GETFOREGROUNDWINDOWEF
#ELSE
external_function GetForegroundWindowEf "GetForegroundWindow" user32.dll Returns Handle 
#ENDIF

Struct tDbField
    String  sName
    Integer iType
    Integer iRelatedFile
    Integer iRelatedField
    Integer iIndex
End_Struct
Struct tDbIndexSegment
    Integer iField
End_Struct
Struct tDbIndex
    Integer           iSegments
    tDbIndexSegment[] aSegments
End_Struct
Struct tDbFile
    Integer    iFileNum
    String     sLogicalName
    String     sDisplayName
    Integer    iSystemFile
    Integer    iRecnumTable
    Integer    iPrimaryIndex
    Integer    iNumberFields
    Integer    iLastIndexNumber
    tDbField[] aFields
    tDbIndex[] aIndexes
End_Struct

#IF (!@>109)
Struct tAliasDbField
    String sField
    Integer iFile
    Integer iField
    Integer iType
End_Struct
Struct tAliasDb
    String sAliasName
    tAliasDbField[] sFields
End_Struct
#ENDIF
#IF (!@>109)
Struct tLLDataField
    String sName
    Integer iType
    Integer iDataIndex
    Integer iFile
    Integer iField
End_Struct
Class cListLabelDataObject is a cObject
    Procedure Construct_Object
        Forward Send Construct_Object
        Property Variant[][] pvData
        Property Integer piDataIndex
        Property Boolean pbIsVariable
        Property Boolean pbIsField
        Property Boolean pbWasCreated
        Property String psName
        Property tLLDataField[] paAllDataFields
        Property tLLDataField[] paUsedDataFields
        Property String[] paFieldNames
    End_Procedure
    
    #IF (!@<120)
    function fFindInStringArray string sSearchVal string[] aArray returns integer
        integer iCou
        for iCou from 0 to (SizeOfarray(aArray)-1)
            if (sSearchVal=aArray[iCou]) function_return iCou
        loop
        function_return -1
    end_function
    #ENDIF
    Function FieldNum String sName Returns Integer
        Integer iRetval
        String[] aFieldNames
        Move (Uppercase(Trim(sName))) to sName
        Get paFieldNames to aFieldNames
        #IF (!@<120)
        Move (fFindInStringArray(Self,sName,aFieldNames)) to iRetVal
        #ELSE
        Move (SearchArray(sName,aFieldNames)) to iRetval
        #ENDIF
        Function_Return iRetval        
    End_Function
    Procedure DoAddField String sName Integer iType Integer iFile Integer iField String sDefVal
        tLLDataField aField
        tLLDataField[] aAllFields
        String[] aFieldNames
        String sField 
        Integer iRet
        
        Get paAllDataFields to aAllFields
        Get paFieldNames to aFieldNames
        #IF (!@<120)
        if (fFindInStringArray(self,sName,aFieldNames)=-1) Begin
        #ELSE
        If (SearchArray(sName,aFieldNames)=-1) Begin
        #ENDIF
            Move sName to aField.sName
            Move iType to aField.iType
            Move iFile to aField.iFile
            Move iField to aField.iField
            Move (SizeOfArray(aAllFields)) to aField.iDataIndex
            Move aField to aAllFields[(SizeOfArray(aAllFields))]
            Move sName to aFieldNames[(SizeOfArray(aFieldNames))]
        End
        
        Move ((psName(Self)) + "." + sName) to sField
        If (pbIsVariable(Self)) Begin
            Get LLDefineVariableExt sField sDefVal iType to iRet
        End
        If (pbIsField(Self)) Begin
            Get LLDefineFieldExt sField sDefVal iType to iRet
        End        
        Set paAllDataFields to aAllFields
        Set paFieldNames to aFieldNames
    End_Procedure
    Procedure DoAddFieldsFromDb Integer iFile 
        Integer iFields iCou iDfType iLLType iRet iDateFormat
        String sField sCont
        tDbFile aFile
        
        Get piDateFormat to iDateFormat
        Get fFileStruct iFile to aFile
        Move aFile.iNumberFields to iFields
        For iCou from 0 to iFields
            Move aFile.aFields[iCou].sName to sField
            Move aFile.aFields[iCou].iType to iDfType
            Move -1 to iLLType

            If (iDFType=DF_DATE) ;
                Move iDateFormat to iLLType
            If (iDFType=DF_BCD) ;
                Move LL_NUMERIC to iLLType
            If (iLLType=-1) ;
                Move LL_TEXT to iLLType
            
            Send DoAddField (Trim(sField)) iLLType iFile iCou ""
        Loop        
    End_Procedure
    Procedure DoSetData Variant[][] vData
        tLLDataField[] aUsedFields
        Integer iField iRet
        Set pvData to vData
        Set piDataIndex to -1
    End_Procedure
    
    Function DbValuesAsArray Integer iFile Boolean bOnlyUsed Returns Variant[]
        Integer iField iFields iCou
        Variant[] vReturn
        tLLDataField[] aUsedFields
        tDbFile aFile
        
        Get fFileStruct iFile to aFile
        If (not(bOnlyUsed)) Begin
            Move aFile.iNumberFields to iFields
            For iField from 0 to iFields
                Get_Field_Value iFile iField to vReturn[iField]
            Loop
        End
        Else Begin
            Move aFile.iNumberFields to iFields
            #IF (!@<120)
            Move (ResizeArray(vReturn,(iFields+1))) to vReturn
            #ELSE
            Move (ResizeArray(vReturn,(iFields+1),"")) to vReturn
            #ENDIF
            Get paUsedDataFields to aUsedFields
            For iCou from 0 to (SizeOfArray(aUsedFields)-1)
                If (aUsedFields[iCou].iFile=iFile) Begin
                    Get_Field_Value iFile aUsedFields[iCou].iField to vReturn[aUsedFields[iCou].iDataIndex]
                End
            Loop
        End
        Function_Return vReturn
    End_Function
    
    Function FindRecord Integer iFindMode Returns Integer
        Variant[][] vData
        Integer iIndex
        Get pvData to vData
        Get piDataIndex to iIndex
        
        If (iFindMode=FIRST_RECORD) Begin
            Move 0 to iIndex
        End
        If (iFindMode=LAST_RECORD) Begin
            Move (SizeOfArray(vData)-1) to iIndex
        End
        If ( (iFindMode=NEXT_RECORD) or (iFindMode=(gt)) ) Begin
            Move (iIndex+1) to iIndex
        End
        If (iFindMode=(LT)) Begin
            If (iIndex=-1) ;
                Move (SizeOfArray(vData)-1) to iIndex
            Else ;
                Move (iIndex-1) to iIndex
        End
        If (iIndex<0) Begin
            Set piDataIndex to -1
            Function_Return (False)
        End
        If (SizeOfArray(vData)<=iIndex) Begin
            Set piDataIndex to -1
            Function_Return (False)
        End
        Set piDataIndex to iIndex
        Function_Return (True)
    End_Function
    
    Function FindRecordWithValue String sField String sValue Returns Integer
        Variant[][] vData
        Integer iField iCou
        
        Get FieldNum sField to iField
        Set piDataIndex to -1
        If (iField=-1) ;
            Function_Return (False)
        Get pvData to vData
        For iCou from 0 to (SizeOfArray(vData)-1)
            If (vData[iCou][iField]=sValue) Begin
                Set piDataIndex to iCou
                Function_Return (True)
            End
        Loop
        Function_Return (False) 
    End_Function
    
    Function RowCount Returns Integer
        Variant[][] vData
        Get pvData to vData
        Function_Return (SizeOfArray(vData))
    End_Function
    Function ColCount Returns Integer
        tLLDataField[] aAllFields
        Get paAllDataFields to aAllFields
        Function_Return (SizeOfArray(aAllFields))        
    End_Function
    Procedure AddRows Variant[][] vData
        Integer iCou
        Variant[][] vExistingData
        
        Get pvData to vExistingData
        For iCou from 0 to (SizeOfArray(vData)-1)
            Move vData[iCou] to vExistingData[(SizeOfArray(vExistingData))]
        Loop
        Set pvData to vExistingData
    End_Procedure
    Function MoveFirst Returns Boolean
        Variant[][] vData
        Get pvData to vData
        If (SizeOfArray(vData)=0) Begin
            Set piDataIndex to -1
            Function_Return False
        End
        Set piDataIndex to 0
        Function_Return True
    End_Function
    Function MoveNext Returns Boolean
        Variant[][] vData
        Integer iIndex
        Get pvData to vData
        If (SizeOfArray(vData)=0) Begin
            Set piDataIndex to -1
            Function_Return False
        End
        Get piDataIndex to iIndex
        Move (iIndex+1) to iIndex
        If (SizeOfArray(vData)<=iIndex) Begin
            Set piDataIndex to -1
            Function_Return (False)
        End
        Set piDataIndex to iIndex
        Function_Return True        
    End_Function
    Function AddField String sName Integer iFieldType Returns Boolean
        Integer iFields
        Get RowCount to iFields
        Send DoAddField sName iFieldType 0 0 ""
        Function_Return (RowCount(Self)>iFields)
    End_Function
    Function DeleteField String sName Returns Boolean
        tLLDataField aField
        tLLDataField[] aAllFields aNewFields
        String[] aFieldNames aNewFieldNames
        String sField 
        Integer iRet iField iCou
        
        Get paAllDataFields to aAllFields
        Get paFieldNames to aFieldNames

        #IF (!@<120)
        move (fFindInStringArray(self,sName,aFieldNames)=-1) to iField
        #ELSE
        Move (SearchArray(sName,aFieldNames)) to iField
        #ENDIF
        If (iField=-1) Begin
            Function_Return False
        End
        For iCou from 0 to (iField-1)
            Move aAllFields[iCou] to aNewFields[(SizeOfArray(aNewFields))]
            Move aFieldNames[iCou] to aNewFieldNames[(SizeOfArray(aNewFieldNames))]
        Loop
        For iCou from (iField+1) to (SizeOfArray(aAllFields)-1)
            Move aAllFields[iCou] to aNewFields[(SizeOfArray(aNewFields))]
            Move aFieldNames[iCou] to aNewFieldNames[(SizeOfArray(aNewFieldNames))]
        Loop
        Set paAllDataFields to aNewFields
        Set paFieldNames to aNewFieldNames
        Function_Return True
    End_Function
    Function GetFieldData Integer iColumn Returns Variant
        Integer iIndex
        Variant[][] vData
        Variant vRet
        
        Get piDataIndex to iIndex
        If (iIndex=-1) ;
            Function_Return vRet
        Get pvData to vData
        If (SizeOfArray(vData)<=iIndex) ;
            Function_Return vRet
        If (SizeOfArray(vData[iIndex])<=iColumn) ;
            Function_Return vRet
        Move (vData[iIndex][iColumn]) to vRet
        Function_Return vRet
    End_Function
    Function GetFieldName Integer iColumn Returns String
        tLLDataField[] aAllFields
        Get paAllDataFields to aAllFields
        If (SizeOfArray(aAllFields)<=iColumn) ;
            Function_Return ""
        Function_Return aAllFields[iColumn].sName
    End_Function
    Function GetFieldType Integer iColumn Returns Integer
        tLLDataField[] aAllFields
        Get paAllDataFields to aAllFields
        If (SizeOfArray(aAllFields)<=iColumn) ;
            Function_Return LL_TEXT
        Function_Return aAllFields[iColumn].iType
    End_Function    
    Function MoveToRecord Integer irecord Returns Boolean
        Variant[][] vdata
        Get pvdata to vdata
        If (sizeofarray(vdata)<=irecord) Begin
            Set pidataindex to -1
            Function_Return (False)
        End
        Set pidataindex to irecord
        Function_Return True
    End_Function
    Function GetEof Returns Boolean
        Variant[][] vData
        Get pvData to vData
        If (piDataIndex(Self)=-1) ;
            Function_Return True
        If (piDataIndex(Self)=(SizeOfArray(vData)-1)) ;
            Function_Return True
        Function_Return False
    End_Function
    
    
    Procedure find_by_recnum
    End_Procedure
    Function main_file Returns Integer
    End_Function
    Procedure Set main_file
    End_Procedure
    Function current_record Returns Integer
    End_Function
    Function constrain_file Returns Integer
    End_Function
    Procedure Set constrain_file 
    End_Procedure
End_Class
    
#ENDIF

#IFDEF Is$WebApp
Class cListLabelWebNotificationWindow is a DfBasePanel
    #IF (!@>199)
    Register_Procedure LLNotification Longptr wParam Longptr lParam
    #ELSE
    Register_Procedure LLNotification Integer wParam Integer lParam
    #ENDIF
    Procedure Construct_Object
        Property Integer piNotificationTarget 0
        Set Size to 0 0
        Set Location to -4000 -4000
        Set external_class_name "cListLabelWebNotificationWindow" to "STATIC"
        Set external_message (WM_USER+530) to msg_LLNotification
        #IFDEF Is$WebApp
        Set Visible_State to False
        #ENDIF
        Forward Send Construct_Object
    End_Procedure
    
    #IF (!@>199)
    Procedure LLNotification Longptr nMessage Longptr lParamEx
    #ELSE
    Procedure LLNotification Integer nMessage Integer lParamEx
    #ENDIF
        If (piNotificationTarget(Self)<>0) Begin
            Send LLNotification to (piNotificationTarget(Self)) nMessage lParamEx
        End
    End_Procedure
End_Class    
#ELSE
Class cListLabelNotificationWindow is a ToolPanel    
    #IF (!@>199)
    Register_Procedure LLNotification Longptr wParam Longptr lParam
    #ELSE
    Register_Procedure LLNotification Integer wParam Integer lParam
    #ENDIF
    Procedure Construct_Object
        Property Integer piNotificationTarget 0
        Set Size to 0 0
        Set Location to -4000 -4000
        Set external_class_name "cListLabelNotificationWindow" to "STATIC"
        Set external_message (WM_USER+530) to msg_LLNotification
        #IFDEF Is$WebApp
        Set Visible_State to False
        #ENDIF
        Forward Send Construct_Object
    End_Procedure
    
    #IF (!@>199)
    Procedure LLNotification Longptr nMessage Longptr lParamEx
    #ELSE
    Procedure LLNotification Integer nMessage Integer lParamEx
    #ENDIF
        If (piNotificationTarget(Self)<>0) Begin
            Send LLNotification to (piNotificationTarget(Self)) nMessage lParamEx
        End
    End_Procedure
End_Class    
#ENDIF


// **********************************************************************************************************
// Class-Definition
// **********************************************************************************************************
#IF (!@ >= 120)
{ OverrideProperty=Bitmap Visibility=Private }
{ OverrideProperty=Bitmap_Style Visibility=Private }
{ OverrideProperty=Color Visibility=Private }
{ OverrideProperty=FontItalics Visibility=Private }
{ OverrideProperty=FontSize Visibility=Private }
{ OverrideProperty=FontUnderline Visibility=Private }
{ OverrideProperty=FontWeight Visibility=Private }
{ OverrideProperty=Location Visibility=Private }
{ OverrideProperty=peAnchors Visibility=Private }
{ OverrideProperty=Physical_FontSize Visibility=Private }
{ OverrideProperty=piMaxSize Visibility=Private }
{ OverrideProperty=piMinSize Visibility=Private }
{ OverrideProperty=Size Visibility=Private }
{ OverrideProperty=TextColor Visibility=Private }
{ OverrideProperty=Transparent_State Visibility=Private }
{ OverrideProperty=Typeface Visibility=Private }
{ OverrideProperty=Visible_State Visibility=Private }
{ OverrideProperty=Attach_Parent_State Visibility=Private }
{ OverrideProperty=Block_Mouse_State Visibility=Private }
{ OverrideProperty=Client_Area_State Visibility=Private }
{ OverrideProperty=Focus_mode Visibility=Private }
{ OverrideProperty=OEM_Translate_state Visibility=Private }
{ OverrideProperty=Popup_State Visibility=Private }
{ OverrideProperty=Ring_State Visibility=Private }
{ OverrideProperty=Scope_State Visibility=Private }
{ OverrideProperty=Search_Case Visibility=Private }
{ OverrideProperty=Skip_State Visibility=Private }
{ OverrideProperty=Border_Style Visibility=Private }
#ENDIF
Class cListLabelWrapper is a DFControl
    #IF (!@>199)
    Register_Procedure LLNotification Longptr wParam Longptr lParam
    #ELSE
    Register_Procedure LLNotification Integer wParam Integer lParam
    #ENDIF
    Register_Procedure LLStartDesignerPreview Integer wParam Integer lParam
    Procedure Construct_Object
        Integer iDateFormat
        Forward Send Construct_Object
        Set size to 10 10
        // Hidden definitive
        Set location to 4500 4500
        Set visible_state to false
        Set focus_mode to nonfocusable
        Set skip_state to true
        Set external_class_name "cListLabelWrapper" to "STATIC"
        // Set the List & Label Notification Message
        Set external_message (WM_USER+530) to msg_LLNotification
        Set External_Message (WM_USER+532) to msg_LLStartDesignerPreview
        // Public Properties for List & Label Settings
        
        // Don't forget to set the correct LicenseKey with the property psLicensingInfo.
        // Otherwise List & Label fails to work if installed on a client machine
        // psLicensingInfo should be set directly in the application, not here in the class-definition        
        Property String  psLicensingInfo             ""
        // With the piUiStyle property you can change the Style of the UI
        // Possible Values: LL_OPTION_UISTYLE_STANDARD and LL_OPTION_UISTYLE_OFFICEXP
        #IF (!@ >= 120)
        { EnumList="LL_OPTION_UISTYLE_STANDARD, LL_OPTION_UISTYLE_OFFICEXP, LL_OPTION_UISTYLE_OFFICE2003" }
        #ENDIF
        Property Integer piUiStyle                   LL_OPTION_UISTYLE_STANDARD
        // With the piDlgBoxMode property the UI of Dialogboxes and Buttons can be changed
        // Read the List & Label documentation for more informations
        #IF (!@ >= 120)
        { EnumList="LL_DLGBOXMODE_3DBUTTONS, LL_DLGBOXMODE_3DFRAME2, LL_DLGBOXMODE_3DFRAME, LL_DLGBOXMODE_NOBITMAPS" }
        { EnumList+="LL_DLGBOXMODE_DONTCARE, LL_DLGBOXMODE_SAA, LL_DLGBOXMODE_ALT1, LL_DLGBOXMODE_ALT2, LL_DLGBOXMODE_ALT3" }
        { EnumList+="LL_DLGBOXMODE_ALT4, LL_DLGBOXMODE_ALT5, LL_DLGBOXMODE_ALT6, LL_DLGBOXMODE_ALT7, LL_DLGBOXMODE_ALT8" }
        { EnumList+="LL_DLGBOXMODE_ALT9, LL_DLGBOXMODE_ALT10, LL_DLGBOXMODE_TOOLTIPS98" }
        #ENDIF
        Property Integer piDlgBoxMode                (LL_DLGBOXMODE_ALT10 ior LL_DLGBOXMODE_NOBITMAPS ior LL_DLGBOXMODE_TOOLTIPS98)
        // Set the property piUseLanguage to use a different language 
        // (only possible if you have buyed additional language kit's
        #IF (!@ >= 120)
        { EnumList="CMBTLANG_DEFAULT, CMBTLANG_GERMAN, CMBTLANG_ENGLISH, CMBTLANG_ARABIC, CMBTLANG_AFRIKAANS, CMBTLANG_ALBANIAN, CMBTLANG_BASQUE" }
        { EnumList+="CMBTLANG_BULGARIAN, CMBTLANG_BYELORUSSIAN, CMBTLANG_CATALAN, CMBTLANG_CHINESE, CMBTLANG_CROATIAN, CMBTLANG_CZECH, CMBTLANG_DANISH" }
        { EnumList+="CMBTLANG_DUTCH, CMBTLANG_ESTONIAN, CMBTLANG_FAEROESE, CMBTLANG_FARSI, CMBTLANG_FINNISH, CMBTLANG_FRENCH, CMBTLANG_GREEK, CMBTLANG_HEBREW" }              
        { EnumList+="CMBTLANG_HUNGARIAN, CMBTLANG_ICELANDIC, CMBTLANG_INDONESIAN, CMBTLANG_ITALIAN, CMBTLANG_JAPANESE, CMBTLANG_KOREAN, CMBTLANG_LATVIAN" }             
        { EnumList+="CMBTLANG_LITHUANIAN, CMBTLANG_NORWEGIAN, CMBTLANG_POLISH, CMBTLANG_PORTUGUESE, CMBTLANG_ROMANIAN, CMBTLANG_RUSSIAN, CMBTLANG_SLOVAK" }
        { EnumList+="CMBTLANG_SLOVENIAN, CMBTLANG_SERBIAN, CMBTLANG_SPANISH, CMBTLANG_SWEDISH, CMBTLANG_THAI, CMBTLANG_TURKISH, CMBTLANG_UKRAINIAN" }
        { EnumList+="CMBTLANG_CHINESE_TRADITIONAL, CMBTLANG_PORTUGUESE_BRAZILIAN, CMBTLANG_SPANISH_COLOMBIA, CMBTLANG_UNSPECIFIED" }
        #ENDIF
        Property Integer piUseLanguage               CMBTLANG_DEFAULT
        // With piDebugMode you can switch on debugging of List & Label functions
        // see LLSetDebug in the List & Label documentation for possible values
        #IF (!@ >= 120)
        { EnumList="LL_DEBUG_CMBTLL, LL_DEBUG_CMBTDWG, LL_DEBUG_CMBTLS" }
        #ENDIF
        Property Integer piDebugMode                 0 // (LL_DEBUG_CMBTLL ior LL_DEBUG_CMBTDWG ior LL_DEBUG_CMBTLS)
        // With piNoParameterCheck you can switch of the internal parameter-checking of List & Label
        // When set to TRUE (default) no Parameter Checking is done which speed's up the load time
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF        
        Property Integer piNoParameterCheck          TRUE
        // With piXlatVarnames the internal checking of variable names can be switched off
        // If you don't use any special characters in variables and fields, this should be set to 
        // false to speed up the report
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                
        Property Integer piXLatVarNames              False
        // piConvertCrLF is used to switch the internal translation of CR/LF combinations to LF on or off
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                
        Property Integer piConvertCrLF               TRUE        
        // piMaxRtfVersion (Default 512 which means RTF-Version 2): Set the used RTF Version
        // see the List & Label documentation on LL_OPTION_MAXRTFVERSION for more infos
        Property Integer piMaxRtfVersion             512
        
        // piPreviewPanel, piPreviewObject
        // These Properties can be used to display the Preview in an own Window rather to use the List & Label
        // Standard-Preview Window.
        // If you want to do this you have to create a Standard VDF View (not deferred!) and put an cListLabelViewer
        // into the View. Then just set the piPreviewPanel Property to the Object-Id of the View and the piPreviewObject
        // Property to the Object-Id of the cListLabelViewer Object. To display the Preview you just have to call 
        // LLPreviewDisplay as you would do with the Standardpreview, if both Properties are set your View is displayed
        // instead. The sample uses this technique, so look into it to find more information.
        Property Integer piPreviewPanel              0
        Property Integer piPreviewObject             0
        
        Property Integer piEmbeddedPreviewObjectInt  0
        Property Integer piEmbeddedPreviewCancelBtn  0
        
        // pbIncrementalPreview: Set to TRUE if you want to display the preview while printing.
        // Take care about one special case:
        // While the Report run's the Preview-Window is already displayed and the User is able to close the
        // Window (which result's in an aborting of the Print-Job). It is important, that you call the
        // LLPreviewDisplay Function which (in this case) doesn't display any Preview but only cleans up some
        // important internal stuff.
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                        
        Property Integer pbIncrementalPreview        True
        
        // piTrimDbValues: If set to true, all Variable/Field-Values that come out of a database are trimmed
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                        
        Property Integer piTrimDbValues False
        // pbUseDrilldown: Set to true if you want to use Drilldown-Reporting
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                        
        Property Integer pbUseDrilldown False        
        // pbIsDrilldown: You can check this Property to see if a Drilldown-Report is running
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                        
        Property Integer pbIsDrilldown False
        // piDrilldownDatabaseFiltering: With this Property you can control which Database(s) are presented to the User if a Drilldown-Report is created
        #IF (!@ >= 120)
        { EnumList="LL_DRILLDOWNFILTERSTRATEGY_ALLOW_ONLY_SUBTABLES, LL_DRILLDOWNFILTERSTRATEGY_ALLOW_ALL_TABLES, LL_DRILLDOWNFILTERSTRATEGY_ALLOW_SUBTABLES_AND_UNRELATED" }
        #ENDIF        
        Property Integer piDrilldownDatabaseFiltering LL_DRILLDOWNFILTERSTRATEGY_ALLOW_SUBTABLES_AND_UNRELATED
        // pbDrilldownQueryDatabases: With this Property you control if List & Label will ask you to Display or Hide tables in Drilldown Reports
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF        
        Property Integer pbDrilldownQueryDatabases False
        // pbDrilldownBasetableAsVariables: With this Property you control, if List & Label presents the Parent Database as Variables, not as Fields in a Drilldown Report
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF        
        Property Integer pbDrilldownBasetableAsVariable True        
        // psDrilldownBaseTable: Holds the BaseTable during a Drilldown-Report
        #IF (!@ >= 120)
        { PropertyType=String }
        #ENDIF
        Property String  psDrilldownBaseTable 
        // psDrilldownSubreportTable: Holds the Subreport Table during a Drilldown-Report
        #IF (!@ >= 120)
        { PropertyType=String }
        #ENDIF        
        Property String  psDrilldownSubreportTable
        // psDrilldownRelationId: Holds the current Relationid during a Drilldown-Report
        #IF (!@ >= 120)
        { PropertyType=String }
        #ENDIF        
        Property String  psDrilldownRelationId
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        { DesignTime=False }
        { Visibility=Private }
        #ENDIF        
        Property Integer piDrilldownId 0
        // Helper Properties for the printing logic
        #IF (!@ >= 120)
        { DesignTime=False }
        #ENDIF        
        Property Integer piJobNumber    0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Handle  phWnd          0
        Property String  psEvalValue    ""
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer pbDontCleanupOnJobClose False        
        #IF (!@ >= 120)
        { DesignTime=False }
        #ENDIF        
        Property Integer piProjectType  0
        #IF (!@ >= 120)
        { DesignTime=False }
        #ENDIF        
        Property String  psCurrentProjectFile ""
        #IF (!@ >= 120)
        { DesignTime=False }
        #ENDIF                        
        Property Integer piIsLayouting  False
        #IF (!@ >= 120)
        { DesignTime=False }
        #ENDIF        
        Property String  psTempPath     ""
        #IF (!@ >= 120)
        { DesignTime=False }
        #ENDIF        
        Property Integer piFirstPrint   FALSE
        Property String  psDefaultLayoutDirectory    ""
        Property String  psDefaultLayoutFile         ""
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Handle phRtfObjectHandle           0
        #IF (!@ >= 120)
        { EnumList="LL_DATE, LL_DATE_DELPHI_1, LL_DATE_DELPHI, LL_DATE_MS, LL_DATE_OLE, LL_DATE_VFOXPRO, LL_DATE_DMY, LL_DATE_MDY" }
        { EnumList+="LL_DATE_YMD, LL_DATE_YYYYMMDD, LL_DATE_LOCALIZED, LL_DATE_JULIAN, LL_DATE_CLARION, LL_DATE_YMD_AUTO" }
        #ENDIF
        Property Integer piDateFormat   LL_DATE_DMY
        Get_Attribute DF_DATE_FORMAT to iDateFormat
        If (iDateFormat=DF_DATE_USA) Begin
            Set piDateFormat to LL_DATE_MDY
        End
        If (iDateFormat=DF_DATE_MILITARY) Begin
            Set piDateFormat to LL_DATE_YMD
        End
        #IF (!@ >= 120)
        { DesignTime=False }
        #ENDIF        
        Property String  psUsedIdentifiers ""
        #IF (!@ >= 120)
        { DesignTime=False }
        #ENDIF
        Property String  psCurrentTable ""
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property String  psPreviewOriginalLabel      ""
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer phoDisabledWindows 0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer phoEnabledForModal 0        
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer phoDisabledMenus 0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer phoFocusBeforePrint 0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer piOriginalKeyPath -1
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        #IFDEF U_cCJCommandBarSystem
        Property Handle[] phoDisabledCodejockActions
        #ENDIF
        Property Integer pbDesignerPreviewRunning
        Property Integer pbDesignerPreviewRunningOverride
        Property Integer pbDesignerPreviewAbortRequested
        Property String  psDesignerPreviewProjectName
        Property String  psDesignerPreviewOriginalProjectName
        Property Integer piDesignerPreviewPagesRequested
        Property Handle  phDesignerPreviewhWnd
        Property Handle  phDesignerPreviewhEvent
        Property Integer piDesignerPreviewStartMessage
        // pbUseExpandableRegions: Set to true if you want to use expandable Regions
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                        
        Property Integer pbUseExpandableRegions False
        // pbUseReportParameter: Set to true if you want to use Report Parameter Printing
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                        
        Property Integer pbUseReportParameter False        
        // pbUseInteractiveSorting: Set to true if you want to use interactive Sorting
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                        
        Property Integer pbUseInteractiveSorting False        
                
        // pbReportIsInteractiveRequest: This Property is true when a Report is running a second Time for either expandable Regions, Report-Parameters or interactive Sorting.
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF                        
        Property Integer pbReportIsInteractiveRequest False        
        
        #IFDEF Is$WebApp
        // psTempExportToRemove: Holds the last exported Web-Report which is deleted on next Report or on exiting the Application
        #IF (!@ >= 120)
        { PropertyType=String }
        #ENDIF                        
        Property String psTempExportToRemove ""
        #ENDIF
        
        // Helper Arrays for the printing logic:
        // Needed for storing the available Fields/Variables and to speed up the report
        // oUsedFields holds the Fields that are really used in the Layout definition
        Object oUsedFields is an Array
        End_Object
        // oUsedVariables holds the Variables that are really used in the Layout definition
        Object oUsedVariables is an Array
        End_Object
        // oAllFields holds the Fields that are available for the Layout definition
        Object oAllFields is an Array
        End_Object
        // oAllVariables holds the Variables that are available for the Layout definition
        Object oAllVariables is an Array
        End_Object
        #IF (!@>109)
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF                
        Property tAliasDb[] paAllAliasFields
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF                
        Property tAliasDb[] paAllAliasVariables
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF                
        Property tAliasDb[] paUsedAliasFields
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF                
        Property tAliasDb[] paUsedAliasVariables
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF                
        Property Handle[] phMemBlocksToFree
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property String[] psDrilldownAdditionalTables
        #ENDIF
        // pbKeepJobOpen: For performance Reasons you can set this to true. Then you have an active Printjob until the object is destroyed
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF        
        Property Integer pbKeepJobOpen False
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer pbDefinesNeeded False
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer pbForceUsedIdentifierIdentification False
        Object oDataObjects is a Array
        End_Object
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Pointer ppVarHelpBuffer 0
        #IF (!@ >= 120)
        { PropertyType=String }
        #ENDIF        
        Property String psPrintLanguage ""
        #IF (!@ >= 120)
        { PropertyType=Boolean }
        #ENDIF        
        Property Integer pbPreviewExitButtonClicked False
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer phoCreatedNotificationWindow 0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property tDbFile[] paFilelistCache
    End_Procedure
    
    Procedure DoDeleteDataObjects
        Integer iCou bCreated
        Handle hoObj
        If (Item_Count(oDataObjects(Self))=0) ;
            Procedure_Return
        For iCou from 0 to (Item_Count(oDataObjects(Self))-1)
            Get Value of oDataObjects iCou to hoObj
            If (hoObj<>0) Begin
                get pbWasCreated of hoObj to bCreated
                If (bCreated) Begin
                    Send Destroy to hoObj
                End
                Set Value of oDataObjects iCou to 0
            End
        Loop
        Send Delete_Data to oDataObjects
    End_Procedure
    
    Procedure Set piEmbeddedPreviewObject Integer iObj
        Integer hoObj
        Set piEmbeddedPreviewObjectInt to iObj
        Get Object_Id of iObj to hoObj
        If (hoObj<>0) Begin
            Set pbIsEmbeddedObject of iObj to True
        End
    End_Procedure
    
    Function piEmbeddedPreviewObject Returns Integer
        Function_Return (piEmbeddedPreviewObjectInt(Self))
    End_Function
    
    // Function to Convert OemToAnsi and append a Character 0
    Function ToAnsiStr String sStr Returns String
        String sVar
        Pointer pVar
        Integer iRet
        Move (sStr + (Character(0))) to sVar
        Move (addressof(sVar)) to pVar
        Move (OemToAnsi(pVar,pVar)) to iRet
        Function_Return sVar
    End_Function
    
    // Helper Procedure for Enabling/Disabling Menu Item's.
    // Should be called in OnLL_CMND_ENABLEMENU.
    // Parameter: hMenu    Handle to a Menu. Is delivered in OnLL_CMND_ENABLEMENU
    //            iItem    Item ID of the Menu Item to enable/disable (look in the file menuid.txt for possible values)
    //            iState   TRUE/FALSE
    Procedure Set LLMenuEnabled Integer hMenu Integer iItem Integer iState
        Integer iRet
        If iState ;
            Move (MF_BYCOMMAND ior MF_ENABLED) to iState
        Else ;
            Move (MF_BYCOMMAND ior MF_GRAYED ior MF_DISABLED) to iState
        Move (EnableMenuItemEf(hMenu,iItem,iState)) to iRet        
    End_Procedure
    
    // Helper Function to delete a List & Label Menu item
    // Should be called in the Notification OnLL_CMND_MODIFYMENU.
    // Parameter: hMenu    handle to a Menu. Is delivered in OnLL_CMND_MODIFYMENU
    //            iItem    Item ID of the Menu Item to delete (look in the file menuid.txt for possible values) 
    Function DeleteLLMenu Integer hMenu Integer iItem Returns Integer
        Integer iRet
        Function_Return (DeleteMenuEf(hMenu,iItem,MF_BYCOMMAND))
    End_Function    
    
    // Helper Function to insert a user defined Menu Item.
    // Should be called in the Notification OnLL_CMND_MODIFYMENU
    // Parameter: hMenu                handle to a Menu. Is delivered in OnLL_CMND_MODIFYMENU
    //            sValue               Text to display in the Menu Item
    //            iInsertBeforeItem    Item ID of the Menu Item where the new Menu Item is inserted (look in the file menuid.txt for possible values)
    //            iMenuID              Item ID of the inserted Menu (should start with 10000)
    //
    // You have to use the OnLL_CMND_SELECTMENU Notification to trap your Menu item and to execute the desired commands.
    Function InsertLLMenu Handle hMenu String sValue Integer iInsertBeforeItem Integer iMenuID Returns Integer
        String sMenuItem sMenuText
        Pointer pMenuItem pMenuText   
        Integer iRet
        scLLMenuItemInfo aMenuItem
        
        Move (ToAnsiStr(self,sValue)) to sMenuText
        Move (AddressOf(sMenuText)) to pMenuText
        
        Move (SizeOfType(scLLMenuItemInfo)) to aMenuItem.cbSize
        Move (16 ior 2) to aMenuItem.fMask
        Move MFT_STRING to aMenuItem.fType
        Move iMenuID to aMenuItem.wId
        Move pMenuText to aMenuItem.dwTypeData
        Move (length(sMenuText)) to aMenuItem.cch
        Move (AddressOf(aMenuItem)) to pMenuItem
        
        Function_Return (InsertMenuItemEf(hMenu,iInsertBeforeItem,FALSE,pMenuItem))    
    End_Function
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF
    #IF (!@>199)
    Function StringFromPointer Longptr pSource Returns String
        WString wVar
        String sRetVal
        Move (PointerToWString(pSource)) to wVar
        Move (CString(wVar)) to sRetVal
        Function_Return sRetVal        
    End_Function
    #ELSE
    Function StringFromPointer Integer pSource Returns String
        String sPos sRetVal
        Pointer pPos
        Integer iRet
        While (pSource)
            Move (Character(0)) to sPos
            Move (AddressOf(sPos)) to pPos
            Move (CopyMemoryE(pPos,pSource,1)) to iRet
            Move (sRetVal + sPos) to sRetVal
            If (sPos=(Character(0))) ;
                Move 0 to pSource
            Else ;
                Increment pSource
        End
        If (sRetVal <> "") Begin
            Move (addressof(sRetVal)) to pPos 
            Move (AnsiToOem(pPos,pPos)) to iRet
        End
        Function_Return (cString(sRetVal))
    End_Function        
    #ENDIF
    #IF (!@<=199)
    External_Function LLMultiByteToWideChar "MultiByteToWideChar" kernel32.dll;
        DWord dwCodePage;
        DWord dwFlags;
        Pointer pMultiByteStr;
        Integer cbMultiByte;
        Pointer pWideStr;
        Integer cchWideChar;
        Returns Integer
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF        
    Function StringFromWidePointer Address aVal Returns String
        Integer iWideSize
        Integer iVoid
        Address pWideBuf
        String  sPos sRetVal
        Integer iRet
        
        While (aVal)
            Move (LLMultiByteToWideChar(3,0,aVal,1,0,0)) to iWideSize
            If (iWideSize<>0) Begin
                Move (Alloc(iWideSize*2)) to pWideBuf
                If (pWideBuf<>0) Begin
                    Move (LLMultiByteToWideChar(3,0,aVal,1,pWideBuf,iWideSize)) to iWideSize
                    Move (Character(0)) to sPos
                    Move (CopyMemoryE(AddressOf(sPos),pWideBuf,2)) to iRet
                    Move (Free(pWideBuf)) to iRet
                    Move (sRetVal+sPos) to sRetVal
                    If (sPos=(Character(0))) ;
                        Move 0 to aVal
                    Else ;
                        Move (aVal+2) to aVal
                End
                Else ;
                    Move 0 to aVal
            End
            Else ;
                Move 0 to aVal
        End
        If (CString(sRetVal)<>"") Begin
            Move (AnsiToOem(AddressOf(sRetVal),AddressOf(sRetVal))) to iRet
        End
        Function_Return (CString(sRetVal))
    End_Function    
    #ENDIF    

    // Notification if the User Clicks on a Previewer button.
    // Return 1 to ignore the User-Click
    // 0 to execute Default Function
    
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure onLL_CMND_VIEWERBTNCLICKED Integer iButton
    End_Procedure

    // Notification for disabling or hiding a Previewer button
    // Return -1 to hide the button, 0 to take the ListLabel Default
    // 1 to enable button and 2 to disable button

    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_CMND_GETVIEWERBUTTONSTATE Integer iButton Integer iState
    End_Procedure

    // Notification if a External$ Call is made from List & Label to VDF
    // List & Label can "ask" VDF for additional function's which are evaluated with this Notification.
    // i.E.: put an 'External$("Testfunction")' in a List & Label Data-Field and you will get the 
    // OnLL_CMND_EVALUATE sent with 'Testfunction' as the parameter. You can then
    // Return 0 if the Eval was successfull and set the psEvalValue Property to the evaluated Value
    // Return 1 if the Eval had an error and set the psEvalValue Property to the error-text
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_CMND_EVALUATE String sEvalValue Integer iEvaluate
    End_Procedure

    // Notification if List & Label encounters an error in the Layout-Definition
    // i.E.: Layout uses a Field that is not defined in the VDF Program
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_NTFY_EXPRERROR String sError
    End_Procedure
    
    // Very special Notification, rarely needed
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_CMND_CHANGE_DCPROPERTIES_CREATE Handle hDc
    End_Procedure
    
    // Notification for each Page printed. This Notification is sent twice a Page.
    // One Time before the Page is drawn (bPreDraw eq TRUE), and one time after 
    // the Page is drawn (bPreDraw eq FALSE).
    // Look at the List & Label Documentation what can be done with the other Parameters
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_CMND_PAGE Integer bPreDraw Handle hPaintDC Handle hRefDC
    End_Procedure

    // Notification if the User selects Help.
    // Return 1 to disable the internal Help-System from List & Label
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_CMND_HELP Integer iWhichHelp Integer iHelpContext
    End_Procedure
    
    // In CMND_MODIFYMENU the Menu's of List & Label Designer could be changed
    // Look at the file menuid.txt in the List & Label Directory for predefined
    // Menu ID's.
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_CMND_MODIFYMENU Handle hMenu
    End_Procedure
    
    // In CMND_ENABLEMENU you can enable/disable Menu's in the Designer
    // Look at the file menuid.txt in the List & Label Directory for predefined
    // Menu ID's.
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_CMND_ENABLEMENU Integer hMenu
    End_Procedure

    // Notification that the user selected a Menu Item. Return 1 if the default
    // Command of List & Label should not be executed or in case of user defined
    // Menu items.    
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_CMND_SELECTMENU Integer iMenuItem
    End_Procedure
    
    // Notification if the current record that was tried to print did not match
    // the Filter's defined in the Print-Project
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure onLL_NTFY_FAILSFILTER
    End_Procedure
        
    #IF (!@>109)
    Function TabSeparatedToStringArray String sTabVals Returns String[]
        String[] sReturn
        String sVal
        Move (sTabVals + (Character(9))) to sTabVals
        While (Pos(Character(9),sTabVals)<>0) 
            Move (Left(sTabVals,(Pos(Character(9),sTabVals)))) to sVal
            Move (Replace(sVal,sTabVals,"")) to sTabVals
            Move (Replace(Character(9),sVal,"")) to sReturn[(SizeOfArray(sReturn))]
        End            
        Function_Return sReturn
    End_Function
    Function StringArrayToTabSeparated String[] sVals Returns String
        String sReturn
        Integer iCou
        For iCou from 0 to (SizeOfArray(sVals)-1)
            Move (sReturn + sVals[iCou]+(Character(9))) to sReturn
        Loop
        Function_Return sReturn
    End_Function
    
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnLL_NTFY_VIEWERDRILLDOWNSTART String sTableId String sKeyField String sKeyValue String sSubreportTableId String sSubreportKeyField String sRelationId String sProjectFileName String sPreviewFileName String sTabText String sTooltipText Handle hWnd Integer hAttachInfo    
    End_Procedure
    Procedure OnLL_NTFY_DRILLDOWN_ADDITIONALTABLES String sMainTableId String sSubreportTableId String sRelationId
    End_Procedure
    Procedure OnLL_NTFY_DRILLDOWN_USE_TABLE String sTableToQuery String sMainTableId String sSubreportTableId String sRelationId
    End_Procedure
    Procedure OnLL_NTFY_DRILLDOWN_USE_TABLEASVARIABLE String sTableToQuery String sMainTableId String sSubreportTableId String sRelationId
    End_Procedure
    Procedure OnLL_NTFY_VIEWERUSERREQUESTSTART String sProjectFileName String sPreviewFileName Handle hWnd Integer hAttachInfo
    End_Procedure
    #ENDIF 
    
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF
    Procedure OnLL_NTFY_PROJECTLOADED
    End_Procedure
    
    #IF (!@>=120)
    { MethodType=Event Visibility=Private }
    #ENDIF
    #IF (!@>109)
    Procedure OnLL_CMND_VARHELPTEXT String sField String ByRef sHelptext
    End_Procedure
    #ENDIF
    
    #IF (USELLVERSION>19)
    // Notification that a Hyperlink was clicked.
    // iAction=HLACTION_Q_RBUTTONALLOWED: Sent when the mouse hovers over a Hyperlink. Return 2 if you want to enable right clicking on the Hyperlink
    // iAction=HLACTION_LCLICKED: Sent when the Hyperlink was left clicked. Return 1 if you processed the Hyperlink yourself and if there is nothing more to do
    // iAction=HLACTION_RCLICKED: Sent when the Hyperlink was right clicked. Return 1 if you processed the Hyperlink yourself and if there is nothing more to do
    #IF (!@>=120)
    { MethodType=Event Visibility=Private }
    #ENDIF
    Procedure OnLL_NTFY_HYPERLINK Integer iAction String sProtocol String sData
    End_Procedure
    #ENDIF    
    
    Procedure LLStartDesignerPreview Integer wParam Integer lParam
    End_Procedure

    // Parses all Notifications and Returns the values
    // Not all Notifications implemented yet
    #IF (!@ >= 120)
    { MethodType=Event Visibility=Private }
    #ENDIF
    #IF (!@>199)    
    Procedure LLNotification Longptr nMessage Longptr lParamEx
    #ELSE
    Procedure LLNotification Integer nMessage Integer lParamEx
    #ENDIF
        String sData sData2 sEvalValue sError sKeyField sKeyValue sPreviewFileName sProjectFileName sRelationId sSubreportKeyField sSubreportTableId sTableId sTabText sTooltipText sAllowedTables sVal sDesignerProject sOriginalDesignerProject sField sExportFormat sProtocol
        Pointer pData pData2 pEvalValue pStructVal pError pMem pBuffer 
        Integer iRet iArg lUserParameter iOffset iEval hDC hRefDC iJobOrg iTablesModified iCou
        #IF (!@>199)
        Longptr lParam lResult 
        WString wVar        
        #ELSE
        Integer lParam lResult 
        #ENDIF
        Boolean bIsDrilldown bIsExpanding
        Handle hMem hMenu
        scLLPrinter aPrinter
        scLLPage aPage
        scLLExtFct aExtFct
        scLLCallback aCallback
        #IF (!@>109)
        scLLDrilldownJob cLLDrilldownJob
        scLLDDFilterInfo cLLDDFilterInfo
        String[] sTables
        Handle[] hMemBlocks
        String[] sAdditionalTables
        scLLDesginerPrintJob cLLDesignerPrintJob
        #ENDIF
        #IF (USELLVERSION>19)
        scLLNtfyHyperlink aHyperlink
        #ENDIF
        Case Begin
            #IF (!@>109)
            Case (nMessage=LL_NTFY_VIEWERDRILLDOWN) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Move (CopyMemoryE(AddressOf(cLLDrilldownJob),lParam,SizeOfType(scLLDrilldownJob))) to iRet
                If (cLLDrilldownJob.nFunction=LL_DRILLDOWN_START) Begin
                    Get StringfromPointer cLLDrilldownJob.pszKeyField to sKeyField
                    Get stringfromPointer cLLDrilldownJob.pszKeyValue to sKeyValue
                    Get StringFromPointer cLLDrilldownJob.pszPreviewFileName to sPreviewFileName
                    Get StringFromPointer cLLDrilldownJob.pszProjectFileName to sProjectFileName
                    Get StringFromPointer cLLDrilldownJob.pszRelationID to sRelationId
                    Get StringFromPointer cLLDrilldownJob.pszSubreportKeyField to sSubReportKeyField
                    Get StringFromPointer cLLDrilldownJob.pszSubreportTableID to sSubreportTableId
                    Get StringFromPointer cLLDrilldownJob.pszTableID to sTableId
                    Get StringFromPointer cLLDrilldownJob.pszTabText to sTabText
                    Get StringFromPointer cLLDrilldownJob.pszTooltipText to sTooltipText
                    #IF (USELLVERSION>19)
                    Get StringFromPointer cLLDrilldownJob.pszExportFormat to sExportFormat
                    #ENDIF
                    
                    If (Trim(sKeyField)="") Begin
                        Get pbReportIsInteractiveRequest to bIsExpanding
                        Set pbReportIsInteractiveRequest to True
                        Get msg_OnLL_NTFY_VIEWERUSERREQUESTSTART sProjectFileName sPreviewFileName cLLDrilldownJob.hWnd cLLDrilldownJob.hAttachInfo to iRet
                        Set pbReportIsInteractiveRequest to bIsExpanding
                        If (iRet<>0) Begin
                            Set piDrilldownId to (piDrilldownId(Self)+1)
                            Move (piDrillDownId(Self)) to aCallback.lResult
                            Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet
                        End
                    End
                    Else Begin
                        Get pbIsDrilldown to bIsDrilldown
                        Set pbIsDrilldown to True
                        Set psDrilldownBaseTable to sTableId
                        Set psDrilldownSubreportTable to sSubreportTableId
                        Set psDrilldownRelationId to sRelationId
                        Get msg_OnLL_NTFY_VIEWERDRILLDOWNSTART sTableId sKeyField sKeyValue sSubreportTableId sSubreportKeyField sRelationId sProjectFileName sPreviewFileName sTabText sTooltipText cLLDrilldownJob.hWnd cLLDrilldownJob.hAttachInfo to iRet
                        Set pbIsDrilldown to bIsDrilldown
                        If (iRet<>0) Begin
                            Set piDrilldownId to (piDrilldownId(Self)+1)
                            Move (piDrillDownId(Self)) to aCallback.lResult
                            Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet
                        End
                    End
                End
                Case Break
            End
            Case (nMessage=LL_QUERY_DRILLDOWN_ADDITIONAL_BASETABLES_FOR_VARIABLES) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter                
                Move (CopyMemoryE(AddressOf(cLLDDFilterInfo),lParam,SizeOfType(scLLDDFilterInfo))) to iRet
                Get StringFromPointer cLLDDFilterInfo.pszParentTableID to sTableId
                Get StringFromPointer cLLDDFilterInfo.pszSubreportTableID to sSubreportTableId
                Get StringFromPointer cLLDDFilterInfo.pszRelationID to sRelationId
                #IF (!@>199)
                Move (Repeat(character(0),cLLDDFilterInfo.nBufSize*2)) to wVar
                Move (CopyMemoryE(AddressOf(wVar),cLLDDFilterInfo.pszAllowedTables,cLLDDFilterInfo.nBufSize*2)) to iRet
                Move (CString(wVar)) to sAllowedTables
                #ELSE
                Move (LLZeroString(cLLDDFilterInfo.nBufSize)) to sAllowedTables
                Move (CopyMemoryE(AddressOf(sAllowedTables),cLLDDFilterInfo.pszAllowedTables,cLLDDFilterInfo.nBufSize)) to iRet
                Move (sAllowedTables + (character(0))) to sAllowedTables
                Move (AnsiToOem(AddressOf(sAllowedTables),AddressOf(sAllowedTables))) to iRet
                Move (CString(sAllowedTables)) to sAllowedTables
                #ENDIF
                
                Move 0 to iTablesModified
                Get TabSeparatedToStringArray sAllowedTables to sTables
                Move "" to sAllowedTables
                For iCou from 0 to (SizeOfArray(sTables)-1)
                    If ( (Uppercase(Trim(sTables[iCou]))<>(Uppercase(Trim(sTableId)))) and (uppercase(trim(sTables[iCou]))<>(uppercase(trim(sSubreportTableId)))) ) Begin
                        Get msg_OnLL_NTFY_DRILLDOWN_USE_TABLEASVARIABLE sTables[iCou] sTableId sSubreportTableId sRelationId to iRet
                        If (iRet<>0) Begin
                            Move 1 to iTablesModified
                            Move (sAllowedTables + sTables[iCou] + (Character(9))) to sAllowedTables
                        End
                    End
                Loop
                
                If (iTablesModified<>0) Begin
                    Get phMemblocksToFree to hMemBlocks
                    #IF (!@>199)
                    Move sAllowedTables to wVar
                    If (SizeOfWString(wVar)*2>cLLDDFilterInfo.nBufSize) Begin
                        Move (LlGlobalAllocEf(64,(SizeOfWString(wVar)*2) )) to hMem
                        Move (LlGlobalLockEf(hMem)) to pMem
                        Move (CopyMemoryE(pMem,AddressOf(wVar),(SizeOfWString(sAllowedTables)*2) )) to iRet
                        Move (LlGlobalUnlockEf(hMem)) to iRet
                        Move hMem to cLLDDFilterInfo.pszAllowedTables
                        Move hMem to hMemBlocks[(SizeOfArray(hMemBlocks))]
                        Move (SizeOfWString(wVar)*2) to cLLDDFilterInfo.nBufSize                        
                    End
                    Else Begin
                        Move (wVar+(Repeat(Character(0),cLLDDFilterInfo.nBufSize))) to wVar
                        Move (CopyMemoryE(cLLDDFilterInfo.pszAllowedTables,AddressOf(wVar),cLLDDFilterInfo.nBufSize*2)) to iRet
                    End
                    #ELSE
                    Move (ToAnsiStr(Self,sAllowedTables)) to sAllowedTables
                    If (Length(sAllowedTables)>cLLDDFilterInfo.nBufSize) Begin
                        Move (LlGlobalAllocEf(64,(length(sAllowedTables)) )) to hMem
                        Move (LlGlobalLockEf(hMem)) to pMem
                        Move (CopyMemoryE(pMem,AddressOf(sAllowedTables),(length(sAllowedTables)) )) to iRet
                        Move (LlGlobalUnlockEf(hMem)) to iRet
                        Move hMem to cLLDDFilterInfo.pszAllowedTables
                        Move hMem to hMemBlocks[(SizeOfArray(hMemBlocks))]
                        Move (length(sAllowedTables)) to cLLDDFilterInfo.nBufSize                        
                    End
                    Else Begin
                        Move (sAllowedTables + (Repeat(Character(0),cLLDDFilterInfo.nBufSize))) to sAllowedTables
                        Move (CopyMemoryE(cLLDDFilterInfo.pszAllowedTables,AddressOf(sAllowedTables),cLLDDFilterInfo.nBufSize)) to iRet
                    End
                    #ENDIF
                    Move (CopyMemoryE(lParam,AddressOf(cLLDDFilterInfo),SizeOfType(scLLDDFilterInfo))) to iRet
                    Move 1 to aCallback.lResult
                    Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet
                    Set phMemblocksToFree to hMemBlocks
                End
                Case Break                
            End
            Case (nMessage=LL_QUERY_DRILLDOWN_ADDITIONAL_TABLES) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Move (CopyMemoryE(AddressOf(cLLDDFilterInfo),lParam,SizeOfType(scLLDDFilterInfo))) to iRet
                Get StringFromPointer cLLDDFilterInfo.pszParentTableID to sTableId
                Get StringFromPointer cLLDDFilterInfo.pszSubreportTableID to sSubreportTableId
                Get StringFromPointer cLLDDFilterInfo.pszRelationID to sRelationId
                #IF (!@>199)
                Move (Repeat(character(0),cLLDDFilterInfo.nBufSize*2)) to wVar
                Move (CopyMemoryE(AddressOf(wVar),cLLDDFilterInfo.pszAllowedTables,cLLDDFilterInfo.nBufSize*2)) to iRet
                Move (CString(wVar)) to sAllowedTables
                #ELSE
                Move (LLZeroString(cLLDDFilterInfo.nBufSize)) to sAllowedTables
                Move (CopyMemoryE(AddressOf(sAllowedTables),cLLDDFilterInfo.pszAllowedTables,cLLDDFilterInfo.nBufSize)) to iRet
                Move (sAllowedTables + (character(0))) to sAllowedTables
                Move (AnsiToOem(AddressOf(sAllowedTables),AddressOf(sAllowedTables))) to iRet
                Move (CString(sAllowedTables)) to sAllowedTables
                #ENDIF                
                Get piJobNumber to iJobOrg
                Set piJobNumber to cLLDDFilterInfo.hLlJob
                Move (ResizeArray(sAdditionalTables,0)) to sAdditionalTables
                Set psDrilldownAdditionalTables to sAdditionalTables
                Send OnLL_NTFY_DRILLDOWN_ADDITIONALTABLES sTableId sSubreportTableId sRelationId
                Set piJobNumber to iJobOrg
                Get psDrilldownAdditionalTables to sAdditionalTables
                
                Move 0 to iTablesModified
                Get TabSeparatedToStringArray sAllowedTables to sTables
                Move "" to sAllowedTables
                For iCou from 0 to (SizeOfArray(sTables)-1)
                    If ( (Uppercase(Trim(sTables[iCou]))<>(Uppercase(Trim(sTableId)))) and (uppercase(trim(sTables[iCou]))<>(uppercase(trim(sSubreportTableId)))) ) Begin
                        Get msg_OnLL_NTFY_DRILLDOWN_USE_TABLE sTables[iCou] sTableId sSubreportTableId sRelationId to iRet
                        If (iRet<>0) Begin
                            Move 1 to iTablesModified
                            If (iRet=LL_DRILLDOWN_SHOWTABLE) Begin
                                Move (sAllowedTables + sTables[iCou] + (Character(9))) to sAllowedTables
                            End
                        End
                    End
                Loop
                
                For iCou from 0 to (SizeOfArray(sAdditionalTables)-1)
                    Move (sAllowedTables + sAdditionalTables[iCou]+(Character(9))) to sAllowedTables
                    Move 1 to iTablesModified
                Loop
                
                If (iTablesModified<>0) Begin
                    
                    Get phMemblocksToFree to hMemBlocks
                    #IF (!@>199)
                    Move sAllowedTables to wVar
                    If (SizeOfWString(wVar)*2>cLLDDFilterInfo.nBufSize) Begin
                        Move (LlGlobalAllocEf(64,(SizeOfWString(wVar)*2) )) to hMem
                        Move (LlGlobalLockEf(hMem)) to pMem
                        Move (CopyMemoryE(pMem,AddressOf(wVar),(SizeOfWString(sAllowedTables)*2) )) to iRet
                        Move (LlGlobalUnlockEf(hMem)) to iRet
                        Move hMem to cLLDDFilterInfo.pszAllowedTables
                        Move hMem to hMemBlocks[(SizeOfArray(hMemBlocks))]
                        Move (SizeOfWString(wVar)*2) to cLLDDFilterInfo.nBufSize                        
                    End
                    Else Begin
                        Move (wVar+(Repeat(Character(0),cLLDDFilterInfo.nBufSize))) to wVar
                        Move (CopyMemoryE(cLLDDFilterInfo.pszAllowedTables,AddressOf(wVar),cLLDDFilterInfo.nBufSize*2)) to iRet
                    End
                    #ELSE
                    Move (ToAnsiStr(Self,sAllowedTables)) to sAllowedTables
                    If (Length(sAllowedTables)>cLLDDFilterInfo.nBufSize) Begin
                        Move (LlGlobalAllocEf(64,(length(sAllowedTables)) )) to hMem
                        Move (LlGlobalLockEf(hMem)) to pMem
                        Move (CopyMemoryE(pMem,AddressOf(sAllowedTables),(length(sAllowedTables)) )) to iRet
                        Move (LlGlobalUnlockEf(hMem)) to iRet
                        Move hMem to cLLDDFilterInfo.pszAllowedTables
                        Move hMem to hMemBlocks[(SizeOfArray(hMemBlocks))]
                        Move (length(sAllowedTables)) to cLLDDFilterInfo.nBufSize                        
                    End
                    Else Begin
                        Move (sAllowedTables + (Repeat(Character(0),cLLDDFilterInfo.nBufSize))) to sAllowedTables
                        Move (CopyMemoryE(cLLDDFilterInfo.pszAllowedTables,AddressOf(sAllowedTables),cLLDDFilterInfo.nBufSize)) to iRet
                    End
                    #ENDIF
                    Move (CopyMemoryE(lParam,AddressOf(cLLDDFilterInfo),SizeOfType(scLLDDFilterInfo))) to iRet
                    Move 1 to aCallback.lResult
                    Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet
                    Set phMemblocksToFree to hMemBlocks                    
                End
                Case Break
            End
            Case (nMessage=LL_NTFY_DESIGNERPRINTJOB) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Move (CopyMemoryE(AddressOf(cLLDesignerPrintJob),lParam,SizeOfType(scLLDesginerPrintJob))) to iRet
                If ( (cLLDesignerPrintJob.nFunction=LL_DESIGNERPRINTCALLBACK_PREVIEW_START) or (cLLDesignerPrintJob.nFunction=LL_DESIGNERPRINTCALLBACK_EXPORT_START) ) Begin
                    Get StringFromPointer cLLDesignerPrintJob.pszProjectFileName to sDesignerProject
                    Get StringFromPointer cLLDesignerPrintJob.pszOriginalProjectFileName to sOriginalDesignerProject
                    Set psDesignerPreviewProjectName to sDesignerProject
                    Set psDesignerPreviewOriginalProjectName to sOriginalDesignerProject
                    Set piDesignerPreviewPagesRequested to cLLDesignerPrintJob.nPages
                    Set phDesignerPreviewhEvent to cLLDesignerPrintJob.hEvent
                    Set phDesignerPreviewhWnd to cLLDesignerPrintJob.hWnd
                    If (cLLDesignerPrintJob.nFunction=LL_DESIGNERPRINTCALLBACK_PREVIEW_START) Begin
                        Move (LLPostMessageEf(Window_Handle(Self),(WM_USER+532),0,0)) to iRet    
                    End
                    Else Begin
                        Move (LLPostMessageEf(Window_Handle(Self),(WM_USER+532),1,0)) to iRet    
                    End
                    Move LL_DESIGNERPRINTTHREAD_STATE_RUNNING to aCallback.lResult
                End
                If ( (cLLDesignerPrintJob.nFunction=LL_DESIGNERPRINTCALLBACK_PREVIEW_QUEST_JOBSTATE) or (cLLDesignerPrintJob.nFunction=LL_DESIGNERPRINTCALLBACK_EXPORT_QUEST_JOBSTATE) ) Begin
                    If (pbDesignerPreviewRunning(Self)) Begin
                        Move LL_DESIGNERPRINTTHREAD_STATE_RUNNING to aCallback.lResult
                    End
                    Else Begin
                        Move LL_DESIGNERPRINTTHREAD_STATE_STOPPED to aCallback.lResult
                    End
                End
                If ( (cLLDesignerPrintJob.nFunction=LL_DESIGNERPRINTCALLBACK_PREVIEW_ABORT) or (cLLDesignerPrintJob.nFunction=LL_DESIGNERPRINTCALLBACK_EXPORT_ABORT) ) Begin
                    Set pbDesignerPreviewAbortRequested to True
                    Move LL_DESIGNERPRINTTHREAD_STATE_RUNNING to aCallback.lResult
                End
                If ( (cLLDesignerPrintJob.nFunction=LL_DESIGNERPRINTCALLBACK_PREVIEW_FINALIZE) or (cLLDesignerPrintJob.nFunction=LL_DESIGNERPRINTCALLBACK_EXPORT_FINALIZE) ) Begin
                    Move LL_DESIGNERPRINTTHREAD_STATE_RUNNING to aCallback.lResult
                End
                Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet                
                Case Break
            End
            #ENDIF
            Case (nMessage=LL_NTFY_FAILSFILTER) Begin
                Send OnLL_NTFY_FAILSFILTER
                Case break
            End
            Case (nMessage=LL_CMND_SELECTMENU) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Get msg_OnLL_CMND_SELECTMENU (abs(lParam)) to iRet
                If iRet Begin
                    Move 1 to aCallback.lResult
                    Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet
                End       
                Case break
            End             
            Case (nMessage=LL_CMND_ENABLEMENU) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Get msg_OnLL_CMND_ENABLEMENU lParam to iRet
                Case break
            End           
            Case (nMessage=LL_CMND_MODIFYMENU) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Move lParam to hMenu
                Get msg_OnLL_CMND_MODIFYMENU hMenu to iRet
                Case break
            End
            Case (nMessage=LL_CMND_HELP) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Get msg_OnLL_CMND_HELP (hi(lParam)) (low(lParam)) to iRet
                If iRet Begin
                    Move 1 to aCallback.lResult
                    Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet                    
                End
                Case break
            End
            Case (nMessage=LL_CMND_PAGE) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Move (CopyMemoryE(AddressOf(aPage),lParam,SizeOfType(scLLPage))) to iRet
                
                Move aPage.hPaintDC to hDC
                Move aPage.hRefDC to hRefDC
                Move aPage.bPreDraw to iArg
                Get msg_OnLL_CMND_PAGE iArg hDc hRefDC to iRet
                Case Break
            End
            Case (nMessage=LL_CMND_CHANGE_DCPROPERTIES_CREATE) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Move (CopyMemoryE(AddressOf(aPrinter),lParam,SizeOfType(scLLPrinter))) to iRet
                Move aPrinter.hDC to hDC
                Get msg_OnLL_CMND_CHANGE_DCPROPERTIES_CREATE hDC to iRet
                If (iRet=1) Begin
                    Move 1 to aCallback.lResult
                    Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet                    
                End       
                Case break
            End
            Case (nMessage=LL_NTFY_VIEWERBTNCLICKED) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Get msg_OnLL_CMND_VIEWERBTNCLICKED lParam to iRet
                If (iRet=1) Begin
                    Move 1 to aCallback.lResult
                    Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet                    
                End
                Else Begin
                    If (lParam=114) Begin
                        Set pbPreviewExitButtonClicked to True
                    End
                End
                Case break
            End
            Case (nMessage=LL_CMND_GETVIEWERBUTTONSTATE) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Get msg_OnLL_CMND_GETVIEWERBUTTONSTATE (hi(lParam)) (low(lParam)) to iRet
                If ( (iRet=-1) or (iRet=1) or (iRet=2) ) Begin
                    Move iRet to aCallback.lResult
                    Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet                    
                End       
                Case break
            End
            Case (nMessage=LL_CMND_EVALUATE) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                #IF (!@<201)
                get_argument_size to iArg
                Set_Argument_Size 32000
                #ENDIF

                Move (CopyMemoryE(AddressOf(aExtFct),lParam,SizeOfType(scLLExtFct))) to iRet
                Get StringFromPointer aExtFct.pSzContent to sEvalValue
                Move aExtFct.bEvaluate to iEval
                
                Set psEvalValue to ""

                Get msg_OnLL_CMND_Evaluate sEvalValue iEval to iRet
                If (iRet=0) Begin
                    Move (psEvalValue(Self)) to sEvalValue
                    #IF (!@>199)
                    If (Length(sEvalValue)>16384);
                        Move (Left(sEvalValue,16384)) to sEvalValue
                    Move (sEvalValue+(Character(0))) to wVar
                    Move (CopyMemory(AddressOf(aExtFct.szNewValue),AddressOf(wVar),(SizeOfWString(wVar)*2))) to iRet
                    #ELSE
                    Move (ToAnsiStr(Self,sEvalValue)) to sEvalValue
                    If (Length(sEvalValue)>16384) ;
                        Move (Left(sEvalValue,16384)) to sEvalValue
                    Move (sEvalValue+(Character(0))) to sEvalValue
                    Move (CopyMemoryE(AddressOf(aExtFct.szNewValue),AddressOf(sEvalValue),(Length(sEvalValue)))) to iRet
                    #ENDIF
                    Move (CopyMemoryE(lParam,AddressOf(aExtFct),SizeOfType(scLLExtFct))) to iRet
                End
                Else Begin
                    Move (psEvalValue(Self)) to sEvalValue
                    If (length(sEvalValue)>127) ;
                        Move (Left(sEvalValue,127)) to sEvalValue
                    #IF (!@>199)
                    Move (sEvalValue+(Character(0))) to wVar
                    Move (CopyMemory(AddressOf(aExtFct.szError),AddressOf(wVar),(SizeOfWString(wVar)*2))) to iRet                    
                    #ELSE
                    Move (ToAnsiStr(Self,sEvalValue)) to sEvalValue
                    Move (sEvalValue+(Character(0))) to sEvalValue
                    Move (CopyMemoryE(AddressOf(aExtFct.szError),AddressOf(sEvalValue),(Length(sEvalValue)))) to iRet
                    #ENDIF
                    Move 1 to aExtFct.bError
                    Move (CopyMemoryE(lParam,AddressOf(aExtFct),SizeOfType(scLLExtFct))) to iRet
                End
                #IF (!@<201)
                Set_Argument_Size iArg
                #ENDIF
                Case break
            End
            Case (nMessage=LL_NTFY_EXPRERROR) Begin
                If (piIsLayouting(Self)) ;
                    Procedure_Return
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Get StringFromPointer lParam to sError
                #IF (!@<=199)
                Move (sError + (Character(0))) to sError
                Move (AddressOf(sError)) to pError
                Move (AnsiToOem(pError,pError)) to iRet
                Move (CString(sError)) to sError
                #ENDIF
                Send OnLL_NTFY_EXPRERROR sError
                Case break
            End
            Case (nMessage=LL_NTFY_PROJECTLOADED) Begin
                Send OnLL_NTFY_PROJECTLOADED 
                Case Break
            End
            #IF (!@>109)
            Case (nMessage=LL_CMND_VARHELPTEXT) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move aCallback.lParam to lParam
                Move aCallback.lResult to lResult
                Move aCallback.lUserParameter to lUserParameter
                Get StringFromPointer lParam to sField
                If (ppVarhelpBuffer(Self)=0) Begin
                    Move (Alloc(2048)) to pBuffer
                    Set ppVarHelpBuffer to pBuffer
                End
                Move "" to sVal
                Send OnLL_CMND_VARHELPTEXT sField (&sVal)
                #IF (!@>199)
                If (Length(sVal)>1023) Begin
                    Move (Left(sVal,1023)) to sVal
                End                
                Move (sVal+(Character(0))) to wVar
                Move (CopyMemory(ppVarHelpBuffer(Self),AddressOf(wVar),(SizeOfWString(wVar)*2))) to iRet
                #ELSE
                If (Length(sVal)>2047) Begin
                    Move (Left(sVal,2047)) to sVal
                End
                Move (sVal+ (Character(0))) to sVal
                Move (OemToAnsi(addressof(sVal),AddressOf(sVal))) to iRet
                Move (CopyMemory(ppVarHelpBuffer(Self),AddressOf(sVal),(Length(sVal)))) to iRet
                #ENDIF
                
                Move (ppVarHelpBuffer(Self)) to aCallback.lResult
                Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet                
                
                Case Break
            End
            #ENDIF
            #IF (USELLVERSION>19)
            Case (nMessage=LL_NTFY_HYPERLINK) Begin
                Move (CopyMemoryE(AddressOf(aCallback),lParamEx,SizeOfType(scLLCallback))) to iRet
                Move (CopyMemoryE(AddressOf(aHyperlink),aCallback.lParam,SizeOfType(scLLNtfyHyperlink))) to iRet
                #IF (!@>199)
                Move (StringFromPointer(Self,aHyperlink.pwszData)) to sData
                Move (stringFromPointer(Self,aHyperlink.pwszProtocol)) to sProtocol
                #ELSE
                Move (StringFromWidePointer(Self,aHyperlink.pwszData)) to sData
                Move (StringFromWidePointer(Self,aHyperlink.pwszProtocol)) to sProtocol                
                #ENDIF
                If (aHyperlink.nAction<>0) Begin
                    Get msg_OnLL_NTFY_HYPERLINK aHyperlink.nAction sProtocol sData to iRet
                    If (iRet<>0) Begin
                        Move iRet to aCallback.lResult
                        Move (CopyMemoryE(lParamEx,AddressOf(aCallback),SizeOfType(scLLCallback))) to iRet
                    End
                End
                Case Break
            End
            #ENDIF
        Case End
    End_Procedure
    
    // Wrapper Functions for DLL-Calls. Defined the same way as described in List & Label Programmers Reference
    // except for the List & Label Job handle which is always automatically supplied    

    Function LLSetFileExtensions Integer iType String sDefinitionFile String sPrinterfile String sSketchfile Returns Integer
        String sExt1 sExt2 sExt3
        Pointer pExt1 pExt2 pExt3
        
        #IF (!@>199)
        Function_Return (LlSetFileExtensionsEf((piJobNumber(Self)),iType,sDefinitionFile,sPrinterfile,sSketchfile))
        #ELSE

        Move (ToAnsiStr(self,sDefinitionFile)) to sExt1
        Move (AddressOf(sExt1)) to pExt1
        Move (ToAnsiStr(self,sPrinterFile)) to sExt2
        move (AddressOf(sExt2)) to pExt2
        Move (ToAnsiStr(self,sSketchFile)) to sExt3
        Move (AddressOf(sExt3)) to pExt3

        Function_Return (LlSetFileExtensionsEf((piJobNumber(Self)),iType,pExt1,pExt2,pExt3))
        #ENDIF
    End_Function

    Function LLSetPrinterDefaultsDir String sDir Returns Integer
        String sVar
        Pointer pVar
        Integer iRet
        #IF (!@>199)
        Function_Return (LlSetPrinterDefaultsDirEf((piJobNumber(Self)),sDir))
        #ELSE
        Move (ToAnsiStr(self,sDir)) to sVar
        Move (AddressOf(sVar)) to pVar
        Function_Return (LlSetPrinterDefaultsDirEf((piJobNumber(Self)),pVar))
        #ENDIF
    End_Function
    
    // Two Notifications called before and after the JobOpen

    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF
    Procedure OnJobBeforeOpen
    End_Procedure

    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF
    Procedure OnJobAfterOpen
    End_Procedure

    Function LLPreviewSetTempPath String sPath Returns Integer
        String sVar1
        Pointer pVar1
        If (Right(sPath,1)<>"\") ;
            Move (sPath + "\") to sPath
        Set psTempPath to sPath
        #IF (!@>199)
        Function_Return (LLPreviewSetTempPathEf(piJobNumber(Self),sPath))
        #ELSE
        Move (ToAnsiStr(self,sPath)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LLPreviewSetTempPathEf(piJobNumber(Self),pVar1))
        #ENDIF
    End_Function

    Function LLJobOpen Returns Integer
        Integer iJob iRet iFehler iFilter iDebug hoFocus hoNotification
        Handle hWnd
        String sExt1 sExt2 sExt3 sTempDir sStr sDll
        Pointer pExt1 pExt2 pExt3
        
        Set pbPreviewExitButtonClicked to False
        
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(Self))) ) Begin
            Function_Return (piJobNumber(Self))
        End
        
        Set pbDesignerPreviewAbortRequested to False
        
        Send DoFillFilelistCache

        Send OnJobBeforeOpen
        
        If ( (not(pbIsDrilldown(Self))) and (not(pbDesignerPreviewRunning(Self))) and (not(pbReportIsInteractiveRequest(Self))) ) Begin
            If (trim(psLicensingInfo(Self))="") Begin
                Move "Your Personal License Key is not set." to sStr
                Move (sStr + " If you don't set the property psLicensingInfo correctly List & Label will only work on your Development Machine.") to sStr
                Move (sStr + "\n\nYou find your License Key in the file 'perslic.txt' (usually \Program Files\combit\LLxx\perslic.txt).") to sStr
                #IFDEF Is$WebApp
                Error 999 sStr
                #ELSE
                Send info_box sStr "Warning"
                #ENDIF
            End
            Set piDrilldownId to 0
        End
        If ( (pbUseDrilldown(Self)) or (pbUseExpandableRegions(Self)) or (pbUseInteractiveSorting(Self)) or (pbUseReportParameter(Self)) ) Begin
            If ( (piEmbeddedPreviewObjectInt(Self)<>0) and (not(pbIsDrilldown(Self))) and (not(pbReportIsInteractiveRequest(Self))) ) Begin
                Set pbKeepJobOpen to True 
            End
        End
        Move (LLSetDebugEf((piDebugMode(Self)))) to iRet
        Move (LsSetDebugEf(If((piDebugMode(Self)<>0),True,False))) to iRet        
        
        If ( (not(pbKeepJobOpen(Self))) or (pbIsDrilldown(Self)) or (pbReportIsInteractiveRequest(Self)) ) Begin
            Set piJobNumber to 0
            Move (LLSetOptionEf(-1,LL_OPTION_MAXRTFVERSION,(piMaxRtfVersion(Self)))) to iRet
        End
        
        If ( (not(pbKeepJobOpen(Self))) or (piJobNumber(Self)=0) ) Begin
            Move (LLJobOpenEf(piUseLanguage(Self))) to iJob
            Send DebugVDFReport "Job open:" iJob
        End
        Else Begin
            Move (piJobNumber(Self)) to iJob
            Send DebugVDFReport "Re-Use existing Job:" iJob
        End
        If (iJob=LL_ERR_NO_LANG_DLL) Begin
            #IFNDEF Is$WebApp
            Send stop_box "Wrong Language selected. Set the piUseLanguage Property to the correct Value"
            #ELSE
            Error 999 "Wrong Language selected. Set the piUseLanguage Property to the correct Value"
            #ENDIF
        End
        If (iJob) Begin
            Set piJobNumber to iJob
            Get LLSetOptionString LL_OPTIONSTR_LICENSINGINFO (psLicensingInfo(self)) to iRet
            Move (LLSetOptionEf(iJob,LL_OPTION_UISTYLE,(piUiStyle(Self)))) to iRet
            Get LLSetDlgBoxMode (piDlgBoxMode(Self)) to iRet
            
            Move (Window_Handle(Self)) to hWnd
            If (hWnd=0) Begin
                Get Focus to hoFocus
                Get Find_Scope of hoFocus to hoFocus
                If (hoFocus<>0) Begin
                    
                    #IFNDEF Is$WebApp
                    Get Create of hoFocus U_cListLabelNotificationWindow to hoNotification
                    #ELSE
                    Get Create of hoFocus U_cListLabelWebNotificationWindow to hoNotification
                    #ENDIF
                    Send Page_Object to hoNotification True
                    Set piNotificationTarget of hoNotification to (Self)
                    Move (Window_Handle(hoNotification)) to hWnd
                    Set phoCreatedNotificationWindow to hoNotification
                End
            End
            
            Move (LLSetOptionEf(iJob,LL_OPTION_NOTIFICATIONMESSAGEHWND,hWnd)) to iRet
            Move (LLSetNotificationMessageEf(iJob,(WM_USER+530))) to iRet
            
            Move (llSetOptionEf(iJob,LL_OPTION_NOPARAMETERCHECK,(piNoParameterCheck(self)))) to iRet
            Move (LLSetOptionEf(iJob,LL_OPTION_XLATVARNAMES,(pixLatVarnames(self)))) to iRet
            Move (LLSetOptionEf(iJob,LL_OPTION_CONVERTCRLF,(piConvertCrLf(self)))) to iRet
            Move (LLSetOptionEf(iJob,LL_OPTION_CALLBACKMASK,(LL_CB_PAGE Ior LL_CB_HELP))) to iRet
            Move (LLSetOptionEf(iJob,LL_OPTION_INCREMENTAL_PREVIEW,(pbIncrementalPreview(Self)))) to iRet
            #IF (!@>109)
            If (pbUseDrilldown(Self)) Begin
                Move (LlSetOptionEf(iJob,LL_OPTION_DRILLDOWNPARAMETER,1)) to iRet
                Move (piDrilldownDatabaseFiltering(Self)) to iFilter
                If (pbDrilldownQueryDatabases(Self)) ;
                    Move LL_DRILLDOWNFILTERSTRATEGY_ALLOW_SUBTABLES_AND_USERDEFINED to iFilter
                If (pbDrilldownBasetableAsVariable(Self)) ;
                    Move (iFilter ior LL_DRILLDOWNFILTERFLAG_OFFER_BASERECORD_AS_VARIABLES) to iFilter
                Move (LlSetOptionEf(iJob,LL_OPTION_DRILLDOWN_DATABASEFILTERING,iFilter)) to iRet
            End
            Else Begin
                Move (LlSetOptionEf(iJob,LL_OPTION_DRILLDOWNPARAMETER,0)) to iRet
            End
            #ELSE
            Set pbUseDrilldown to False
            Move (LlSetOptionEf(iJob,LL_OPTION_DRILLDOWNPARAMETER,0)) to iRet
            #ENDIF
            Get TempDirectory to sTempDir
            Move (LLPreviewSetTempPath(Self,sTempDir)) to iRet
            
            If (psPrintLanguage(Self)<>"") Begin
                Get LlSetDefaultProjectParameter "LL.PrintJobLCID" ('"'+(psPrintLanguage(Self))+'"') (LL_PARAMETERTYPE_LLINTERNAL ior LL_PARAMETERFLAG_GLOBAL ior LL_PARAMETERFLAG_FORMULA ior LL_PARAMETERFLAG_PUBLIC) to iRet
            End
            #IF (USELLVERSION>18)
            If (pbUseExpandableRegions(Self)) Begin
                Move (LlSetOptionEf(iJob,LL_OPTION_EXPANDABLE_REGIONS_REALDATAJOBPARAMETER,1)) to iRet
            End
            If (pbUseReportParameter(Self)) Begin
                Move (LlSetOptionEf(iJob,LL_OPTION_REPORT_PARAMETERS_REALDATAJOBPARAMETER,1)) to iRet
            End
            If (pbUseInteractiveSorting(Self)) Begin
                Move (LlSetOptionEf(iJob,LL_OPTION_INTERACTIVESORTING_REALDATAJOBPARAMETER,1)) to iRet
            End
            #ENDIF
            Send OnJobAfterOpen
        End
        Function_Return iJob
    End_Function

    Function LLSetDlgboxMode Integer iMode Returns Integer
        Function_Return (LlSetDlgboxModeEf(iMode))
    End_Function

    Function LLSetOption Integer iOption Integer iState Returns Integer
        Function_Return (LLSetOptionEf(piJobNumber(self),iOption,iState))
    End_Function

    Function LLSetOptionString Integer iOption String sOptionVal Returns Integer
        String sVal
        Pointer pVal
        #IF (!@>199)
        Function_Return (LLSetOptionStringEf(piJobNumber(Self),iOption,sOptionVal))        
        #ELSE
        Move (ToAnsiStr(self,sOptionVal)) to sVal
        Move (AddressOf(sVal)) to pVal
        Function_Return (LLSetOptionStringEf(piJobNumber(Self),iOption,pVal))
        #ENDIF
    End_Function

    Function LLGetOptionString Integer iOption Returns String
        String sVal
        Pointer pVal
        Integer iRet iSize
        
        #IF (!@>199)
        WString wVar
        Move 1024 to iSize
        Move (Repeat(Character(0),iSize)) to wVar
        Move (LLGetOptionStringEf(piJobNumber(Self),iOption,AddressOf(wVar),(iSize*2))) to iRet
        While (iRet=LL_ERR_BUFFERTOOSMALL)
            Move (iSize +1024) to iSize
            Move (Repeat(Character(0),iSize)) to wVar
            Move (LLGetOptionStringEf(piJobNumber(Self),iOption,AddressOf(wVar),(iSize*2))) to iRet
        End
        If (iRet=0) Begin
            Move (CString(wVar)) to sVal
            Function_Return sVal
        End        
        #ELSE
        Move 1024 to iSize
        Move (Repeat(Character(0),iSize)) to sVal
        Move (AddressOf(sVal)) to pVal
        Move (LLGetOptionStringEf(piJobNumber(self),iOption,pVal,iSize)) to iRet
        While (iRet=LL_ERR_BUFFERTOOSMALL)
            Move (iSize +1024) to iSize
            Move (Repeat(Character(0),iSize)) to sVal
            Move (AddressOf(sVal)) to pVal
            Move (LLGetOptionStringEf(piJobNumber(self),iOption,pVal,iSize)) to iRet
        End
        If (iRet=0) Begin
            Move (OemToAnsi(pVal,pVal)) to iRet
            Function_Return (cString(sVal))
        End
        #ENDIF
        Function_Return ""
    End_Function

    Function LLPrintGetOptionString Integer iOption Returns String
        String sVal
        Pointer pVal
        Integer iRet iSize
        #IF (!@>199)
        WString wVar
        Move 1024 to iSize
        Move (Repeat(Character(0),iSize)) to wVar
        Move (LlPrintGetOptionStringEf(piJobNumber(Self),iOption,AddressOf(wVar),(iSize*2))) to iRet
        While (iRet=LL_ERR_BUFFERTOOSMALL)
            Move (iSize +1024) to iSize
            Move (Repeat(Character(0),iSize)) to wVar
            Move (LlPrintGetOptionStringEf(piJobNumber(Self),iOption,AddressOf(wVar),(iSize*2))) to iRet
        End
        If (iRet=0) Begin
            Move (CString(wVar)) to sVal
            Function_Return sVal
        End        
        #ELSE
        Move 1024 to iSize
        Move (Repeat(Character(0),iSize)) to sVal
        Move (AddressOf(sVal)) to pVal
        Move (LLPrintGetOptionStringEf(piJobNumber(self),iOption,pVal,iSize)) to iRet
        While (iRet=LL_ERR_BUFFERTOOSMALL)
            Move (iSize +1024) to iSize
            Move (Repeat(Character(0),iSize)) to sVal
            Move (AddressOf(sVal)) to pVal
            Move (LLPrintGetOptionStringEf(piJobNumber(self),iOption,pVal,iSize)) to iRet
        End
        If (iRet=0) Begin
            Move (OemToAnsi(pVal,pVal)) to iRet
            Function_Return (cString(sVal))
        End
        #ENDIF
        Function_Return ""
    End_Function

    Function LLPrintGetOption Integer iOption Returns Integer
        Function_Return (LLPrintGetOptionEf(piJobNumber(self), iOption))
    End_Function

    Function LLPrintSetOptionString Integer iOption String sOptionVal Returns Integer
        String sVal
        Pointer pVal
        #IF (!@>199)
        Function_Return (LLPrintSetOptionStringEf(piJobNumber(Self),iOption,sOptionVal))
        #ELSE
        Move (ToAnsiStr(self,sOptionVal)) to sVal
        Move (AddressOf(sVal)) to pVal
        Function_Return (LLPrintSetOptionStringEf(piJobNumber(Self),iOption,pVal))
        #ENDIF
    End_Function

    Function LLPrintSetOption Integer iOption Integer iState Returns Integer
        Function_Return (LLPrintSetOptionEf(piJobNumber(self),iOption,iState))
    End_Function
    
    Function LLPrintGetRemainingSpacePerTable String sField Integer iDimension Returns Integer
        #IF (!@>199)
        Function_Return (LLPrintGetRemainingSpacePerTableEf(piJobNumber(Self),sField,iDimension))
        #ELSE
        String sVal
        Pointer pVal
        
        If (trim(sField)="") Begin
            Move 0 to pVal
        End    
        Else Begin
            Move (ToAnsiStr(self,sField)) to sVal
            Move (AddressOf(sVal)) to pVal
        End
        Function_Return (LLPrintGetRemainingSpacePerTableEf(piJobNumber(Self),pVal,iDimension))
        #ENDIF
    End_Function    
    
    // Notification called before the Job is closed
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF
    Procedure OnJobClose
    End_Procedure

    Function LLJobClose Returns Integer
        Integer iJob iRet iPreviewObj iPreviewPanel iPreviewRunning
        String sStr
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(Self))) ) Begin
            Function_Return 0
        End
        Send OnJobClose
        Move (llsetNotificationCallbackEf(piJobNumber(Self),0)) to iRet
        If (phoCreatedNotificationWindow(Self)<>0) Begin
            Send Destroy to (phoCreatedNotificationWindow(Self))
            Set phoCreatedNotificationWindow to 0
        End        
        
        If (not(pbDontCleanupOnJobClose(Self))) Begin
            #IFNDEF Is$WebApp        
            If (piEmbeddedPreviewObjectInt(Self)<>0) Begin
                Get object_id of (piEmbeddedPreviewObjectInt(Self)) to iPreviewObj
                If (pbIncrementalPreview(Self)) Begin
                    Get Find_Scope of (piEmbeddedPreviewObjectInt(Self)) to iPreviewPanel
                End
            End
            If ( (piPreviewPanel(Self)<>0) and (piPreviewObject(Self)<>0) ) Begin
                If (pbIncrementalPreview(Self)) Begin
                    Get object_id of (piPreviewObject(Self)) to iPreviewObj
                    Get object_id of (piPreviewPanel(Self)) to iPreviewPanel
                End
            End
            
            If (psPreviewOriginalLabel(Self)<>"") Begin
                If (iPreviewPanel<>0) Begin
                    Set label of iPreviewPanel to (psPreviewOriginalLabel(Self))
                End
                Set psPreviewOriginalLabel to ""
            End
            If (iPreviewObj<>0) Begin
                Get pbPreviewRunning of iPreviewObj to iPreviewRunning
                If (iPreviewRunning) Begin
                    Move (SendMessage(window_handle(iPreviewObj),LS_VIEWERCONTROL_SET_PROGRESSINFO,-1,0)) to iRet
                    Set pbPreviewRunning of iPreviewObj to False
                    Send OnIncrementalPreviewEnd to iPreviewObj (Self)            
                End
                If ( (current_modal_object<>0) and (not(visible_state(current_modal_object))) ) Begin
                    Set visible_state of (current_modal_object) to True
                End                
                Set piAssociatedLLObj of iPreviewObj to 0
                Send DoDisableOtherWindows False
                If (phoFocusBeforePrint(Self)<>0) Begin
                    Send activate to (phoFocusBeforePrint(Self))
                    Set phoFocusBeforePrint to 0
                End                
                If (piOriginalKeyPath(Self)<>-1) Begin
                    If (iPreviewPanel<>0) Begin
                        Set key_path of iPreviewPanel to (piOriginalKeyPath(Self))
                    End
                    Set piOriginalKeyPath to -1
                End
            End
            #ENDIF
        End
        
        If (not(pbKeepJobOpen(Self))) Begin
            Move (LLJobCloseEf(piJobNumber(Self))) to iJob
            Send DebugVDFReport "Job closed:" (piJobNumber(Self))
            Set piJobNumber to 0
        End
        Else Begin
            Send DebugVDFReport "Job kept open:" (piJobNumber(Self))
        End
        
        #IF (!@>109)
        Handle[] hMemBlocks
        Integer iCou
        If ( (not(pbIsDrilldown(Self))) and (not(pbReportIsInteractiveRequest(Self))) ) Begin
            Get phMemBlocksToFree to hMemBlocks
            For iCou from 0 to (SizeOfArray(hMemBlocks)-1)
                Move (LlGlobalFreeEf(hMemBlocks[iCou])) to iRet
            Loop
            Move (ResizeArray(hMemBlocks,0)) to hMemBlocks
            Set phMemBlocksToFree to hMemBlocks
        End
        #ENDIF
        
        Function_Return iJob
    End_Function
    
    Procedure DebugVDFReport 
        Integer iCou iRet iIsReturn
        String sMessage sPart
        Pointer pMessage
        If (piDebugMode(Self)=0) ;
            Procedure_Return
        For iCou from 1 to NUM_ARGUMENTS
            Move iCou& to sPart
            If ( (iCou=1) and (Right(Trim(sPart),1)="=")) ;
                Move 1 to iIsReturn
            Move (sMessage + (trim(sPart)) + " ") to sMessage
            If ( (iCou=2) and (iIsReturn=1) ) Begin
                Move (Integer(sPart)) to iRet
                If (iRet=LL_REPORT_USEDEFAULT) Begin
                    Move (sMessage + " (LL_REPORT_USEDEFAULT)") to sMessage
                End
                If (iRet=LL_REPORT_EOF) Begin
                    Move (sMessage + " (LL_REPORT_EOF)") to sMessage
                End                
                If (iRet=LL_REPORT_SKIPRECORD) Begin
                    Move (sMessage + " (LL_REPORT_SKIPRECORD)") to sMessage
                End
                If (iRet=LL_REPORT_CANCELPRINT) Begin
                    Move (sMessage + " (LL_REPORT_CANCELPRINT)") to sMessage
                End
                If (iRet=LL_REPORT_SKIPTABLE) Begin
                    Move (sMessage + " (LL_REPORT_SKIPTABLE)") to sMessage
                End
                If (iRet=LL_DRILLDOWN_SHOWTABLE) Begin
                    Move (sMessage + " (LL_DRILLDOWN_SHOWTABLE)") to sMessage
                End
                If (iRet=LL_DRILLDOWN_HIDETABLE) Begin
                    Move (sMessage + " (LL_DRILLDOWN_HIDETABLE)") to sMessage
                End                
            End            
        Loop
        
        Move ("VDFREPORT " + (Trim(sMessage)) ) to sMessage
        Move (Replaces(Character(13),sMessage,"\x13")) to sMessage
        Move (Replaces(Character(10),sMessage,"\x10")) to sMessage
        Move (Replaces(Character(9),sMessage,"\x9")) to sMessage
        #IF (!@>199)
        Move (LlDebugOutputEf(0,sMessage)) to iRet
        #ELSE
        Move (sMessage + (Character(0))) to sMessage
        Move (AddressOf(sMessage)) to pMessage
        Move (OemToAnsi(pMessage,pMessage)) to iRet
        Move (LlDebugOutputEf(0,pMessage)) to iRet
        #ENDIF
    End_Procedure    
    
    Procedure Destroy
        Boolean bRet
        Send DoDeleteDataObjects
        If (ppVarHelpBuffer(Self)<>0) Begin
            Move (Free(ppVarhelpBuffer(Self))) to bRet
            Set ppVarHelpBuffer to 0
        End
        Forward Send Destroy
    End_Procedure
    
    Procedure Destroy_Object
        Integer iRet
        If ( (pbKeepJobOpen(Self)) and (piJobNumber(Self)<>0) ) Begin
            Move (llsetNotificationCallbackEf(piJobNumber(Self),0)) to iRet
            Move (LLJobCloseEf(piJobNumber(Self))) to iRet
            Send DebugVDFReport "Job closed: " (piJobNumber(Self))
            Set piJobNumber to 0            
        End
        Forward Send Destroy_Object
    End_Procedure

    Function LLPrintGetPrinterName Returns String
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Integer iRet
        
        #IF (!@>199)
        WString wVar1 wVar2
        Move (Repeat(Character(0),512)) to wVar1
        Move (Repeat(Character(0),512)) to wVar2
        Move (LLPrintGetPrinterInfoEf(piJobNumber(Self),AddressOf(wVar1),1024,AddressOf(wVar2),1024)) to iRet
        If (iRet=0) Begin
            Function_Return (CString(wVar1))
        End
        Else ;
            Function_Return ""            
        #ELSE
        Move (Repeat(Character(0),250)) to sVar1
        Move (Repeat(Character(0),250)) to sVar2
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Move (LLPrintGetPrinterInfoEf(piJobNumber(self),pVar1,250,pVar2,250)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVar1,pVar1)) to iRet
            Function_Return (cString(sVar1))
        End
        Else ;
            Function_Return ""
        #ENDIF
    End_Function

    Function LLPrintGetPrinterPort Returns String
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Integer iRet

        #IF (!@>199)
        WString wVar1 wVar2
        Move (Repeat(Character(0),512)) to wVar1
        Move (Repeat(Character(0),512)) to wVar2
        Move (LLPrintGetPrinterInfoEf(piJobNumber(Self),AddressOf(wVar1),1024,AddressOf(wVar2),1024)) to iRet
        If (iRet=0) Begin
            Function_Return (cString(wVar2))
        End
        Else ;
            Function_Return ""        
        #ELSE
        Move (Repeat(Character(0),250)) to sVar1
        Move (Repeat(Character(0),250)) to sVar2
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Move (LLPrintGetPrinterInfoEf(piJobNumber(self),pVar1,250,pVar2,250)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVar2,pVar2)) to iRet
            Function_Return (cString(sVar2))
        End
        Else ;
            Function_Return ""
        #ENDIF
    End_Function

    Function LLPrintIsFieldUsed String sField Returns Integer
        String sVar1
        Pointer pVar1
        #IF (!@>199)
        Function_Return (LLPrintIsFieldUsedEf(piJobNumber(Self),sField))
        #ELSE
        Move (ToAnsiStr(self,sField)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LLPrintIsFieldUsedEf(piJobNumber(Self),pVar1))
        #ENDIF
    End_Function

    Function LLPrintIsVariableUsed String sField Returns Integer
        String sVar1
        Pointer pVar1
        #IF (!@>199)
        Function_Return (LLPrintIsVariableUsedEf(piJobNumber(Self),sField))
        #ELSE
        Move (ToAnsiStr(self,sField)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LLPrintIsVariableUsedEf(piJobNumber(Self),pVar1))
        #ENDIF
    End_Function

    Function LLDefineFieldStart Returns Integer
        Function_Return (LLDefineFieldStartEf(piJobNumber(self)))
    End_Function

    Function LLDefineVariableStart Returns Integer
        Function_Return (LLDefineVariableStartEf(piJobNumber(self)))
    End_Function

    Function LLDefineFieldExt String sField String sCont Integer iType Returns Integer //mrc
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Move (trim(sCont)) to sCont
        If (sCont="") ;
            Move " " to sCont
        #IF (!@>199)
        WString wVar
        Move (sCont+Character(0)) to wVar
        Function_Return (LLDefineFieldExtEf(piJobNumber(Self),sField,AddressOf(wVar),iType,0))        
        #ELSE
        Move (ToAnsiStr(self,sField)) to sVar1
        Move (ToAnsiStr(self,sCont)) to sVar2
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Function_Return (LLDefineFieldExtEf(piJobNumber(Self),pVar1,pVar2,iType,0))
        #ENDIF
    End_Function

    Function LLDefineVariableExt String sField String sCont Integer iType Returns Integer //mrc
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Move (trim(sCont)) to sCont
        If (sCont="") ;
            Move " " to sCont
        #IF (!@>199)
        WString wVar
        Move (sCont+Character(0)) to wVar
        Function_Return (LLDefineVariableExtEf(piJobNumber(Self),sField,AddressOf(wVar),iType,0))
        #ELSE
        Move (ToAnsiStr(self,sField)) to sVar1
        Move (ToAnsiStr(self,sCont)) to sVar2
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Function_Return (LLDefineVariableExtEf(piJobNumber(Self),pVar1,pVar2,iType,0))
        #ENDIF
    End_Function
    
    Function LLDefineVariableExtHandle String sField Handle hCont Integer iType Returns Integer
        String sVar1 sVar2
        Pointer pVar1 pVar2
        #IF (!@>199)
        Function_Return (LLDefineVariableExtHandleEf(piJobNumber(Self),sField,hCont,iType,0))
        #ELSE
        Move (ToAnsiStr(self,sField)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LLDefineVariableExtHandleEf(piJobNumber(Self),pVar1,hCont,iType,0))
        #ENDIF
    End_Function
    
    Function LLDefineFieldExtHandle String sField Handle hCont Integer iType Returns Integer 
        String sVar1 
        Pointer pVar1
        #IF (!@>199)
        Function_Return (LlDefineFieldExtHandleEf(piJobNumber(Self),sField,hCont,iType,0))
        #ELSE
        Move (ToAnsiStr(Self,sField)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LlDefineFieldExtHandleEf(piJobNumber(Self),pVar1,hCont,iType,0))
        #ENDIF
    End_Function    
    
    Procedure Set LLValue String sField Integer iType String sValue
        Integer iRet
        If (piProjectType(Self)<>LL_PROJECT_LIST) Begin
            Get LLDefineVariableExt sField sValue iType to iRet 
        End
        Else Begin
            Get LLDefineFieldExt sField sValue iType to iRet
        End
    End_Procedure
    
    Procedure DoFillUsedIdentifiers String sFile
        Set psUsedIdentifiers to ""
        #IF (!@>199)
        Integer iArgSize iRet
        WString wVarList
        String sVarList
        Get_Argument_Size to iArgSize
        Move (Repeat(Character(0),iArgSize)) to wVarList
        Move (LLGetUsedIdentifiersEf((piJobNumber(Self)),sFile,AddressOf(wVarList),iArgSize*2)) to iRet
        If (iRet=0) Begin
            Move (CString(wVarList)) to sVarList
            Move (";"+sVarList+";") to sVarList
            Move (uppercase(sVarList)) to sVarList
            Set psUsedIdentifiers to sVarList
        End        
        #ELSE
        String sVar sVarList
        Pointer pVar pVarList
        Integer iRet iArgSize
        Move (ToAnsiStr(self,sFile)) to sVar
        Move (AddressOf(sVar)) to pVar
        get_argument_size to iArgSize
        Move (LLZeroString(iArgSize)) to sVarList
        Move (AddressOf(sVarList)) to pVarList
        Move (LLGetUsedIdentifiersEf((piJobNumber(self)),pVar,pVarList,iArgSize)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVarList,pVarList)) to iRet
            Move (cString(sVarList)) to sVarList
            Move (";"+sVarList+";") to sVarList
            Move (uppercase(sVarList)) to sVarList
            Set psUsedIdentifiers to sVarList
        End
        #ENDIF
    End_Procedure

    Function LLPrintStart Integer iType String sFile Integer iOptions Returns Integer
        String sVar
        Pointer pVar
        Integer iRet
        #IF (!@>109)
        tAliasDb[] sAllFields
        #ENDIF
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(Self))) ) Begin
            Function_Return 0
        End
        Set piProjectType to iType
        If (psCurrentProjectFile(Self)<>sFile) ;
            Set pbDefinesNeeded to True
        If (not(pbDesignerPreviewRunning(Self))) ;
            Set psCurrentProjectFile to sFile
        
        If ( (not(pbKeepJobOpen(Self))) or (pbDefinesNeeded(Self)) ) Begin
            If (piJobNumber(Self)<>0) Begin
                #IF (!@>199)
                Move (LlDbAddTableEf(piJobNumber(Self),"","")) to iRet
                #ELSE
                Move (LlDbAddTableEf(piJobNumber(Self),0,0)) to iRet
                #ENDIF
            End
            Send delete_data to (oAllFields(Self))
            Send delete_data to (oAllVariables(Self))
            #IF (!@>109)
            Set paAllAliasFields to sAllFields
            Set paAllAliasVariables to sAllFields
            #ENDIF        
            Set psUsedIdentifiers to ""
            Set psCurrentTable to ""
            Send DoFillUsedIdentifiers sFile
            Get LLDefineFieldStart to iRet
            Get LLDefineVariableStart to iRet
            Send DefineOneTimeVariables
            Send DefineStandardVariables
            Send DefineAllFields
            Send DefineAllVariables
        End
        Else Begin
            Send DefineStandardVariables
            Send DefineUsedVariables            
        End
        #IF (!@>199)
        Move (LLPrintStartEf((piJobNumber(Self)),iType,sFile,iOptions,0)) to iRet
        #ELSE
        Move (ToAnsiStr(Self,sFile)) to sVar
        Move (AddressOf(sVar)) to pVar
        Move (LlPrintStartEf((piJobNumber(Self)),iType,pVar,iOptions,0)) to iRet
        #ENDIF
        Set piFirstPrint to True
        If ( (not(pbKeepJobOpen(Self))) or (pbDefinesNeeded(Self)) or (pbForceUsedIdentifierIdentification(Self)) ) Begin
            Send SearchUsedFields
            Send SearchUsedVariables
            Set pbForceUsedIdentifierIdentification to False
        End
        Set pbDefinesNeeded to False
        Function_Return iRet
    End_Function
    
    Function LLPrintWithBoxStart Integer iType String sFile Integer iOptions Integer iBoxType Handle hWndParent String sTitel Returns Integer
        #IFDEF Is$WebApp
        Integer iRet
        Get LLPrintStart iType sFile iOptions to iRet
        Function_Return iRet
        #ELSE
        String sVar sVar2 sExistingPreview
        Pointer pVar pVar2
        Integer iRet iPreviewObj
        #IF (!@>109)
        tAliasDb[] sAllFields
        #ENDIF
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(Self))) ) Begin
            Function_Return 0
        End        
        If ( (piEmbeddedPreviewObjectInt(Self)<>0) and (not(pbIncrementalPreview(Self))) ) Begin
            Get object_id of (piEmbeddedPreviewObjectInt(Self)) to iPreviewObj                        
            If (iPreviewObj<>0) Begin
                Get FileUrl of iPreviewObj to sExistingPreview
                If (sExistingPreview<>"") Begin
                    Set FileUrl of iPreviewObj to ""
                    EraseFile sExistingPreview
                End
            End
        End
        Set piProjectType to iType
        If (psCurrentProjectFile(Self)<>sFile) ;
            Set pbDefinesNeeded to True
        Set psCurrentProjectFile to sFile
        If ( (not(pbKeepJobOpen(Self))) or (pbDefinesNeeded(Self)) ) Begin
            If (piJobNumber(Self)<>0) Begin
                #IF (!@>199)
                Move (LlDbAddTableEf(piJobNumber(Self),"","")) to iRet
                #ELSE
                Move (LlDbAddTableEf(piJobNumber(Self),0,0)) to iRet
                #ENDIF
            End            
            Send delete_data to (oAllFields(Self))
            Send delete_data to (oAllVariables(Self))
            #IF (!@>109)
            Set paAllAliasFields to sAllFields
            Set paAllAliasVariables to sAllFields
            #ENDIF        
            Set psUsedIdentifiers to ""
            Set psCurrentTable to ""
            
            Send DoFillUsedIdentifiers sFile
            
            Get LLDefineFieldStart to iRet
            Get LLDefineVariableStart to iRet
            Send DefineOneTimeVariables
            Send DefineStandardVariables
            Send DefineAllFields
            Send DefineAllVariables
        End
        Else Begin
            Send DefineStandardVariables
            Send DefineUsedVariables            
        End
        If (hWndParent=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWndParent            
        End
        #IF (!@>199)
        Move (LLPrintWithBoxStartEf((piJobNumber(Self)),iType,sFile,iOptions,iBoxType,hWndParent,sTitel)) to iRet
        #ELSE
        Move (ToAnsiStr(self,sFile)) to sVar
        Move (AddressOf(sVar)) to pVar
        Move (ToAnsiStr(self,sTitel)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (LLPrintWithBoxStartEf((piJobNumber(Self)),iType,pVar,iOptions,iBoxType,hWndParent,pVar2)) to iRet
        #ENDIF
        Set piFirstPrint to True
        If ( (not(pbKeepJobOpen(Self))) or (pbDefinesNeeded(Self)) or (pbForceUsedIdentifierIdentification(Self)) ) Begin
            Send SearchUsedFields
            Send SearchUsedVariables
            Set pbForceUsedIdentifierIdentification to False
        End
        Set pbDefinesNeeded to False
        Function_Return iRet
        #ENDIF
    End_Function
    
    Function LLPrintAbort Returns Integer
        If (piJobNumber(Self)=0) ;
            Function_Return LL_ERR_BAD_JOBHANDLE
        Function_Return (LLPrintAbortEf(piJobNumber(self)))
    End_Function
    
    Function LLAssociatePreviewControl Handle hWnd Integer iOptions Returns Integer
        Integer iRet
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(self))) ) Begin
            Function_Return 0
        End        
        Move (LLAssociatePreviewControlEf((piJobNumber(self)),hWnd,iOptions)) to iRet
        Function_Return iRet
    End_Function

    Function LLPrintOptionsDialog Handle hWnd String sText Returns Integer
        #IFDEF Is$WebApp
        Function_Return LL_ERR_NOUSERINTERACTION
        #ENDIF
        String sVar
        Pointer pVar
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(self))) ) Begin
            Function_Return 0
        End
        If (hWnd=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWnd
        End
        #IF (!@>199)
        Function_Return (LLPrintOptionsDialogEf(piJobNumber(Self),hwnd,sText))
        #ELSE
        Move (ToAnsiStr(self,sText)) to sVar
        Move (AddressOf(sVar)) to pVar
        Function_Return (LLPrintOptionsDialogEf(piJobNumber(Self),hwnd,pVar))
        #ENDIF
    End_Function
    
    Function LLPrintSelectOffsetEx Handle hWnd Returns Integer
        #IFDEF Is$WebApp
        Function_Return LL_ERR_NOUSERINTERACTION
        #ENDIF        
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(Self))) ) Begin
            Function_Return 0
        End
        If (hWnd=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWnd
        End        
        Function_Return (LlPrintSelectOffsetExEf(piJobNumber(Self),hWnd))
    End_Function

    Function LLDefineLayout Handle hWnd String sText Integer iType String sFile Returns Integer
        String sVar1 sVar2 sCurDir sActionText
        Pointer pVar1 pVar2
        Integer iRet iIsNewProject iLanguage
        
        #IFDEF Is$WebApp
        Function_Return LL_ERR_NOUSERINTERACTION
        #ENDIF        
        
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(Self))) ) Begin
            Function_Return 0
        End        
        
        If (iType iand LL_NONAMEINTITLE) Begin
            Set piProjectType to (iType - LL_NONAMEINTITLE)
        End
        Else Begin
            Set piProjectType to iType
        End
        
        If (Uppercase(Trim(sFile))="CREATENEWPROJECT") Begin
            Move "" to sFile
            Move 1 to iIsNewProject
        End

        Set psCurrentProjectFile to sFile
        
        If (piJobNumber(Self)<>0) Begin
            #IF (!@>199) 
            Move (LlDbAddTableEf(piJobNumber(Self),"","")) to iRet
            #ELSE
            Move (LlDbAddTableEf(piJobNumber(Self),0,0)) to iRet
            #ENDIF
        End        
        
        Send delete_data to (oAllFields(self))
        Send delete_data to (oAllVariables(Self))
        #IF (!@>109)
        tAliasDb[] sAllFields
        Set paAllAliasFields to sAllFields
        Set paAllAliasVariables to sAllFields
        #ENDIF        
        Set psUsedIdentifiers to ""
        Set psCurrentTable to ""
        Get LLDefineFieldStart to iRet
        Get LLDefineVariableStart to iRet
        Send DefineOneTimeVariables
        Send DefineStandardVariables
        Send DefineAllFields
        Send DefineAllVariables
        
        Set pbForceUsedIdentifierIdentification to True
        Set pbDefinesNeeded to False

        Set piIsLayouting to TRUE

        Move (LLSetOptionString(Self,LL_OPTIONSTR_DEFDEFFONT,"{(0,0,0),10,-12,0,0,0,400,0,0,0,0,3,2,1,34,Arial}")) to iRet
        
        Move (ToAnsiStr(Self,sText)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (ToAnsiStr(self,sFile)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        If (iIsNewProject) Begin
            Get_Directory sCurDir
            If (trim(psDefaultLayoutDirectory(Self))<>"") Begin
                Set_Directory (psDefaultLayoutDirectory(Self))
            End
            If (not(iType iand LL_NONAMEINTITLE)) Begin
                Move (iType ior LL_NONAMEINTITLE) to iType
            End
        End
        If (hWnd=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWnd
        End
        
        If (piProjectType(Self)<>LL_PROJECT_LIST) Begin
            Move "Set Table and Sort-Order..." to sActionText
            Move (LlGetOptionEf((piJobNumber(Self)),LL_OPTION_LANGUAGE)) to iLanguage
            If (iLanguage=CMBTLANG_GERMAN) Begin            
                Move "Tabelle und Sortierung..." to sActionText
            End
            Get LLDesignerAddAction 10999 (LLDESADDACTIONFLAG_ADD_TO_TOOLBAR ior LLDESADDACTION_MENUITEM_APPEND) sActionText "2.2" (Replace("...",sActionText,"")) 16 to iRet
        End        
        #IF (!@>199)
        If (sFile="") ;
            Move (Character(0)) to sFile
        Move (LLDefineLayoutEf(piJobNumber(Self),hWnd,sText,iType,sFile)) to iRet
        #ELSE
        Move (LLDefineLayoutEf(piJobNumber(Self),hWnd,pVar1,iType,pVar2)) to iRet
        #ENDIF
        If (iIsNewProject) Begin
            Set_Directory sCurDir
        End
        Set piIsLayouting to FALSE
        Function_Return iRet
    End_Function

    Function LLSelectFileDlgTitleEx Handle hWnd String sTitle Integer iType Returns String
        Integer iRet
        String sVar1 sVar2 sDir
        Pointer pVar1 pVar2
        
        #IFDEF Is$WebApp
        Function_Return ""
        #ENDIF        
        
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(Self))) ) Begin
            Function_Return (psDesignerPreviewProjectName(Self))
        End        
        
        If (hWnd=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWnd
        End
        #IF (!@>199)
        WString wVar
        If (psDefaultLayoutDirectory(Self)<>"") Begin
            Move (trim(psDefaultLayoutDirectory(Self))) to sDir
            If (Right(sDir,1)<>"\") ;
                Move (sDir + "\") to sDir
            If (psDefaultLayoutFile(Self)<>"") ;
                Move (sDir + (psDefaultLayoutFile(Self))) to sDir
            Move (sDir+(Repeat(Character(0),512))) to wVar
        End
        Else Begin
            If (psDefaultLayoutFile(Self)<>"") Begin
                Move (psDefaultLayoutFile(Self)+(Repeat(Character(0),512))) to wVar
            End
            Else Begin
                Move (Repeat(Character(0),512)) to wVar
            End
        End        
        Move (LLSelectFileDlgTitleExEf(piJobNumber(Self),hWnd,sTitle,iType,addressof(wVar),1024,0)) to iRet
        If (iRet=0) Begin
            Move (CString(wVar)) to sVar2
            If ( (trim(sVar2)="") and (iType iand LL_FILE_ALSONEW) ) Begin
                Move "CREATENEWPROJECT" to sVar2
            End
            Function_Return sVar2
        End
        Else ;
            Function_Return ""        
        #ELSE
        Move (ToAnsistr(self,sTitle)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        If (psDefaultLayoutDirectory(Self)<>"") Begin
            Move (trim(psDefaultLayoutDirectory(self))) to sDir
            If (Right(sDir,1)<>"\") ;
                Move (sDir + "\") to sDir
            If (psDefaultLayoutFile(Self)<>"") ;
                Move (sDir + (psDefaultLayoutFile(Self))) to sDir
            Move (ToAnsiStr(self,sDir)) to sVar2
            Move (sVar2 + (Repeat(Character(0),512))) to sVar2
        End
        Else Begin
            If (psDefaultLayoutFile(Self)<>"") Begin
                Move (ToAnsiStr(self,(psDefaultLayoutFile(self)))) to sVar2
                Move (sVar2 + (Repeat(Character(0),512))) to sVar2
            End
            Else Begin
                Move (Repeat(Character(0),512)) to sVar2
            End
        End        
        Move (AddressOf(sVar2)) to pVar2
        Move (LLSelectFileDlgTitleExEf(piJobNumber(self),hWnd,pVar1,iType,pVar2,512,0)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVar2,pVar2)) to iRet
            If ( (trim(CString(sVar2))="") and (iType iand LL_FILE_ALSONEW) ) Begin
                Move "CREATENEWPROJECT" to sVar2
            End
            Function_Return (cString(sVar2))
        End
        Else ;
            Function_Return ""
        #ENDIF
    End_Function

    Function LLPrinterSetup Handle hWnd Integer iType String sFile Returns Integer
        String sVar1
        Pointer pVar1
        Integer iRet 
        #IF (!@>109)
        tAliasDb[] sAllFields
        #ENDIF                
        
        #IFDEF Is$WebApp
        Function_Return LL_ERR_NOUSERINTERACTION
        #ENDIF        
        
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(Self))) ) Begin
            Function_Return 0
        End        
        
        If (psCurrentProjectFile(Self)<>sFile) ;
            Set pbDefinesNeeded to True
        
        If ( (not(pbKeepJobOpen(Self))) or (pbDefinesNeeded(Self)) ) Begin
            If (piJobNumber(Self)<>0) Begin
                #IF (!@>199) 
                Move (LlDbAddTableEf(piJobNumber(Self),"","")) to iRet
                #ELSE
                Move (LlDbAddTableEf(piJobNumber(Self),0,0)) to iRet
                #ENDIF
            End            
            Send delete_data to (oAllFields(Self))
            Send delete_data to (oAllVariables(Self))  
            #IF (!@>109)
            Set paAllAliasFields to sAllFields
            Set paAllAliasVariables to sAllFields
            #ENDIF        
            Set psUsedIdentifiers to ""
            Set psCurrentTable to ""
            Get LLDefineFieldStart to iRet
            Get LLDefineVariableStart to iRet
            Send defineOneTimeVariables
            Send DefineStandardVariables
            Send DefineAllFields
            Send DefineAllVariables
            Set pbForceUsedIdentifierIdentification to True
        End
        Else Begin
            Send DefineStandardVariables
            Send DefineUsedVariables            
        End
        If (hWnd=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWnd
        End        
        Set psCurrentProjectFile to sFile
        Set pbDefinesNeeded to False
        #IF (!@>199)
        Function_Return (LLPrinterSetupEf(piJobNumber(Self),hWnd,iType,sFile))
        #ELSE
        Move (ToAnsiStr(Self,sFile)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LLPrinterSetupEf(piJobNumber(Self),hWnd,iType,pVar1))
        #ENDIF
    End_Function

    Function LLSetPrinterToDefault Integer iType String sFile Returns Integer
        String sVar1
        Pointer pVar1
        #IF (!@>199)
        Function_Return (LLSetPrinterToDefaultEf(piJobNumber(Self),iType,sFile))
        #ELSE
        Move (ToAnsiStr(self,sFile)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LLSetPrinterToDefaultEf(piJobNumber(Self),iType,pVar1))
        #ENDIF
    End_Function
    
    Function LLSetPrinterInPrinterFile Integer iType String sFile Integer iPrinterIdx String sPrinterName Pointer pDevMode Returns Integer
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Integer iRet
        #IF (!@>199)
        Function_Return (LLSetPrinterInPrinterFileEf(piJobNumber(Self),iType,sFile,iPrinterIdx,sPrinterName,pDevMode))
        #ELSE
        Move (ToAnsiStr(Self,sFile)) to sVar1
        Move (ToAnsiStr(self,sPrinterName)) to sVar2
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Function_Return (LLSetPrinterInPrinterFileEf(piJobNumber(Self),iType,pVar1,iPrinterIdx,pVar2,pDevMode))
        #ENDIF
    End_Function

    Function LLDesignerProhibitAction Integer iIndex Returns Integer
        Function_Return (LLDesignerProhibitActionEf(piJobNumber(self),iIndex))
    End_Function
    
    Function LLDesignerAddAction Integer iId Integer iFlags String sMenuText String sMenuHierarchy String sTooltipText Integer iIcon Returns Integer 
        #IF !@>199
        Function_Return (LlDesignerAddActionEf(piJobNumber(Self),iId,iFlags,sMenuText,sMenuHierarchy,sTooltipText,iIcon,0))
        #ELSE
        String sVar1 sVar2 sVar3
        Pointer pVar1 pVar2 pVar3
        Move (ToAnsiStr(Self,sMenuText)) to sVar1
        Move (ToAnsiStr(Self,sMenuHierarchy)) to sVar2
        Move (ToAnsiStr(Self,sTooltipText)) to sVar3
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Move (AddressOf(sVar3)) to pVar3
        
        Function_Return (LlDesignerAddActionEf(piJobNumber(Self),iId,iFlags,pVar1,pVar2,pVar3,iIcon,0))
        #ENDIF
    End_Function
    
    Function LlDesignerSetOptionString Integer iOption String sValue Returns Integer
        #IF !@>199
        Function_Return (LlDesignerSetOptionStringEf(piJobNumber(Self),iOption,sValue))
        #ELSE
        String sVar1
        Pointer pVar1
        
        Move (ToAnsiStr(self,sValue)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LlDesignerSetOptionStringEf(piJobNumber(Self),iOption,pVar1))
        #ENDIF
    End_Function

    Function LLPrint Returns Integer
        Send DefineStandardVariables
        Send DefineUsedVariables
        Function_Return (LLPrintEf(piJobNumber(self)))
    End_Function

    Function LLPrintFields Returns Integer
        Send DefineStandardVariables
        Send DefineUsedFields
        Function_Return (LLPrintFieldsEf(piJobNumber(self))) 
    End_Function

    Function LLPrintResetProjectState Returns Integer
        Function_Return (LLPrintResetProjectStateEf(piJobNumber(self)))
    End_Function                                                              
    
    Function LLPrintGetCurrentPage Returns Integer
        Function_Return (LLPrintGetCurrentPageEf(piJobNumber(self)))
    End_Function                                                              
    
    Function LLPrintSetBoxText String sText Integer iPercentage Returns Integer
        String sVal
        Pointer pVal
        Integer iRet
        Integer hoPreviewWindow
        #IFNDEF Is$WebApp
        If (piEmbeddedPreviewObjectInt(Self)<>0) Begin
            If (pbIncrementalPreview(Self)) Begin
                Get Find_Scope of (piEmbeddedPreviewObjectInt(Self)) to hoPreviewWindow            
                If (hoPreviewWindow<>0) Begin
                    Move (Replaces("\n",sText," ")) to sVal
                    Move (Replaces(Character(13),sVal,"")) to sVal
                    Move (Replaces(Character(10),sVal," ")) to sVal
                    Set label of hoPreviewWindow to sVal                
                End
                If (iPercentage<>0) Begin
                    Move (SendMessage(window_handle(piEmbeddedPreviewObjectInt(Self)),LS_VIEWERCONTROL_SET_PROGRESSINFO,iPercentage,pVal)) to iRet
                End    
                Function_Return 0                
            End
        End
        If ( (piPreviewPanel(self)<>0) And (piPreviewObject(self)<>0) ) Begin
            If (pbIncrementalPreview(self)) Begin
                If (active_state(piPreviewPanel(self))) Begin
                    Move (Replaces("\n",sText," ")) to sVal
                    Move (Replaces(Character(13),sVal,"")) to sVal
                    Move (Replaces(Character(10),sVal," ")) to sVal
                    Set label Of (piPreviewPanel(self)) to sVal
                    If (iPercentage<>0) Begin
                        Move (SendMessage(window_handle(piPreviewObject(self)),LS_VIEWERCONTROL_SET_PROGRESSINFO,iPercentage,pVal)) to iRet
                    End    
                    Function_Return 0
                End
            End
        End
        #ENDIF
        #IF (!@>199)
        Move (Replaces("\n",sText,( (Character(13))+(Character(10))))) to sVal
        Function_Return (LLPrintSetBoxTextEf(piJobNumber(Self),sVal,iPercentage))
        #ELSE
        Move (ToAnsiStr(self,sText)) to sVal
        Move (Replaces("\n",sVal,( (Character(13))+(Character(10))))) to sVal
        Move (AddressOf(sVal)) to pVal
        Function_Return (LLPrintSetBoxTextEf(piJobNumber(Self),pVal,iPercentage))
        #ENDIF
    End_Function

    Function LLPrintFieldsEnd Returns Integer
        //Don't call the Defines here otherwise List & Label can't finish Footers, Subgroups etc. with the correct Data.
        //Send DefineStandardVariables
        //Send DefineUsedFields
        Function_Return (LLPrintFieldsEndEf(piJobNumber(self)))
    End_Function
    
    Function LLGetFieldContents String sField Returns String
        String sVal sVal2 sRetVal
        Pointer pVal pVal2
        Integer iRet
        #IF (!@>199)
        WString wVar
        Move (Repeat(Character(0),1024)) to wVar
        Move (LLGetFieldContentsEf(piJobNumber(Self),sField,AddressOf(wVar),2048)) to iRet
        If (iRet=0) Begin
            Move (cString(wVar)) to sRetVal
        End        
        #ELSE
        Move (ToAnsiStr(self,sField)) to sVal
        Move (AddressOf(sVal)) to pVal
        Move (LLZeroString(1024)) to sVal2
        Move (AddressOf(sVal)) to pVal
        Move (LLGetFieldContentsEf(piJobNumber(self),pVal,pVal2,1024)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVal2,pVal2)) to iRet
            Move (cString(sVal2)) to sRetVal
        End
        #ENDIF
        Function_Return sRetVal
    End_Function

    Function LLGetVariableContents String sVariable Returns String
        String sVal sVal2 sRetVal
        Pointer pVal pVal2
        Integer iRet
        #IF (!@>199)
        WString wVar
        Move (Repeat(Character(0),1024)) to wVar
        Move (LLGetVariableContentsEf(piJobNumber(Self),sVariable,AddressOf(wVar),2048)) to iRet
        If (iRet=0) Begin
            Move (CString(wVar)) to sRetVal
        End
        #ELSE
        Move (ToAnsiStr(self,sVariable)) to sVal
        Move (AddressOf(sVal)) to pVal
        Move (LLZeroString(1024)) to sVal2
        Move (AddressOf(sVal2)) to pVal2
        Move (LLGetVariableContentsEf(piJobNumber(self),pVal,pVal2,1024)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVal2,pVal2)) to iRet
            Move (cString(sVal2)) to sRetVal
        End
        #ENDIF
        Function_Return sRetVal
    End_Function
    
    Function LLGetUserVariableContents String sVariable Returns String
        String sVal sVal2 sRetVal
        Pointer pVal pVal2
        Integer iRet
        #IF (!@>199)
        WString wVar
        Move (Repeat(Character(0),1024)) to wVar
        Move (LLGetUserVariableContentsEf(piJobNumber(Self),sVariable,AddressOf(wVar),2048)) to iRet
        If (iRet=0) Begin
            Move (cString(wVar)) to sRetVal
        End        
        #ELSE
        Move (ToAnsiStr(self,sVariable)) to sVal
        Move (AddressOf(sVal)) to pVal
        Move (LLZeroString(1024)) to sVal2
        Move (AddressOf(sVal2)) to pVal2
        Move (LLGetUserVariableContentsEf(piJobNumber(self),pVal,pVal2,1024)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVal2,pVal2)) to iRet
            Move (cString(sVal2)) to sRetVal
        End
        #ENDIF
        Function_Return sRetVal
    End_Function    
    
    Function LLPrintEnableObject String sObject Integer bEnable Returns Integer
        String sVal
        Pointer pVal
        If (trim(sObject)<>"") ;
            Move (":"+sObject) to sObject
        #IF (!@>199)
        Function_Return (LLPrintEnableObjectEf(piJobNumber(Self),sObject,bEnable))
        #ELSE
        Move (ToAnsiStr(self,sObject)) to sVal
        Move (AddressOf(sVal)) to pVal
        Function_Return (LLPrintEnableObjectEf(piJobNumber(Self),pVal,bEnable))
        #ENDIF
    End_Function
    
    Function LLPrintEnd Returns Integer
        If (piProjectType(Self)=LL_PROJECT_LIST) Begin
            While (LLPrintFieldsEndEf(piJobNumber(Self))=LL_WRN_REPEAT_DATA)
            End
        End
        Function_Return (LLPrintEndEf(piJobNumber(self),0))
    End_Function
    
    Function LLPreviewDisplay String sFile String sPath Handle hWnd Returns Integer
        #IFDEF Is$WebApp
        Function_Return LL_ERR_NOUSERINTERACTION
        #ELSE
        String sVar1 sVar2 sPreviewFile sTempDir
        Pointer pVar1 pVar2
        Integer iRet iPreviewObj iPreviewPanel iOldCurrentModalObject iOldStopUiState iMain hoFocus iOldEs
        
        If ( (pbDesignerPreviewRunning(Self)) and (not(pbDesignerPreviewRunningOverride(Self))) ) Begin
            Function_Return 0
        End
        
        If (piEmbeddedPreviewObjectInt(Self)<>0) Begin
            Get object_id of (piEmbeddedPreviewObjectInt(Self)) to iPreviewObj
            If (pbIncrementalPreview(Self)) Begin
                Get Find_Scope of (piEmbeddedPreviewObjectInt(Self)) to iPreviewPanel
                If (psPreviewOriginalLabel(Self)<>"") Begin
                    If (iPreviewPanel) Begin
                        Set label of iPreviewPanel to (psPreviewOriginalLabel(Self))
                    End
                    Set psPreviewOriginalLabel to ""
                End                
                Move (SendMessage(window_handle(iPreviewObj),LS_VIEWERCONTROL_SET_PROGRESSINFO,-1,0)) to iRet
                Set pbPreviewRunning of iPreviewObj to False
                Send OnIncrementalPreviewEnd to iPreviewObj (Self)            
                Set piAssociatedLLObj of iPreviewObj to 0
                Send DoDisableOtherWindows False
                If (phoFocusBeforePrint(Self)<>0) Begin
                    Send activate to (phoFocusBeforePrint(Self))
                    Set phoFocusBeforePrint to 0
                End                
                If (piOriginalKeyPath(Self)<>-1) Begin
                    Set key_path of (Find_Scope(iPreviewObj)) to (piOriginalKeyPath(Self))
                    Set piOriginalKeyPath to -1
                    Set Key_Path of (piEmbeddedPreviewObjectInt(Self)) to 0
                    If (piEmbeddedPreviewCancelBtn(Self)<>0) Begin
                        Set Key_Path of (piEmbeddedPreviewCancelBtn(Self)) to 0
                    End                    
                End
            End
            Else Begin
                Move sFile to sPreviewFile
                While (Pos("\",sPreviewFile)<>0)
                    Move (Right(sPreviewFile,( (length(sPreviewFile)) - (Pos("\",sPreviewFile)) ) )) to sPreviewFile
                End
                Move (Left(sPreviewFile,(Pos(".",sPreviewFile)))) to sPreviewFile
                If (trim(sPath)<>"") ;
                    Move sPath to sTempDir
                Else ;
                    Move (psTempPath(Self)) to sTempDir
                Move (trim(sTempDir)) to sTempDir
                If (Right(sTempDir,1)<>"\") ;
                    Move (sTempDir + "\") to sTempDir
                Move (sTempDir + sPreviewFile + "LL") to sPreviewFile
                Set FileUrl of iPreviewObj to sPreviewFile
            End
            Function_Return 0
        End
        
        If ( (piPreviewPanel(self)<>0) And (piPreviewObject(self)<>0) ) Begin
            If (pbIncrementalPreview(self)) Begin
                Get object_id Of (piPreviewObject(self)) to iPreviewObj
                Get object_id Of (piPreviewPanel(self)) to iPreviewPanel
                If (psPreviewOriginalLabel(self)<>"") Begin
                    Set label Of iPreviewPanel to (psPreviewOriginalLabel(self))
                    Set psPreviewOriginalLabel to ""
                End
                If (active_state(iPreviewPanel)) Begin
                    Move (SendMessage(window_handle(iPreviewObj),LS_VIEWERCONTROL_SET_PROGRESSINFO,-1,0)) to iRet
                    Set pbPreviewRunning Of iPreviewObj to False
                    Send OnIncrementalPreviewEnd to iPreviewObj (self)
                    
                    Move current_modal_object to iOldCurrentModalObject
                    Get private.stop_ui_state of iPreviewPanel to iOldStopUiState
                    Move iPreviewPanel to Current_Modal_Object
                    Set private.stop_ui_state Of iPreviewPanel to True
                    Get exit_application_local_state Of iPreviewPanel to iOldEs
                    Set exit_application_local_state Of iPreviewPanel to True
                    Start_UI
                    Set private.stop_ui_state Of iPreviewPanel to iOldStopUiState
                    Set exit_application_local_state Of iPreviewPanel to iOldEs
                    Move iOldCurrentModalObject to current_modal_object
                End
                If ( (current_modal_object<>0) And (Not(visible_state(current_modal_object))) ) Begin
                    Set visible_state Of (current_modal_object) to TRUE
                End                
                Set piAssociatedLLObj Of iPreviewObj to 0
                Send DoDisableOtherWindows False
                If (phoFocusBeforePrint(self)<>0) Begin
                    Send activate to (phoFocusBeforePrint(self))
                    Set phoFocusBeforePrint to 0
                End                
                If (piOriginalKeyPath(self)<>-1) Begin
                    Set key_path Of iPreviewPanel to (piOriginalKeyPath(self))
                    Set piOriginalKeyPath to -1
                End
            End
            Else Begin
                Get object_id of (piPreviewObject(Self)) to iPreviewObj
                Get object_id Of (piPreviewPanel(self)) to iPreviewPanel                
                Move sFile to sPreviewFile
                While (Pos("\",sPreviewFile)<>0)
                    Move (Right(sPreviewFile,( (length(sPreviewFile)) - (Pos("\",sPreviewFile)) ) )) to sPreviewFile
                End
                Move (Left(sPreviewFile,(Pos(".",sPreviewFile)))) to sPreviewFile
                If (trim(sPath)<>"") ;
                    Move sPath to sTempDir
                Else ;
                    Move (psTempPath(Self)) to sTempDir
                Move (trim(sTempDir)) to sTempDir
                If (Right(sTempDir,1)<>"\") ;
                    Move (sTempDir + "\") to sTempDir
                Move (sTempDir + sPreviewFile + "LL") to sPreviewFile
                Set psFileToDisplay Of iPreviewObj to sPreviewFile
                Set phoFocusBeforePrint to (focus(desktop))
                Set popup_state Of iPreviewPanel to True 
                Send Popup to iPreviewPanel
                Send DoDisableOtherWindows True
                Get key_path Of iPreviewPanel to iRet
                Set piOriginalKeyPath to iRet
                Set key_path Of iPreviewPanel to (desktop)
                Set piAssociatedLLObj Of iPreviewObj to (self) 
                Move current_modal_object to iOldCurrentModalObject
                Get private.stop_ui_state Of iPreviewPanel to iOldStopUiState
                Move iPreviewPanel to Current_Modal_Object
                Set private.stop_ui_state Of iPreviewPanel to True
                Get exit_application_local_state Of iPreviewPanel to iOldEs
                Set exit_application_local_state Of iPreviewPanel to True
                Start_UI
                Set private.stop_ui_state Of iPreviewPanel to iOldStopUiState
                Set exit_application_local_state Of iPreviewPanel to iOldEs
                Move iOldCurrentModalObject to current_modal_object                
                Set piAssociatedLLObj Of iPreviewObj to 0
                Send DoDisableOtherWindows False
                If (phoFocusBeforePrint(self)<>0) Begin
                    Send activate to (phoFocusBeforePrint(self))
                    Set phoFocusBeforePrint to 0
                End                
                If (piOriginalKeyPath(self)<>-1) Begin
                    Set key_path Of iPreviewPanel to (piOriginalKeyPath(self))
                    Set piOriginalKeyPath to -1
                End                
            End
            Function_Return 0
        End
        If (hWnd=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWnd
        End        
        If (trim(sPath)="") ;
            Move (psTempPath(Self)) to sPath
        #IF (!@>199)
        Function_Return (LLPreviewDisplayEf(piJobNumber(Self),sFile,sPath,hWnd))
        #ELSE
        Move (ToAnsiStr(self,sFile)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (ToAnsiStr(self,sPath)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Function_Return (LLPreviewDisplayEf(piJobNumber(Self),pVar1,pVar2,hWnd))
        #ENDIF
        #ENDIF
    End_Function

    Function LLPreviewDeleteFiles String sFile String sPath Returns Integer
        If (trim(sPath)= "") ;
            Move (psTempPath(Self)) to sPath
        #IF (!@>199)
        Function_Return (LLPreviewDeleteFilesEf(piJobNumber(Self),sFile,sPath))
        #ELSE
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Move (ToAnsiStr(self,sFile)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (ToAnsiStr(self,sPath)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Function_Return (LLPreviewDeleteFilesEf(piJobNumber(Self),pVar1,pVar2))
        #ENDIF
    End_Function

    Function LLXGetParameter Integer iExtensionType String sExtensionName String sKey Returns String
        Integer iRet
        #IF (!@>199)
        WString wVar
        String sVal
        
        Move (Repeat(Character(0),250)) to wVar
        Move (LLxGetParameterEf(piJobNumber(Self),iExtensionType,sExtensionName,sKey,AddressOf(wVar),500)) to iRet
        If (iRet=0) Begin
            Move (CString(wVar)) to sVal
            Function_Return sVal
        End
        Else ;
            Function_Return ""
        #ELSE
        String sVar1 sVar2 sVar3
        Pointer pVar1 pVar2 pVar3
        Move (ToAnsiStr(self,sExtensionName)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (ToAnsiStr(self,sKey)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (Repeat(Character(0),250)) to sVar3
        Move (AddressOf(sVar3)) to pVar3
        Move (LLxGetParameterEf(piJobNumber(self),iExtensionType,pVar1,pVar2,pVar3,250)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVar3,pVar3)) to iRet
            Function_Return (cString(sVar3))
        End
        Else ;
            Function_Return ""
        #ENDIF
    End_Function

    Function LLXSetParameter Integer iExtensionType String sExtensionName String sKey String sValue Returns Integer
        #IF (!@>199)
        Function_Return (LLxSetParameterEf(piJobNumber(Self),iExtensionType,sExtensionName,sKey,sValue))
        #ELSE
        String sVar1 sVar2 sVar3
        Pointer pVar1 pVar2 pVar3
        Integer iRet
        Move (ToAnsiStr(self,sExtensionName)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (ToAnsiStr(self,sKey)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (ToAnsiStr(self,sValue)) to sVar3
        Move (AddressOf(sVar3)) to pVar3
        Function_Return (LLxSetParameterEf(piJobNumber(Self),iExtensionType,pVar1,pVar2,pVar3))
        #ENDIF
    End_Function
    
    Function LLDbAddTable String sTableId String sDisplayName Returns Integer
        #IF (!@>199)
        Function_Return (LlDbAddTableEf(piJobNumber(Self),sTableId,sDisplayName))
        #ELSE
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Move (ToAnsiStr(self,sTableId)) to sVar1
        Move (ToAnsiStr(self,sDisplayName)) to sVar2
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Function_Return (LlDbAddTableEf(piJobNumber(Self),pVar1,pVar2))
        #ENDIF
    End_Function
    
    Function LlDbAddTableRelation String sTableId String sParentId String sRelationId String sDisplayName Returns Integer
        #IF (!@>199)
        Function_Return (LlDbAddTableRelationEf(piJobNumber(Self),sTableId,sParentId,sRelationId,sDisplayName))
        #ELSE
        String sVar1 sVar2 sVar3 sVar4
        Pointer pVar1 pVar2 pVar3 pVar4
        Move (ToAnsiStr(self,sTableId)) to sVar1
        Move (ToAnsiStr(self,sParentId)) to sVar2
        Move (ToAnsiStr(self,sRelationId)) to sVar3
        Move (ToAnsiStr(self,sDisplayName)) to sVar4
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Move (AddressOf(sVar3)) to pVar3
        Move (AddressOf(sVar4)) to pVar4
        Function_Return (LlDbAddTableRelationEf(piJobNumber(Self),pVar1,pVar2,pVar3,pVar4))
        #ENDIF
    End_Function
    
    Function LlDbAddTableRelationEx String sTableId String sParentId String sRelationId String sDisplayName String sKeyField String sParentKeyField Returns Integer
        #IF (!@>199)
        Function_Return (LlDbAddTableRelationExEf(piJobNumber(Self),sTableId,sParentId,sRelationId,sDisplayName,sKeyField,sParentKeyField))
        #ELSE
        String sVar1 sVar2 sVar3 sVar4 sVar5 sVar6
        Pointer pVar1 pVar2 pVar3 pVar4 pVar5 pVar6
        Move (ToAnsiStr(Self,sTableId)) to sVar1
        Move (ToAnsiStr(Self,sParentId)) to sVar2
        Move (ToAnsiStr(Self,sRelationId)) to sVar3
        Move (ToAnsiStr(Self,sDisplayName)) to sVar4
        Move (ToAnsiStr(Self,sKeyField)) to sVar5
        Move (ToAnsiStr(Self,sParentKeyField)) to sVar6
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Move (AddressOf(sVar3)) to pVar3
        Move (AddressOf(sVar4)) to pVar4        
        Move (AddressOf(sVar5)) to pVar5
        Move (AddressOf(sVar6)) to pVar6
        Function_Return (LlDbAddTableRelationExEf(piJobNumber(Self),pVar1,pVar2,pVar3,pVar4,pVar5,pVar6))
        #ENDIF
    End_Function
    
    Function LlDbAddTableSortOrder String sTableId String sSortOrderId String sDisplayName Returns Integer
        #IF (!@>199)
        Function_Return (LlDbAddTableSortOrderEf(piJobNumber(Self),sTableId,sSortOrderId,sDisplayName))
        #ELSE
        String sVar1 sVar2 sVar3
        Pointer pVar1 pVar2 pVar3
        Move (ToAnsiStr(self,sTableId)) to sVar1
        Move (ToAnsiStr(self,sSortOrderId)) to sVar2
        Move (ToAnsiStr(self,sDisplayName)) to sVar3
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Move (AddressOf(sVar3)) to pVar3
        Function_Return (LlDbAddTableSortOrderEf(piJobNumber(Self),pVar1,pVar2,pVar3))
        #ENDIF
    End_Function
    
    Function LLDbAddTableSortOrderEx String sTableId String sSortOrderId String sDisplayName String sFields Returns Integer
        #IF (!@>199)
        Function_Return (LlDbAddTableSortOrderExEf(piJobNumber(Self),sTableId,sSortOrderId,sDisplayName,sFields))
        #ELSE
        String sVar1 sVar2 sVar3 sVar4
        Pointer pVar1 pVar2 pVar3 pVar4
        Move (ToAnsiStr(Self,sTableId)) to sVar1
        Move (ToAnsiStr(Self,sSortOrderId)) to sVar2
        Move (ToAnsiStr(Self,sDisplayName)) to sVar3
        Move (ToAnsiStr(Self,sFields)) to sVar4
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Move (AddressOf(sVar3)) to pVar3
        Move (AddressOf(sVar4)) to pVar4
        Function_Return (LlDbAddTableSortOrderExEf(piJobNumber(Self),pVar1,pVar2,pVar3,pVar4))
        #ENDIF
    End_Function
    
    Function LlDbSetMasterTable String sTableId Returns Integer
        #IF (!@>199)
        Function_Return (LlDbSetMasterTableEf(piJobNumber(Self),sTableId))
        #ELSE
        String sVar1
        Pointer pVar1
        Move (ToAnsiStr(self,sTableId)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LlDbSetMasterTableEf(piJobNumber(Self),pVar1))
        #ENDIF
    End_Function
    
    Function LLPrintDbGetCurrentTable Integer bCompletePath Returns String
        #IF (!@>199)
        WString wVar
        String sVar
        Integer iRet
        Move (Repeat(Character(0),512)) to wVar
        Move (LLprintDbGetCurrentTableEf(piJobNumber(Self),AddressOf(wVar),1024,bCompletePath)) to iRet
        If (iRet=0) Begin
            Move (CString(wVar)) to sVar
            Function_Return sVar
        End
        #ELSE
        String sVar1
        Pointer pVar1
        Integer iRet
        Move (LLZeroString(512)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (LLprintDbGetCurrentTableEf(piJobNumber(self),pVar1,512,bCompletePath)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVar1,pVar1)) to iRet
            Function_Return (cString(sVar1))
        End
        #ENDIF
        Function_Return ""
    End_Function
    
    Function LLPrintDbGetCurrentTableSortOrder Returns String
        #IF (!@>199)
        WString wVar
        String sVal
        Integer iRet
        Move (Repeat(Character(0),512)) to wVar
        Move (LLprintDbGetCurrentTableSortOrderEf(piJobNumber(Self),AddressOf(wVar),1024)) to iRet
        If (iRet=0) Begin
            Move (CString(wVar)) to sVal
            Function_Return sVal
        End        
        #ELSE
        String sVar1
        Pointer pVar1
        Integer iRet
        Move (LLZeroString(512)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (LLprintDbGetCurrentTableSortOrderEf(piJobNumber(self),pVar1,512)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVar1,pVar1)) to iRet
            Function_Return (cString(sVar1))
        End
        #ENDIF
        Function_Return ""
    End_Function    
    
    Function LLPrintDbGetCurrentTableRelation Returns String
        #IF (!@>199)
        WString wVar
        String sVal
        Integer iRet
        Move (Repeat(Character(0),512)) to wVar
        Move (LLprintDbGetCurrentTableRelationEf(piJobNumber(Self),AddressOf(wVar),1024)) to iRet
        If (iRet=0) Begin
            Move (CString(wVar)) to sVal
            Function_Return sVal
        End
        #ELSE
        String sVar1
        Pointer pVar1
        Integer iRet
        Move (LLZeroString(512)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (LLprintDbGetCurrentTableRelationEf(piJobNumber(self),pVar1,512)) to iRet
        If (iRet=0) Begin
            Move (AnsiToOem(pVar1,pVar1)) to iRet
            Function_Return (cString(sVar1))
        End
        #ENDIF
        Function_Return ""
    End_Function    

    Function LlStgsysStoragePrint String sFile String sTemp String sPrinter1 String sPrinter2 Integer iStartPage Integer iEndPage Integer iCopies Integer iFlags String sMessage Handle hWndParent Returns Integer
        If (hWndParent=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWndParent
        End        
        #IF (!@>199)
        Function_Return (LlStgsysStoragePrintEf(sFile,sTemp,sPrinter1,sPrinter1,iStartPage,iEndPage,iCopies,iFlags,sMessage,hWndParent))
        #ELSE
        String sVar1 sVar2 sVar3 sVar4 sVar5
        Pointer pVar1 pVar2 pVar3 pVar4 pVar5
        Move (ToAnsiStr(self,sFile)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (ToAnsiStr(self,sTemp)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (ToAnsiStr(self,sPrinter1)) to sVar3
        Move (AddressOf(sVar3)) to pVar3
        If (trim(sPrinter1)="") ;
            Move 0 to pVar3
        Move (ToAnsiStr(self,sPrinter2)) to sVar4
        Move (AddressOf(sVar4)) to pVar4
        If (trim(sPrinter2)="") ;
            Move 0 to pVar4
        Move (ToAnsiStr(self,sMessage)) to sVar5
        Move (AddressOf(sVar5)) to pVar5
        Function_Return (LlStgsysStoragePrintEf(pVar1,pVar2,pVar3,pVar4,iStartPage,iEndPage,iCopies,iFlags,pVar5,hWndParent))
        #ENDIF
    End_Function
    
    #IF (!@>199)
    Function LlStgsysStorageOpen String sFile String sTempPath Integer bReadOnly Integer bOneJobConversion Returns Longptr
        Function_Return (LlStgsysStorageOpenEf(sFile,sTempPath,bReadOnly,bOneJobConversion)) 
    End_Function
    
    Function LlStgsysStorageClose Longptr hStg Returns Integer
        Function_Return (LlStgsysStorageCloseEf(hStg))
    End_Function    
    Function LlStgsysPrint Longptr hStg String sPrinter1 String sPrinter2 Integer iStartPage Integer iEndPage Integer iCopies Integer iFlags String sMessage Handle hWndParent Returns Integer
        If (hWndParent=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWndParent
        End        
        Function_Return (LlStgsysPrintEf(hStg,sPrinter1,sPrinter2,iStartPage,iEndPage,iCopies,iFlags,sMessage,hWndParent))
    End_Function        
    Function LlStgsysStorageConvert String sFile String sDestFile String sFormat Returns Integer
        Function_Return (LlStgsysStorageConvertEf(sFile,sDestFile,sFormat))
    End_Function    
    Function LsConversionJobOpen String sFormat Returns Longptr
        Function_Return (LsConversionJobOpenEf(window_handle(Self),(piUseLanguage(Self)),sFormat))
    End_Function
    Function LsConversionJobClose Longptr hCnvJob Returns Integer
        Function_Return (LsConversionJobCloseEf(hCnvJob))
    End_Function
    Function LsConversionConfigurationDlg Longptr hCnvJob Returns Integer
        Function_Return (LsConversionConfigurationDlgEf(hCnvJob,(window_handle(Self))))
    End_Function
    Function LsConversionConvertStgToFile Longptr hCnvJob Longptr hStg String sFilename Returns Integer
        Function_Return (LsConversionConvertStgToFileEf(hCnvJob,hStg,sFilename))
    End_Function    
    Function LsConversionSetOptionString Longptr hCnvJob String sOption String sValue Returns Integer
        Function_Return (LsConversionSetOptionStringEf(hCnvJob,sOption,sValue))
    End_Function        
    // SavePreviewAsFile is used to export a existing Preview File into various File Formats:
    // Params: 
    // sFile          The existing Report File (the Filename of the Preview-File is taken automatically) i.E. c:\path\llcontrpt2.lst
    // sTargetFile    The desired Filename of the Result: i.E. c:\path\test.pdf
    // sFormat        The desired File-Format: i.E PDF, TIFF, ...
    // iWithOptions   If TRUE Export-Options from List & Label are displayed, otherwise Standard-Options are used.
    // iFromPage      Start-Page of Export (if 0 the First-Page is used)
    // iToPage        End-Page of Export (if 0 the Last-Page is used)
    
    Function SavePreviewAsFile String sFile String sTargetFile String sFormat Integer iWithOptions Integer iFromPage Integer iToPage Longptr hExternStorage Returns Integer
        String sPreviewFile
        Integer iRet 
        Longptr iConversion iStg hExternStg
        
        If (num_arguments>=7) Begin
            Move hExternStorage to hExternStg
        End
        Else Begin
            Move 0 to hExternStg
        End
        
        Move sFile to sPreviewFile
        While (Pos("\",sPreviewFile)<>0)                    // Take only the Filename (without Path)
            Move (Right(sPreviewFile,( (length(sPreviewFile)) - (Pos("\",sPreviewFile)) ) )) to sPreviewFile
        End
        Move (Left(sPreviewFile,(Pos(".",sPreviewFile)))) to sPreviewFile  // Strip the File-Extension
        Move ((psTempPath(Self)) + sPreviewFile + "LL") to sPreviewFile  // Take the Temp-Path, Filename and the LL Extension
        If ( (not(iWithOptions)) and (hExternStg=0) ) Begin
            If (Num_arguments>4) Begin
                If (iFromPage<>0) Begin
                    Move (sFormat + ";Export.PageIndexRange.Min="+(String(iFromPage))) to sFormat
                End
                If (iToPage<>0) Begin
                    Move (sFormat + ";Export.PageIndexRange.Max="+(String(iToPage))) to sFormat
                End
            End    
            Get LlStgsysStorageConvert sPreviewFile sTargetFile sFormat to iRet  // Convert the File directly
            Function_Return iRet
        End
        
        If (hExternStg=0) Begin
            Move (LlStgsysStorageOpen(Self,sPreviewFile,(psTempPath(Self)),True,False)) to iStg
            If (iStg<0) ;
                Function_Return iStg
        End    
        Else Begin
            Move hExternStg to iStg
        End
        
        Move (LsConversionJobOpen(Self,sFormat)) to iConversion
        If (iConversion<0) Begin
            If (hExternStg=0) ;
                Move (LlStgsysStorageClose(Self,iStg)) to iStg
            Function_Return iConversion
        End
        If (iWithOptions) Begin
            //If (sFormat="PDF") Begin
            //    Move (LsConversionSetOptionString(Self,iConversion,"PDF.FontMode","1")) to iRet
            //End
            Move (LsConversionConfigurationDlg(Self,iConversion)) to iRet
            If (iRet <> 0) Begin
                Move (LsConversionJobClose(Self,iConversion)) to iConversion
                If (hExternStg=0) ;
                    Move (LlStgsysStorageClose(Self,iStg)) to iStg
                Function_Return iRet            
            End
        End
        Else Begin
            If (sFormat="PDF") Begin
                Move (LsConversionSetOptionString(Self,iConversion,"PDF.Title","")) to iRet
                Move (LsConversionSetOptionString(Self,iConversion,"PDF.Subject","")) to iRet
                Move (LsConversionSetOptionString(Self,iConversion,"PDF.Keywords","")) to iRet
                Move (LsConversionSetOptionString(Self,iConversion,"PDF.Encryption.EncryptFile","0")) to iRet
            End
        End
        If (Num_arguments>4) Begin
            If (iFromPage <> 0) Begin
                Move (LsConversionSetOptionString(Self,iConversion,"Export.PageIndexRange.Min",(String(iFromPage)))) to iRet
            End
            If (iToPage <> 0) Begin
                Move (LsConversionSetOptionString(Self,iConversion,"Export.PageIndexRange.Max",(String(iToPage)))) to iRet
            End    
        End    
        Move (LsConversionConvertStgToFile(Self,iConversion,iStg,sTargetFile)) to iRet
        Move (LsConversionJobClose(Self,iConversion)) to iConversion
        If (hExternStg=0) Begin
            Move (LlStgsysStorageClose(Self,iStg)) to iStg
        End    
        Function_Return iRet
    End_Function    
    #ELSE
    Function LlStgsysStorageOpen String sFile String sTempPath Integer bReadOnly Integer bOneJobConversion Returns Handle
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Move (ToAnsiStr(Self,sFile)) to sVar1
        Move (ToAnsiStr(Self,sTempPath)) to sVar2
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Function_Return (LlStgsysStorageOpenEf(pVar1,pVar2,bReadOnly,bOneJobConversion)) 
    End_Function
    
    Function LlStgsysStorageClose Integer hStg Returns Integer
        Function_Return (LlStgsysStorageCloseEf(hStg))
    End_Function    
    Function LlStgsysPrint Handle hStg String sPrinter1 String sPrinter2 Integer iStartPage Integer iEndPage Integer iCopies Integer iFlags String sMessage Handle hWndParent Returns Integer
        String sVar1 sVar2 sVar3
        Pointer pVar1 pVar2 pVar3
        If (hWndParent=0) Begin
            Get SuggestedParentWindowHandle (Self) to hWndParent
        End        
        Move (ToAnsiStr(Self,sPrinter1)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        If (trim(sPrinter1)="") ;
            Move 0 to pVar1
        Move (ToAnsiStr(Self,sPrinter2)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        If (trim(sPrinter2)="") ;
            Move 0 to pVar2
        Move (ToAnsiStr(Self,sMessage)) to sVar3
        Move (AddressOf(sVar3)) to pVar3
        If (trim(sMessage)="") ;
            Move 0 to pVar3
        Function_Return (LlStgsysPrintEf(hStg,pVar1,pVar2,iStartPage,iEndPage,iCopies,iFlags,pVar3,hWndParent))
    End_Function        
    Function LlStgsysStorageConvert String sFile String sDestFile String sFormat Returns Integer
        String sVar1 sVar2 sVar3
        Pointer pVar1 pVar2 pVar3
        
        Move (ToAnsiStr(Self,sFile)) to sVar1
        Move (ToAnsiStr(Self,sDestFile)) to sVar2
        Move (ToAnsiStr(Self,sFormat)) to sVar3
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Move (AddressOf(sVar3)) to pVar3
        Function_Return (LLStgsysStorageConvertEf(pVar1,pVar2,pVar3))
    End_Function    
    Function LsConversionJobOpen String sFormat Returns Integer
        String sVar1
        Pointer pVar1
        Move (ToAnsiStr(Self,sFormat)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LsConversionJobOpenEf(window_handle(Self),(piUseLanguage(Self)),pVar1))
    End_Function    
    Function LsConversionJobClose Integer hCnvJob Returns Integer
        Function_Return (LsConversionJobCloseEf(hCnvJob))
    End_Function    
    Function LsConversionConfigurationDlg Integer hCnvJob Returns Integer
        Function_Return (LsConversionConfigurationDlgEf(hCnvJob,(window_handle(Self))))
    End_Function    
    Function LsConversionConvertStgToFile Integer hCnvJob Integer hStg String sFilename Returns Integer
        String sVar1
        Pointer pVar1
        Move (ToAnsiStr(Self,sFileName)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Function_Return (LsConversionConvertStgToFileEf(hCnvJob,hStg,pVar1))
    End_Function    
    Function LsConversionSetOptionString Integer hCnvJob String sOption String sValue Returns Integer
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Move (ToAnsiStr(Self,sOption)) to sVar1
        Move (ToAnsiStr(Self,sValue)) to sVar2
        Move (AddressOf(sVar1)) to pVar1
        Move (AddressOf(sVar2)) to pVar2
        Function_Return (LsConversionSetOptionStringEf(hCnvJob,pVar1,pVar2))
    End_Function
    
    // SavePreviewAsFile is used to export a existing Preview File into various File Formats:
    // Params: 
    // sFile          The existing Report File (the Filename of the Preview-File is taken automatically) i.E. c:\path\llcontrpt2.lst
    // sTargetFile    The desired Filename of the Result: i.E. c:\path\test.pdf
    // sFormat        The desired File-Format: i.E PDF, TIFF, ...
    // iWithOptions   If TRUE Export-Options from List & Label are displayed, otherwise Standard-Options are used.
    // iFromPage      Start-Page of Export (if 0 the First-Page is used)
    // iToPage        End-Page of Export (if 0 the Last-Page is used)
    
    Function SavePreviewAsFile String sFile String sTargetFile String sFormat Integer iWithOptions Integer iFromPage Integer iToPage Integer hExternStorage Returns Integer
        String sPreviewFile
        Integer iRet iStg iConversion hExternStg
       
        If (num_arguments>=7) Begin
            Move hExternStorage to hExternStg
        End
        Else Begin
            Move 0 to hExternStg
        End
        
        Move sFile to sPreviewFile
        While (Pos("\",sPreviewFile)<>0)                    // Take only the Filename (without Path)
            Move (Right(sPreviewFile,( (length(sPreviewFile)) - (Pos("\",sPreviewFile)) ) )) to sPreviewFile
        End
        Move (Left(sPreviewFile,(Pos(".",sPreviewFile)))) to sPreviewFile  // Strip the File-Extension
        Move ((psTempPath(Self)) + sPreviewFile + "LL") to sPreviewFile  // Take the Temp-Path, Filename and the LL Extension
        If ( (not(iWithOptions)) and (hExternStg=0) ) Begin
            If (Num_arguments>4) Begin
                If (iFromPage<>0) Begin
                    Move (sFormat + ";Export.PageIndexRange.Min="+(String(iFromPage))) to sFormat
                End
                If (iToPage<>0) Begin
                    Move (sFormat + ";Export.PageIndexRange.Max="+(String(iToPage))) to sFormat
                End
            End    
            Get LlStgsysStorageConvert sPreviewFile sTargetFile sFormat to iRet  // Convert the File directly
            Function_Return iRet
        End
        
        If (hExternStg=0) Begin
            Move (LlStgsysStorageOpen(Self,sPreviewFile,(psTempPath(Self)),True,False)) to iStg
            If (iStg<0) ;
                Function_Return iStg
        End    
        Else Begin
            Move hExternStg to iStg
        End
        
        Move (LsConversionJobOpen(Self,sFormat)) to iConversion
        If (iConversion<0) Begin
            If (hExternStg=0) ;
                Move (LlStgsysStorageClose(Self,iStg)) to iStg
            Function_Return iConversion
        End
        If (iWithOptions) Begin
            //If (sFormat="PDF") Begin
            //    Move (LsConversionSetOptionString(Self,iConversion,"PDF.FontMode","1")) to iRet
            //End
            Move (LsConversionConfigurationDlg(Self,iConversion)) to iRet
            If (iRet <> 0) Begin
                Move (LsConversionJobClose(Self,iConversion)) to iConversion
                If (hExternStg=0) ;
                    Move (LlStgsysStorageClose(Self,iStg)) to iStg
                Function_Return iRet            
            End
        End
        Else Begin
            If (sFormat="PDF") Begin
                Move (LsConversionSetOptionString(Self,iConversion,"PDF.Title","")) to iRet
                Move (LsConversionSetOptionString(Self,iConversion,"PDF.Subject","")) to iRet
                Move (LsConversionSetOptionString(Self,iConversion,"PDF.Keywords","")) to iRet
                Move (LsConversionSetOptionString(Self,iConversion,"PDF.Encryption.EncryptFile","0")) to iRet
            End
        End
        If (Num_arguments>4) Begin
            If (iFromPage <> 0) Begin
                Move (LsConversionSetOptionString(Self,iConversion,"Export.PageIndexRange.Min",(String(iFromPage)))) to iRet
            End
            If (iToPage <> 0) Begin
                Move (LsConversionSetOptionString(Self,iConversion,"Export.PageIndexRange.Max",(String(iToPage)))) to iRet
            End    
        End    
        Move (LsConversionConvertStgToFile(Self,iConversion,iStg,sTargetFile)) to iRet
        Move (LsConversionJobClose(Self,iConversion)) to iConversion
        If (hExternStg=0) Begin
            Move (LlStgsysStorageClose(Self,iStg)) to iStg
        End    
        Function_Return iRet
    End_Function    
    #ENDIF

    

    
    // Functions for Sending Mails
    #IF (!@>199)
    Function LsMailJobOpen Integer iLanguage Returns Longptr
        Function_Return (LsMailJobOpenEf(iLanguage))
    End_Function
    
    Function LsMailSetOptionString Longptr iMailJob String sKey String sVal Returns Integer
        Function_Return (LsMailSetOptionStringEf(iMailJob,sKey,sVal)) 
    End_Function
    
    Function LsMailSendFile Longptr iMailJob Handle hWndParent Returns Integer
        Function_Return (LsMailSendFileEf(iMailJob,hWndParent))
    End_Function
    
    Function LsMailJobClose Longptr iMailJob Returns Integer
        Function_Return (LsMailJobCloseEf(iMailJob))
    End_Function
    
    // Function for simple sending a Mail.
    // Multiple Attachments and multiple Recipients can be separated with ";"
    // If iParentWindow=0 the Mail is sent without User Interaction
    Function SendLLMail String sSubject String sBody String sTo String sCC String sBcc String sAttachments Integer iParentWindow Returns Integer
        Longptr hMailJob
        Integer iRet iReturn
        
        Get LsMailJobOpen (piUseLanguage(Self)) to hMailJob
        If (hMailJob=0) ;
            Function_Return 0
        
        Get LsMailSetOptionString hMailJob "Export.Mail.Subject" sSubject to iRet
        Get LsMailSetOptionString hMailJob "Export.Mail.Body" sBody to iRet
        Get LsMailSetOptionString hMailJob "Export.Mail.To" sTo to iRet
        Get LsMailSetOptionString hMailJob "Export.Mail.CC" sCC to iRet
        Get LsMailSetOptionString hMailJob "Export.Mail.BCC" sBcc to iRet
        Move (Replaces(";",sAttachments,(Character(9)))) to sAttachments
        Get LsMailSetOptionString hMailJob "Export.Mail.AttachmentList" sAttachments to iRet
        Get LsMailSendFile hMailJob iParentWindow to iReturn
        Get LsMailJobClose hMailJob to iRet
        Function_Return iReturn
    End_Function
    
    Function LsMailConfigurationDialog Handle hWndParent String sSubKey Integer nFlags Integer nLanguage Returns Integer
        Function_Return (LsMailConfigurationDialogEf(hWndParent,sSubKey,nFlags,nLanguage))
    End_Function
    
    Function DisplayMailConfigurationDialog Returns Integer
        Handle hWnd
        String sApp
        Integer iRet
        
        Get SuggestedParentWindowHandle (Self) to hWnd
        #IFDEF ghoApplication
        If (ghoApplication<>0) Begin
            Get GetApplicationName of ghoApplication to sApp
        End
        #ENDIF
        If (sApp="") ;
            Move "DEFAULT" to sApp
        Move (LsMailConfigurationDialog(Self,hWnd,sApp,(LS_MAILCONFIG_USER ior LS_MAILCONFIG_GLOBAL ior LS_MAILCONFIG_PROVIDER), (piUseLanguage(Self)))) to iRet
        Function_Return iRet
    End_Function    
    #ELSE
    Function LsMailJobOpen Integer iLanguage Returns Integer
        Function_Return (LsMailJobOpenEf(iLanguage))
    End_Function
    
    Function LsMailSetOptionString Integer iMailJob String sKey String sVal Returns Integer
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Integer iRet
        
        Move (sKey + (Character(0))) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (OemToAnsi(pVar1,pVar1)) to iRet
        Move (sVal + (Character(0))) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (OemToAnsi(pVar2,pVar2)) to iRet
        Function_Return (LsMailSetOptionStringEf(iMailJob,pVar1,pVar2)) 
    End_Function
    
    Function LsMailSendFile Integer iMailJob Handle hWndParent Returns Integer
        // Removed this because it was no longer possible to send a Mail without User Interaction as described in the Documentation
        // 9.3.2016 BP
        //If (hWndParent=0) Begin
        //    Get SuggestedParentWindowHandle (Self) to hWndParent
        //End        
        Function_Return (LsMailSendFileEf(iMailJob,hWndParent))
    End_Function
    
    Function LsMailJobClose Integer iMailJob Returns Integer
        Function_Return (LsMailJobCloseEf(iMailJob))
    End_Function
    
    // Function for simple sending a Mail.
    // Multiple Attachments and multiple Recipients can be separated with ";"
    // If iParentWindow=0 the Mail is sent without User Interaction
    Function SendLLMail String sSubject String sBody String sTo String sCC String sBcc String sAttachments Integer iParentWindow Returns Integer
        Integer hMailJob iRet iReturn
        
        Get LsMailJobOpen (piUseLanguage(self)) to hMailJob
        If (hMailJob=0) ;
            Function_Return 0
        
        Get LsMailSetOptionString hMailJob "Export.Mail.Subject" sSubject to iRet
        Get LsMailSetOptionString hMailJob "Export.Mail.Body" sBody to iRet
        Get LsMailSetOptionString hMailJob "Export.Mail.To" sTo to iRet
        Get LsMailSetOptionString hMailJob "Export.Mail.CC" sCC to iRet
        Get LsMailSetOptionString hMailJob "Export.Mail.BCC" sBcc to iRet
        Move (Replaces(";",sAttachments,(Character(9)))) to sAttachments
        Get LsMailSetOptionString hMailJob "Export.Mail.AttachmentList" sAttachments to iRet
        Get LsMailSendFile hMailJob iParentWindow to iReturn
        Get LsMailJobClose hMailJob to iRet
        Function_Return iReturn
    End_Function
    
    Function LsMailConfigurationDialog Handle hWndParent String sSubKey Integer nFlags Integer nLanguage Returns Integer
        String sVar1
        Pointer pVar1
        Integer iRet
        Move (ToAnsiStr(Self,sSubKey)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (LsMailConfigurationDialogEf(hWndParent,pVar1,nFlags,nLanguage)) to iRet
        Function_Return iRet
    End_Function
    
    Function DisplayMailConfigurationDialog Returns Integer
        Handle hWnd
        String sApp
        Integer iRet
        
        Get SuggestedParentWindowHandle (Self) to hWnd
        #IFDEF ghoApplication
        If (ghoApplication<>0) Begin
            Get GetApplicationName of ghoApplication to sApp
        End
        #ENDIF
        If (sApp="") ;
            Move "DEFAULT" to sApp
        Move (LsMailConfigurationDialog(Self,hWnd,sApp,(LS_MAILCONFIG_USER ior LS_MAILCONFIG_GLOBAL ior LS_MAILCONFIG_PROVIDER), (piUseLanguage(Self)))) to iRet
        Function_Return iRet
    End_Function
    #ENDIF
    
    // Functions to handle the standalone RTF Editor from List & Label.
    // Take a look at the sample to see how it works.
    
    Function LlRTFCreateObject Returns Handle
        Handle hRtf
        If (phRtfObjectHandle(Self)<>0) ;
            Function_Return (phRtfObjectHandle(Self))
        Move (LlRtfCreateObjectEf(piJobNumber(self))) to hRtf
        If (hRtf) ;
            Set phRtfObjectHandle to hRtf
        Else ;
            Set phRtfObjectHandle to 0
        Function_Return hRtf
    End_Function
    
    Function LlRTFDeleteObject Returns Integer
        Integer iRet
        If (phRtfObjectHandle(Self)=0) ;
            Function_Return 1
        Move (LlRtfDeleteObjectEf(piJobNumber(self),(phRtfObjectHandle(self)))) to iRet
        Set phRtfObjectHandle to 0
        Function_Return iRet
    End_Function
    
    Function LlRTFSetText String sText Returns Integer
        String sVar1
        Pointer pVar1
        Integer iRet
        If (phRtfObjectHandle(Self)=0) ;
            Function_Return 0
        Move (ToAnsiStr(self,sText)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (LlRTFSetTextEf(piJobNumber(self),(phRtfObjectHandle(self)),pVar1)) to iRet
        Function_Return iRet
    End_Function
    
    Function LlRTFGetTextLength Integer nFlags Returns Integer
        If (phRtfObjectHandle(Self)=0) ;
            Function_Return 0
        Function_Return (LlRTFGetTextLengthEf(piJobNumber(self),(phRtfObjectHandle(self)),nFlags))
    End_Function
    
    Function LlRTFGetText Integer nFlags Returns String
        String sVar
        Pointer pVar
        Integer iLen iArgSize iRet
        
        If (phRtfObjectHandle(Self)=0) ;
            Function_Return ""
        Move (LlRTFGetTextLength(self,nFlags)) to iLen
        If (iLen<=0) ;
            Function_Return ""
        Move (iLen + 1) to iLen
        get_argument_size to iArgSize
        If (iLen>iArgSize) ;
            Function_Return ""
        #IF (!@>199)
        WString wVar
        Move (Repeat(Character(0),iLen)) to wVar
        Move (LlRtfGetTextEf(piJobNumber(Self),(phRtfObjectHandle(Self)),nFlags,AddressOf(wVar),iLen*2)) to iRet
        If (iRet>=0) Begin
            Move (CString(wVar)) to sVar
            Function_Return sVar
        End
        #ELSE
        Move (LLZeroString(iLen)) to sVar
        Move (AddressOf(sVar)) to pVar
        Move (LlRtfGetTextEf(piJobNumber(self),(phRtfObjectHandle(self)),nFlags,pVar,iLen)) to iRet
        If (iRet>=0) Begin
            Move (AnsiToOem(pVar,pVar)) to iRet
            Function_Return (cString(sVar))            
        End
        #ENDIF
        Function_Return ""
    End_Function
    
    Function LLRTFEditObject Handle hWnd Integer iType Returns Integer
        Function_Return (LLRtfEditObjectEf(piJobNumber(Self),(phRtfObjectHandle(Self)),hWnd,0,iType,True)) 
    End_Function
    
    Function LLGetErrorText Integer iError Returns String
        #IF !@>199
        WString wVar
        Integer iRet
        Move (Repeat(Character(0),2048)) to wVar
        Move (LlGetErrortextEf(iError,AddressOf(wVar),4096)) to iRet
        Function_Return (CString(wVar))
        #ELSE
        String sVar
        Pointer pVar
        Integer iRet
        
        Move (LLZeroString(2048)) to sVar
        Move (AddressOf(sVar)) to pVar
        Move (LLGetErrorTextEf(iError,pVar,2048)) to iRet
        If (iRet<0) ;
            Function_Return ""
        Move (AnsiToOem(pVar,pVar)) to iRet
        Move (cString(sVar)) to sVar
        Function_Return sVar
        #ENDIF
    End_Function
    
    Function LLSetDefaultProjectParameter String sParameter String sValue Integer iFlags Returns Integer
        #IF (!@>199)
        Function_Return (LLSetDefaultProjectParameterEf(piJobNumber(Self),sParameter,sValue,iFlags))
        #ELSE
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Integer iRet
        
        Move (sParameter+(Character(0))) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (OemToAnsi(pVar1,pVar1)) to iRet
        
        Move (sValue+(Character(0))) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (OemToAnsi(pVar2,pVar2)) to iRet
        
        Move (LLSetDefaultProjectParameterEf(piJobNumber(self),pVar1,pVar2,iFlags)) to iRet
        Function_Return iRet
        #ENDIF
    End_Function
    
    Function LLGetDefaultProjectParameter String sParameter Returns String
        #IF (!@>199)
        WString wVar
        String sVal
        Integer iRet
        Move (Repeat(Character(0),1024)) to wVar
        Move (LlGetDefaultProjectParameterEf(piJobNumber(Self),sParameter,AddressOf(wVar),2048,0)) to iRet
        Move (CString(wVar)) to sVal
        Function_Return sVal
        #ELSE
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Integer iRet
        
        Move (sParameter + (Character(0))) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (OemToAnsi(pVar1,pVar1)) to iRet
        
        Move (LLZeroString(1024)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (LlGetDefaultProjectParameterEf(piJobNumber(self),pVar1,pVar2,1024,0)) to iRet
        Move (AnsiToOem(pVar2,pVar2)) to iRet
        Function_Return (cString(sVar2))
        #ENDIF
    End_Function
    
    Function LLPrintSetProjectParameter String sParameter String sValue Integer iFlags Returns Integer
        #IF (!@>199)
        Function_Return (LlPrintSetProjectParameterEf(piJobNumber(Self),sParameter,sValue,iFlags))
        #ELSE
        String sVar1 sVar2 
        Pointer pVar1 pVar2 
        Integer iRet
        
        Move (sParameter + (Character(0))) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (OemToAnsi(pVar1,pVar1)) to iRet
        
        Move (sValue + (Character(0))) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (OemToAnsi(pVar2,pVar2)) to iRet        
        
        Move (LlPrintSetProjectParameterEf(piJobNumber(self),pVar1,pVar2,iFlags)) to iRet
        Function_Return iRet
        #ENDIF
    End_Function
    
    Function LLPrintGetProjectParameter String sParameter Integer bEvaluated Returns String
        #IF (!@>199)
        WString wVar
        String sVal
        Integer iRet iFlags
        Move (Repeat(Character(0),2048)) to wVar
        Move 0 to iFlags
        Move (LlPrintGetProjectParameterEf(piJobNumber(Self),sParameter,bEvaluated,AddressOf(wVar),4096,AddressOf(iFlags))) to iRet
        Move (CString(wVar)) to sVal
        Function_Return sVal
        #ELSE
        String sVar1 sVar2
        Pointer pVar1 pVar2 pVar3
        Integer iRet iFlags
        
        Move (sParameter + (Character(0))) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (OemToAnsi(pVar1,pVar1)) to iRet
        Move (LLZeroString(2048)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        
        Move 0 to iFlags
        Move (AddressOf(iFlags)) to pVar3
        
        Move (LlPrintGetProjectParameterEf(piJobNumber(self),pVar1,bEvaluated,pVar2,2048,pVar3)) to iRet
        Move (AnsiToOem(pVar2,pVar2)) to iRet
        Function_Return (CString(sVar2))
        #ENDIF
    End_Function
    
    Function LLGetProjectParameter String sProjectName String sParameter Returns String
        #IF !@>199
        Integer iRet
        WString wVar
        Move (Repeat(Character(0),2048)) to wVar
        Move (LlGetProjectParameterEf(piJobNumber(Self),sProjectName,sParameter,AddressOf(wVar),4096)) to iRet
        Function_Return (CString(wVar))
        #ELSE
        String sVar1 sVar2 sVar3
        Pointer pVar1 pVar2 pVar3
        Integer iRet
        
        Move (sProjectName + (Character(0))) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (OemToAnsi(pVar1,pVar1)) to iRet
        
        Move (sParameter + (Character(0))) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (OemToAnsi(pVar2,pVar2)) to iRet
        
        Move (LLZeroString(2048)) to sVar3
        Move (AddressOf(sVar3)) to pVar3
        Move (LlGetProjectParameterEf(piJobNumber(self),pVar1,pVar2,pVar3,2048)) to iRet
        Move (AnsiToOem(pVar3,pVar3)) to iRet
        Function_Return (CString(sVar3)) 
        #ENDIF
    End_Function
    
    Function LlLocAddDesignLCID Integer nLCID Returns Integer
        Function_Return (LlLocAddDesignLCIDEf(piJobNumber(Self),nLCID))
    End_Function
    
    Function LlLocAddDictionaryEntry Integer nLCID String sKey String sTranslation Integer iType Returns Integer
        #IF (!@>199)
        Function_Return (LlLocAddDictionaryEntryEf(piJobNumber(Self),nLCID,sKey,sTranslation, iType))
        #ELSE
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Integer iRet
        
        Move (sKey  + (Character(0))) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move (OemToAnsi(pVar1,pVar1)) to iRet
        
        Move (sTranslation  + (Character(0))) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (OemToAnsi(pVar2,pVar2)) to iRet        
        
        Function_Return (LlLocAddDictionaryEntryEf(piJobNumber(Self),nLCID,pVar1,pVar2, iType))
        #ENDIF
    End_Function
    
    Procedure DoSetPrintLanguage Integer iLcId
        String sVar sVar2
        Integer iRet
        If (iLcId=0) Begin
            Set psPrintLanguage to ""
            Procedure_Return
        End        
        #IF !@>199
        WString wVar wVar2
        Move (Repeat(Character(0),2048)) to wVar
        Move (Repeat(Character(0),2048)) to wVar2
        Move (LLGetLocaleInfoEf(iLcid,89,AddressOf(wVar),4096)) to iRet
        Move (LLGetLocaleInfoEf(iLcid,90,AddressOf(wVar2),4096)) to iRet
        Move ((CString(wVar))+"-"+(CString(wVar2))) to sVar
        #ELSE        
        Pointer pVar pVar2

        Move (Repeat(Character(0),255)) to sVar
        Move (AddressOf(sVar)) to pVar
        
        Move (LLGetLocaleInfoEf(iLcid,89,pVar,255)) to iRet
        
        Move (AnsiToOem(pVar,pVar)) to iRet
        Move (CString(sVar)) to sVar
        
        Move (Repeat(Character(0),255)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        
        Move (LLGetLocaleInfoEf(iLcid,90,pVar2,255)) to iRet
        
        Move (AnsiToOem(pVar2,pVar2)) to iRet
        Move (CString(sVar2)) to sVar2
        
        Move (sVar+"-"+sVar2) to sVar
        
        #ENDIF
        Set psPrintLanguage to sVar
    End_Procedure
    
    Function SuggestedParentWindowHandle Integer iObj Returns Integer
        Integer hoMain
        Handle hWnd
        #IFDEF ghoApplication
        If (ghoApplication<>0) Begin
            Get phoMainPanel of ghoApplication to hoMain
            If (hoMain<>0) Begin
                Get Window_Handle of hoMain to hWnd
            End
        End
        #ENDIF
        If (hWnd=0) Begin
            Get Window_Handle of iObj to hWnd
        End
        Function_Return hWnd
    End_Function    
    
    External_Function LLFindWindowExEf "FindWindowExA" user32.dll Handle hWndParent Handle hWndChildAfter Pointer pClass Pointer pWindowName Returns Integer
    External_Function LLGetMenuEf "GetMenu" user32.dll Handle hWnd Returns Integer
    External_Function LLGetMenuItemCountEf "GetMenuItemCount" user32.dll Integer hMenu Returns Integer
    External_Function LLGetMenuStateEf "GetMenuState" user32.dll Integer hMenu Integer hItem Integer uFlags Returns Integer
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF        
    Procedure DoDisableMenuItems Integer hoMenu Integer bDisable
        Integer iItems iItem iState iRet hoDisabledMenus
        
        If (hoMenu=0) ;
            Procedure_Return
        If (bDisable) Begin
            Get phoDisabledMenus to hoDisabledMenus
            If (hoDisabledMenus<>0) ;
                Procedure_Return
            Move (LLGetMenuItemCountEf(hoMenu)) to iItems
            If (iItems=0) ;
                Procedure_Return
            Object oDisabledMenus is a Array
                Move (self) to hoDisabledMenus
            End_Object
            Set phoDisabledMenus to hoDisabledMenus
            FOR iItem From 0 to (iItems-1)
                Move (LLGetMenuStateEf(hoMenu,iItem,MF_BYPOSITION)) to iState
                If (iState<>-1) Begin
                    Move (low(iState)) to iState
                    If (Not(iState Iand MF_DISABLED)) Begin
                        Move (EnableMenuItemEf(hoMenu,iItem,(MF_BYPOSITION Ior MF_DISABLED))) to iRet
                        Set value Of hoDisabledMenus (item_count(hoDisabledMenus)) to iItem 
                    End
                End
            Loop
        End
        Else Begin
            Get phoDisabledMenus to hoDisabledMenus
            If (hoDisabledMenus=0) ;
                Procedure_Return
            FOR iItems From 0 to (Item_count(hoDisabledMenus)-1)
                Get value of hoDisabledMenus iItems to iItem
                Move (EnableMenuItemEf(hoMenu,iItem,(MF_BYPOSITION Ior MF_ENABLED))) to iRet
            Loop
            Send delete_data to hoDisabledMenus
            Send destroy_object to hoDisabledMenus
            Set phoDisabledMenus to 0
        End
    End_Procedure
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF    
    Procedure DoDisableCodejock Integer bDisable
        #IFDEF U_cCJCommandBarSystem
        Integer iAction
        Variant vObj
        Handle[] hoActions hoDisabled
        If (ghoCommandBars<>0) Begin
            If (bDisable) Begin
                Get phoDisabledCodejockActions to hoDisabled
                If (SizeOfArray(hoDisabled)<>0) ;
                    Procedure_Return
                Get phoRegisteredActions Of ghoCommandBars to hoActions
                FOR iAction From 0 to (SizeOfArray(hoActions)-1)
                    If (hoActions[iAction]<>0) Begin
                        If (pbEnabled(hoActions[iAction])) Begin
                            Set pbEnabled Of hoActions[iAction] to False
                            Move hoActions[iAction] to hoDisabled[(SizeOfArray(hoDisabled))]
                        End
                    End
                Loop
                Set phoDisabledCodejockActions to hoDisabled
            End
            Else Begin
                Get phoDisabledCodejockActions to hoDisabled
                FOR iAction From 0 to (SizeOfArray(hoDisabled)-1)
                    Set pbEnabled Of hoDisabled[iAction] to True
                Loop
                Move (ResizeArray(hoDisabled,0)) to hoDisabled
                Set phoDisabledCodejockActions to hoDisabled
            End
        End
        #ENDIF
    End_Procedure    
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF    
    Procedure DoDisableOtherWindows Integer bDisable
        #IFNDEF Is$WebApp
        Handle hoMainWindow hoClientArea hoPreviewWindow hoObj hWnd hWndParent hoDisabledWindows hMenu hWndCancel hWndPreview
        Integer iRet iCou iStyle
        
        If (piEmbeddedPreviewObjectInt(Self)<>0) Begin
            Get Find_Scope of (piEmbeddedPreviewObjectInt(Self)) to hoPreviewWindow
        End
        Else Begin
            Get object_id of (piPreviewPanel(Self)) to hoPreviewWindow
        End
        If (hoPreviewWindow=0) ;
            Procedure_Return
        Move 0 to hoMainWindow
        Move hoPreviewWindow to hoObj
        While ( (hoMainWindow=0) And (hoObj<>0) )
            If (parent(hoObj)=desktop) Begin
                Move (hoObj) to hoMainWindow
            End
            Else Begin
                Move (parent(hoObj)) to hoObj
            End
        Loop        
        If (hoMainWindow<>0) Begin
            Get window_handle Of hoMainWindow to hWndParent
            Move (LLGetMenuEf(hwndParent)) to hMenu
            If (hMenu<>0) Begin
                Send DoDisableMenuItems hMenu bDisable
            End
            Send DoDisableCodejock bDisable
        End
        
        If (not(bDisable)) Begin
            If (phoEnabledForModal(Self)<>0) Begin
                Move (GetWindowLong(Window_Handle(phoEnabledForModal(Self)),GWL_STYLE)) to iStyle
                Move (iStyle ior WS_DISABLED) to iStyle
                Move (SetWindowLong(Window_Handle(phoEnabledForModal(Self)),GWL_STYLE,iStyle)) to iStyle
                Set phoEnabledForModal to 0
            End
            Get phoDisabledWindows to hoDisabledWindows
            If (hoDisabledWindows=0) ;
                Procedure_Return
            FOR iCou From 0 to (item_count(hoDisabledWindows)-1)
                Get value Of hoDisabledWindows iCou to hWnd
                If (hWnd<>0) Begin
                    Move (EnableWindow(hWnd,True)) to iRet
                End
            Loop
            Send delete_data to hoDisabledWindows
            Send destroy_object to hoDisabledWindows
            Set phoDisabledWindows to 0
        End
        Else Begin
            If (hoMainWindow<>0) Begin
                Get phoDisabledWindows to hoDisabledWindows
                If (hoDisabledWindows<>0) ;
                    Procedure_Return
                Object oDisabledWindows is a Array
                    Move (self) to hoDisabledWindows
                End_Object
                Set phoDisabledWindows to hoDisabledWindows
                If (current_modal_object<>0) Begin
                    Get window_handle Of current_modal_object to hWnd
                    If ( (hWnd<>0) And (hWnd<>window_handle(hoPreviewWindow)) ) Begin
                        If (LLIsWindowEnabledEf(hWnd)) Begin
                            Set value of hoDisabledWindows (item_count(hoDisabledWindows)) to hWnd
                            Move (EnableWindow(hWnd,False)) to iRet                            
                        End
                    End
                    Move (GetWindowLong(Window_Handle(hoMainWindow),GWL_STYLE)) to iStyle
                    If (iStyle iand WS_DISABLED) Begin
                        Move (iStyle - WS_DISABLED) to iStyle
                        Move (SetWindowLong(Window_Handle(hoMainWindow),GWL_STYLE,iStyle)) to iStyle
                        Set phoEnabledForModal to hoMainWindow
                    End
                End
                Get client_id Of hoMainWindow to hoClientArea
                Move (LLFindWindowExEf(hWndParent,0,0,0)) to hWnd
                While (hWnd<>0)
                    If ( (hoClientArea=0) Or ( (hoClientArea<>0) And (hWnd<>(window_handle(hoClientArea)))) ) Begin
                        If (hWnd<>window_handle(hoPreviewWindow)) Begin
                            If (LLIsWindowEnabledEf(hWnd)) Begin
                                Set value of hoDisabledWindows (item_count(hoDisabledWindows)) to hWnd
                                Move (EnableWindow(hWnd,False)) to iRet
                            End
                        End
                    End
                    Move (LLFindWindowExEf(hWndParent,hWnd,0,0)) to hWnd
                Loop
                If (hoClientArea<>0) Begin
                    Get window_handle Of hoClientArea to hWndParent
                    Move 0 to hWnd
                    Move (LLFindWindowExEf(hWndParent,0,0,0)) to hWnd
                    While (hWnd<>0)
                        If (hWnd<>(window_handle(hoClientArea))) Begin
                            If (hWnd<>window_handle(hoPreviewWindow)) Begin
                                If (LLIsWindowEnabledEf(hWnd)) Begin
                                    Set value of hoDisabledWindows (item_count(hoDisabledWindows)) to hWnd
                                    Move (EnableWindow(hWnd,False)) to iRet
                                End
                            End
                        End
                        Move (LLFindWindowExEf(hWndParent,hWnd,0,0)) to hWnd
                    Loop
                End
                If (piEmbeddedPreviewObjectInt(Self)<>0) Begin
                    Get Window_Handle of (piEmbeddedPreviewObjectInt(Self)) to hWndPreview
                    If (piEmbeddedPreviewCancelBtn(Self)<>0) begin
                        Get Window_Handle of (piEmbeddedPreviewCancelBtn(Self)) to hWndCancel
                    End
                    Get window_handle of hoPreviewWindow to hWndParent
                    Move (LLFindWindowExEf(hWndParent,0,0,0)) to hWnd
                    While (hWnd<>0)
                        If ( (hWnd<>hWndPreview) and (hWnd<>hWndCancel) ) Begin
                            If (LLIsWindowEnabledEf(hWnd)) Begin
                                Set value of hoDisabledWindows (item_count(hoDisabledWindows)) to hWnd
                                Move (EnableWindow(hWnd,False)) to iRet
                            End
                        End
                        Move (LLFindWindowExEf(hWndParent,hWnd,0,0)) to hWnd
                    Loop
                End
            End
        End
        #ENDIF
    End_Procedure
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF    
    Procedure DoCheckPreviewPanelBeforePrint
        #IFNDEF Is$WebApp
        Integer iDest
        Integer iRet iObj iMain
        Handle hWnd hoObj
        Set psPreviewOriginalLabel to ""
        If (piEmbeddedPreviewObjectInt(Self)<>0) Begin
            If  ( (pbIncrementalPreview(Self)) and (not(pbIsDrilldown(Self))) and (not(pbReportIsInteractiveRequest(Self))) ) Begin
                Get LLPrintGetOption LL_PRNOPT_PRINTDLG_DEST to iDest
                If (iDest=LL_DESTINATION_PRV) Begin
                    Get Find_Scope of (piEmbeddedPreviewObjectInt(Self)) to hoObj
                    If (hoObj<>0) Begin
                        Set psPreviewOriginalLabel to (label(hoObj))
                    End
                    Get object_id of (piEmbeddedPreviewObjectInt(Self)) to iObj
                    Send OnBeforeIncrementalPreviewStart to iObj (Self)
                    Set phoFocusBeforePrint to (focus(desktop))
                    Send DoDisableOtherWindows True
                    Get key_path of (Find_Scope(iObj)) to iRet
                    Set piOriginalKeyPath to iRet
                    Set key_path of (find_scope(iObj)) to (desktop)
                    Set Key_Path of (piEmbeddedPreviewObjectInt(Self)) to (Desktop)
                    If (piEmbeddedPreviewCancelBtn(Self)<>0) Begin
                        Set Key_Path of (piEmbeddedPreviewCancelBtn(Self)) to (Desktop)
                    End
                    Get window_handle of (piEmbeddedPreviewObjectInt(Self)) to hWnd
                    Set piAssociatedLLObj of (piEmbeddedPreviewObjectInt(Self)) to (Self)
                    Set pbPreviewRunning of (piEmbeddedPreviewObjectInt(Self)) to True
                    Set piObjectAssociatedToLLObj of (piEmbeddedPreviewObjectInt(Self)) to (Self)
                    Get LLAssociatePreviewControl hWnd (LL_ASSOCIATEPREVIEWCONTROLFLAG_DELETE_ON_CLOSE) to iRet
                    Send OnIncrementalPreviewStart to (piEmbeddedPreviewObjectInt(Self)) (Self)
                End
            End
            Procedure_Return
        End
        If ( (piPreviewPanel(Self)<>0) and (piPreviewObject(Self)<>0) and (pbIncrementalPreview(Self)) and (not(pbIsDrilldown(Self))) and (not(pbReportIsInteractiveRequest(Self))) ) Begin
            Get LLPrintGetOption LL_PRNOPT_PRINTDLG_DEST to iDest
            If (iDest=LL_DESTINATION_PRV) Begin
                //If (Not(active_state(piPreviewPanel(self)))) Begin
                    Get object_id Of (piPreviewObject(self)) to iObj
                    Send OnBeforeIncrementalPreviewStart to iObj (self)
                    Set phoFocusBeforePrint to (focus(desktop))
                    Get object_id Of (piPreviewPanel(self)) to iObj
                    Set popup_state Of iObj to True 
                    If (current_modal_object<>0) Begin
                        Set visible_state of (current_modal_object) to False
                    End
                    If (Not(active_state(piPreviewPanel(self)))) Begin
                        Send Popup to iObj
                    End
                    Send DoDisableOtherWindows True
                    Get key_path Of iObj to iRet
                    Set piOriginalKeyPath to iRet
                    Set key_path of iObj to (desktop)
                    Get window_handle Of (piPreviewObject(self)) to hWnd
                    If (hWnd<>0) Begin
                        Set psPreviewOriginalLabel to (label(piPreviewPanel(self)))
                        Set piAssociatedLLObj Of (piPreviewObject(self)) to (self)
                        Set pbPreviewRunning of (piPreviewObject(Self)) to True
                        Set piObjectAssociatedToLLObj of (piPreviewObject(Self)) to (Self)
                        Get LLAssociatePreviewControl hWnd 0 to iRet
                        Send OnIncrementalPreviewStart to (piPreviewObject(self)) (self)
                    End    
                //End    
            End
        End
        #ENDIF
    End_Procedure
    
    // DOM Objects handling routines
    
    Function LLProjectOpen Integer iType String sFile Integer iOpenMode Returns Integer
        String sVar
        Pointer pVar
        Integer iRet

        Set piProjectType to iType
        If (psCurrentProjectFile(Self)<>sFile) ;
            Set pbDefinesNeeded to True
        Set psCurrentProjectFile to sFile
        #IF (!@>109)
        tAliasDb[] sAllFields
        #ENDIF
        If (not(iOpenMode iand LL_PRJOPEN_EM_IGNORE_FORMULAERRORS)) Begin
            If ( (not(pbKeepJobOpen(Self))) or (pbDefinesNeeded(Self)) ) Begin
                If (piJobNumber(Self)<>0) Begin
                    #IF (!@>199)
                    Move (LlDbAddTableEf(piJobNumber(Self),"","")) to iRet
                    #ELSE
                    Move (LlDbAddTableEf(piJobNumber(Self),0,0)) to iRet
                    #ENDIF
                End                
                Send delete_data to (oAllFields(Self))
                Send delete_data to (oAllVariables(Self))            
                #IF (!@>109)
                Set paAllAliasFields to sAllFields
                Set paAllAliasVariables to sAllFields
                #ENDIF            
                Set psUsedIdentifiers to ""
                Set psCurrentTable to ""
                Get LLDefineFieldStart to iRet
                Get LLDefineVariableStart to iRet
                Send DefineOneTimeVariables
                Send DefineStandardVariables
                Send DefineAllFields
                Send DefineAllVariables        
                Set pbForceUsedIdentifierIdentification to True
                Set pbDefinesNeeded to False
            End
        End
        #IF !@>199
        Move (LLProjectOpenEf(piJobNumber(Self),iType,sFile,iOpenMode)) to iRet
        #ELSE
        Move (sFile + (Character(0))) to sVar
        Move (AddressOf(sVar)) to pVar
        Move (OemToAnsi(pVar,pVar)) to iRet
        Move (LLProjectOpenEf(piJobNumber(Self),iType,pVar,iOpenMode)) to iRet
        #ENDIF
        Function_Return iRet
    End_Function
    
    Function LLProjectSave String sName Returns Integer
        String sVar
        Pointer pVar
        Integer iRet
        
        #IF !@>199
        Move (LLProjectSaveEf(piJobNumber(Self),sName)) to iRet
        #ELSE
        If (trim(sName)<>"") Begin
            Move (sName + (Character(0))) to sVar
            Move (AddressOf(sVar)) to pVar
            Move (OemToAnsi(pVar,pVar)) to iRet
        End
        Else begin
            Move 0 to pVar
        End
        Move (LLProjectSaveEf(piJobNumber(Self),pVar)) to iRet
        #ENDIF
        Function_Return iRet
    End_Function
    
    Function LLProjectClose Returns Integer
        Integer iRet
        Move (LLProjectCloseEf(piJobNumber(self))) to iRet
        Function_Return iRet 
    End_Function
    
    Function LLDomGetProject Returns Handle
        Integer iObj iRet
        Pointer pObj
        Handle hDom
        
        Move 0 to hDom
        Move (LLDomGetProjectEf(piJobNumber(Self),AddressOf(hDom))) to iRet
        If (iRet<0) ;
            Function_Return iRet
        Function_Return hDom
    End_Function
    
    Function LLDomGetObject Handle hDomObj String sName Returns Handle
        String sVar
        Integer iObj iRet
        Pointer pVar pObj
        Handle hObj
        
        #IF !@>199
        Move 0 to hObj
        Move (LlDomGetObjectEf(hDomObj,sName,AddressOf(hObj))) to iRet
        If (iRet<0) ;
            Function_Return iRet
        Function_Return hObj
        #ELSE
        
        Move (sName + (Character(0))) to sVar
        Move (AddressOf(sVar)) to pVar
        Move (OemToAnsi(pVar,pVar)) to iRet
        
        Move 0 to iObj
        Move (AddressOf(iObj)) to pObj
        
        Move (LLDomGetObjectEf(hDomObj,pVar,pObj)) to iRet
        If (iRet<0) ;
            Function_Return iRet
        Function_Return iObj
        #ENDIF
    End_Function
    
    Function LLDomGetSubobjectCount Handle hDomObj Returns Integer
        Integer iRet iObj
        Pointer pObj
        
        Move 0 to iObj
        Move (AddressOf(iObj)) to pObj
        
        Move (LLDomGetSubObjectCountEf(hDomObj,pObj)) to iRet
        If (iRet<0) ;
            Function_Return iRet
        Function_Return iObj
    End_Function
    
    Function LLDomGetSubobject Handle hDomObj Integer iPosition Returns Handle
        Integer iRet
        Handle hObj
       
        Move 0 to hObj
        Move (LLDomGetSubObjectEf(hDomObj,iPosition,AddressOf(hObj))) to iRet
        If (iRet<0) ;
            Function_Return iRet
        Function_Return hObj
    End_Function
    
    Function LLDomGetProperty Handle hDomObj String sProperty Returns String
        #IF (!@>199)
        WString wVar
        Integer iLen iRet
        String sVar
        Move (LLDomGetPropertyEf(hDomObj,sProperty,0,0)) to iLen
        If (iLen<0) ;
            Function_Return ""        
        Move (Repeat(Character(0),iLen)) to wVar
        Move (LLDomGetPropertyEf(hDomObj,sProperty,AddressOf(wVar),iLen)) to iRet
        If (iRet<0) ;
            Function_Return ""        
        Move (CString(wVar)) to sVar
        Function_Return sVar
        #ELSE
        String sVar sVar2
        Integer iObj iRet iLen
        Pointer pVar pVar2
        
        Move (sProperty + (Character(0))) to sVar
        Move (AddressOf(sVar)) to pVar
        Move (OemToAnsi(pVar,pVar)) to iRet
        
        Move (LLDomGetPropertyEf(hDomObj,pVar,0,0)) to iLen
        If (iLen<0) ;
            Function_Return ""
        Move (LLZeroString(iLen)) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (LLDomGetPropertyEf(hDomObj,pVar,pVar2,iLen)) to iRet
        If (iRet<0) ;
            Function_Return ""
        
        Move (AnsiToOem(pVar2,pVar2)) to iRet
        Move (cString(sVar2)) to sVar2
        
        Function_Return sVar2
        #ENDIF
    End_Function
    
    Function LLDomSetProperty Handle hDomObj String sProperty String sValue Returns Integer
        String sVar sVar2
        Integer iObj iRet iLen
        Pointer pVar pVar2
        
        #IF !@>199
        Move (LlDomSetPropertyEf(hDomObj,sProperty,sValue)) to iRet
        #ELSE
        Move (sProperty + (Character(0))) to sVar
        Move (AddressOf(sVar)) to pVar
        Move (OemToAnsi(pVar,pVar)) to iRet
        
        Move (sValue + (Character(0))) to sVar2
        Move (AddressOf(sVar2)) to pVar2
        Move (OemToAnsi(pVar2,pVar2)) to iRet
        
        Move (LLDomSetPropertyEf(hDomObj,pVar,pVar2)) to iRet
        #ENDIF
        Function_Return iRet
    End_Function    
    
    Function LLDomCreateSubobject Handle hDomObj Integer iPosition String sType Returns Handle
        String sVar
        Pointer pVar pObj
        Integer iRet iObj
        Handle hObj
        #IF !@>199
        Move 0 to hObj
        Move (LLDomCreateSubobjectEf(hDomObj,iPosition,sType,AddressOf(hObj))) to iRet
        If (iRet<0) ;
            Function_Return iRet
        Function_Return hObj
        #ELSE
        Move (sType + (Character(0))) to sVar
        Move (AddressOf(sVar)) to pVar
        Move (OemToAnsi(pVar,pVar)) to iRet
        
        Move 0 to iObj
        Move (AddressOf(iObj)) to pObj
        
        Move (LLDomCreateSubobjectEf(hDomObj,iPosition,pVar,pObj)) to iRet
        If (iRet<0) ;
            Function_Return iRet
        Function_Return iObj
        #ENDIF
    End_Function
    
    Function LLDomDeleteSubobject Handle hDomObj Integer iPosition Returns Integer
        Integer iRet
        Move (LLDomDeleteSubobjectEf(hDomObj,iPosition)) to iRet
        Function_Return iRet
    End_Function
    
    // Function for Filelist Caching because of an DataFlex Issue on repeatedly reading the Filelist with GET_ATTRIBUTE
    Function fFileStruct Integer iFile Returns tDbFile
        tDbFile[] aFiles
        tDbFile aFile
        Integer iField iFirst iIndex iSegment
        
        Get paFilelistCache to aFiles
        If ( (SizeOfArray(aFiles)>iFile) and (aFiles[iFile].iFileNum<>0) ) Begin
            Function_Return aFiles[iFile]
        End
        
        Move iFile to aFile.iFileNum
        Get_Attribute DF_FILE_LOGICAL_NAME of iFile to aFile.sLogicalName
        Get_Attribute DF_FILE_DISPLAY_NAME of iFile to aFile.sDisplayName
        Get_Attribute DF_FILE_IS_SYSTEM_FILE of iFile to aFile.iSystemFile
        Get_Attribute DF_FILE_RECNUM_TABLE of iFile to aFile.iRecnumTable
        Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to aFile.iPrimaryIndex
        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to aFile.iLastIndexNumber
        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to aFile.iNumberFields
        
        If (aFile.iRecnumTable=True)  ;
            Move 0 to iFirst
        Else ;
            Move 1 to iFirst
        For iField from iFirst to aFile.iNumberFields
            Get_Attribute DF_FIELD_NAME of iFile iField to aFile.aFields[iField].sName
            Get_Attribute DF_FIELD_TYPE of iFile iField to aFile.aFields[iField].iType
            Get_Attribute DF_FIELD_INDEX of iFile iField to aFile.aFields[iField].iIndex
            Get_Attribute DF_FIELD_RELATED_FILE of iFile iField to aFile.aFields[iField].iRelatedFile
            Get_Attribute DF_FIELD_RELATED_FIELD of iFile iField to aFile.aFields[iField].iRelatedField
        Loop
        For iIndex from iFirst to aFile.iLastIndexNumber
            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to aFile.aIndexes[iIndex].iSegments
            If (aFile.aIndexes[iIndex].iSegments<>0) Begin
                For iSegment from 1 to aFile.aIndexes[iIndex].iSegments
                    Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to aFile.aIndexes[iIndex].aSegments[iSegment].iField
                Loop
            End
        Loop
        
        Move aFile to aFiles[iFile]
        Set paFilelistCache to aFiles
        
        Function_Return aFile
    End_Function
    
    Procedure DoFillFilelistCache
        Integer iFile iOpen
        tDbFile aFile
        tDbFile[] aFiles
        Get paFilelistCache to aFiles
        If (SizeOfArray(aFiles)>0) ;
            Procedure_Return
        
        Move 0 to iFile
        Get_Attribute DF_FILE_NEXT_USED of iFile to iFile
        While (iFile<>0)
            Get_Attribute DF_FILE_OPENED of iFile to iOpen
            If (iOpen=True) ;
                Get fFileStruct iFile to aFile
            Get_Attribute DF_FILE_NEXT_USED of iFile to iFile
        Loop
    End_Procedure
    
    
    // Helper Functions for Defining Fields/Variables in List & Label
    
    Function DefineCompleteDb Integer iFile Integer iVariable Returns Integer
        Integer iFields iCou iDFType iLLType iRet iSystemTable iRecnumTable iStatus iMainIndex iFirstField
        String sField sCont sFile
        tDbFile aFile
        
        Get_Attribute DF_FILE_OPENED of iFile to iRet

        If (iRet=DFFALSE) ;
            Open iFile
        
        #IFDEF error_object_id
        //Send ignore_all to Error_Object_Id
        #ELSE
        Send ignore_all to error_info_object
        #ENDIF
        
        Get_Attribute DF_FILE_STATUS of iFile to iStatus
        Get fFileStruct iFile to aFile
        Move aFile.iSystemFile to iSystemTable
        Move aFile.iRecnumTable to iRecnumTable
        #IF (!@>120)
        Move aFile.iPrimaryIndex to iMainIndex
        If (not(iSystemTable)) Begin
            If (iStatus=DF_FILE_INACTIVE) ;
                Vfind iFile iMainIndex 3
        End
        #ENDIF
        Move aFile.sLogicalName to sFile
        Move aFile.iNumberFields to iFields
        If (iRecnumTable=True)  ;
            Move 0 to iFirstField
        Else ;
            Move 1 to iFirstField  
        For iCou from iFirstField to iFields
            Move aFile.aFields[iCou].sName to sField
            Get_Field_Value iFile iCou to sCont
            If (piTrimDbValues(Self)) ;
                Move (trim(sCont)) to sCont
            Move (sFile + "." + sField) to sField
            Move aFile.aFields[iCou].iType to iDFType

            Move -1 to iLLType

            If (iDFType=DF_DATE) ;
                Move (piDateFormat(Self)) to iLLType
            If (iDFType=DF_BCD) ;
                Move LL_NUMERIC to iLLType
            If (iLLType=-1) ;
                Move LL_TEXT to iLLType
            
            If ( (psUsedIdentifiers(self)="") Or ((Pos((";"+uppercase(sField)+";"),(psUsedIdentifiers(self)))<>0)) ) Begin
                If (iVariable) Begin
                    Get LLDefineVariableExt sField sCont iLLType to iRet
                    Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sField + ":DB"+(String(iFile))+","+(String(iCou))+","+(String(iLLType)))
                End
                Else Begin
                    Get LLDefineFieldExt sField sCont iLLType to iRet
                    Set array_value of (oAllFields(Self)) (item_count(oAllFields(Self))) to (sField + ":DB"+(String(iFile))+","+(String(iCou))+","+(String(iLLType)))
                End
            End    
        Loop

        If (not(iSystemTable)) Begin
            If (iStatus=DF_FILE_INACTIVE) ;
                Clear iFile
        End        
        #IFDEF error_object_id
        //Send Trap_All to Error_Object_Id
        #ELSE
        Send trap_all to error_info_object
        #ENDIF
        Function_Return 0
    End_Function
    
    Function DefineAliasDb Integer iFile String sAlias Integer iVariable Returns Integer
        #IF (!@>109)
        Integer iFields iCou iDFType iLLType iRet iNewArrayIndex iSystemTable iStatus iMainIndex
        String sField sCont sFile sFieldName
        tAliasDb[] sAllFields
        tAliasDb sAliasFile
        tAliasDbField sAliasField
        tDbFile aFile
        
        Get_Attribute DF_FILE_OPENED Of iFile to iRet

        If (iRet=DFFALSE) ;
            Open iFile
        
        If (iVariable) Begin
            Get paAllAliasVariables to sAllFields
        End
        Else Begin
            Get paAllAliasFields to sAllFields
        End
        
        Move (SizeOfArray(sAllFields)) to iNewArrayIndex
        #IFDEF error_object_id
        //Send Ignore_All to Error_Object_Id
        #ELSE 
        Send ignore_all to error_info_object
        #ENDIF
        
        Get_Attribute DF_FILE_STATUS of iFile to iStatus
        Get fFileStruct iFile to aFile
        Move aFile.iSystemFile to iSystemTable
        #IF (!@>120)
        Move aFile.iPrimaryIndex to iMainIndex
        If (not(iSystemTable)) Begin
            If (iStatus=DF_FILE_INACTIVE) ;
                Vfind iFile iMainIndex 3
        End
        #ENDIF
        Move aFile.sLogicalName to sFile
        Move aFile.iNumberFields to iFields
        For iCou from 0 to iFields
            Move aFile.aFields[iCou].sName to sField
            Move sField to sFieldName
            get_field_value iFile iCou to sCont
            If (piTrimDbValues(Self)) ;
                Move (trim(sCont)) to sCont
            Move (sAlias + "." + sField) to sField
            Move aFile.aFields[iCou].iType to iDFType

            Move -1 to iLLType

            If (iDFType=DF_DATE) ;
                Move (piDateFormat(Self)) to iLLType
            If (iDFType=DF_BCD) ;
                Move LL_NUMERIC to iLLType
            If (iLLType=-1) ;
                Move LL_TEXT to iLLType
            
            If ( (psUsedIdentifiers(self)="") Or ((Pos((";"+uppercase(sField)+";"),(psUsedIdentifiers(self)))<>0)) ) Begin
                If (iVariable) Begin
                    Get LLDefineVariableExt sField sCont iLLType to iRet
                    //Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sField + ":DB"+(String(iFile))+","+(String(iCou))+","+(String(iLLType)))
                End
                Else Begin
                    Get LLDefineFieldExt sField sCont iLLType to iRet
                    //Set array_value Of (oAllFields(self)) (item_count(oAllFields(self))) to (sField + ":DB"+(String(iFile))+","+(String(iCou))+","+(String(iLLType)))
                End
                Move sFieldName to sAliasField.sField
                Move iFile to sAliasField.iFile
                Move iCou to sAliasField.iField
                Move iLLType to sAliasField.iType
                Move sAlias to sAliasFile.sAliasName
                Move sAliasField to sAliasFile.sFields[(SizeOfArray(sAliasFile.sFields))]
                Move sAliasFile to sAllFields[(SizeOfArray(sAllFields))] 
            End    
        Loop
        
        If (not(iSystemTable)) Begin
            If (iStatus=DF_FILE_INACTIVE) ;
                Clear iFile
        End        
        #IFDEF error_object_id
        //Send Trap_All to Error_Object_Id
        #ELSE
        Send trap_all to error_info_object
        #ENDIF
        If (iVariable) Begin
            Set paAllAliasVariables to sAllFields
        End
        Else Begin
            Set paAllAliasFields to sAllFields
        End        
        #ENDIF
        Function_Return 0
    End_Function    
    
    Function DefineSingleDb Integer iFile Integer iField Integer iVariable Returns Integer
        String sCont sFileName sFieldName sVar sField
        Integer iRet iFields iCou iDFType iLLType
        tDbFile aFile
        
        Get_Attribute DF_FILE_OPENED Of iFile to iRet

        If (iRet=DFFALSE) ;
            Open iFile        
        
        Get fFileStruct iFile to aFile
        Move aFile.sLogicalName to sFileName
        Move aFile.aFields[iField].sName to sFieldName
        Move (sFileName + "." + sFieldName) to sField

        Move aFile.aFields[iField].iType to iDFType

        Move -1 to iLLType

        If (iDFType=DF_DATE) ;
            Move (piDateFormat(Self)) to iLLType
        If (iDFType=DF_BCD) ;
            Move LL_NUMERIC to iLLType
        If (iLLType=-1) ;
            Move LL_TEXT to iLLType
        
        get_field_value iFile iField to sCont
        If (piTrimDbValues(Self)) ;
            Move (trim(sCont)) to sCont
        
        If ( (psUsedIdentifiers(self)="") Or ((Pos((";"+uppercase(sField)+";"),(psUsedIdentifiers(self)))<>0)) ) Begin
            If (iVariable) Begin
                Get LLDefineVariableExt sField sCont iLLType to iRet
                Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sField + ":DB"+(String(iFile))+","+(String(iCou))+","+(String(iLLType)))
            End
            Else Begin
                Get LLDefineFieldExt sField sCont iLLType to iRet
                Set array_value of (oAllFields(Self)) (item_count(oAllFields(Self))) to (sField + ":DB"+(String(iFile))+","+(String(iCou))+","+(String(iLLType)))
            End
        End    

        Function_Return iRet
    End_Function    
    
    // Function for defining a complete DB-File as Variables in List & Label
    // i.E.: get DefineAllDbVariables "Flexerrs" to iRet
    Function DefineAllDbVariables String sFile Returns Integer
        Integer iFile
        Move (eval( (sFile + ".FILE_NUMBER"))) to iFile
        Function_Return (DefineCompleteDB(self,iFile,TRUE))
    End_Function
    
    // Function for defining a complete DB-File as Fields in List & Label
    // i.E.: get DefineAllDbFields "Flexerrs" to iRet    
    // Note: if the Project is not a List-Project, Variables are define instead of the Fields
    Function DefineAllDbFields String sFile Returns Integer
        Integer iVar iFile
        If (piProjectType(Self)<>LL_PROJECT_LIST) ;
            Move 1 to iVar
        Else ;
            Move 0 to iVar
        Move (eval( (sFile + ".FILE_NUMBER"))) to iFile
        Function_Return (DefineCompleteDB(self,iFile,iVar))
    End_Function
    
    // Same Functions as above for a single DB-Field
    // i.E.: Get DefineDbField "Flexerrs.Recnum" to iRet
    Function DefineDbField String sField Returns Integer
        Integer iVar iFile iField iRet iFields iCou
        String sFieldName sFileName sVar
        tDbFile aFile
        If (piProjectType(Self)<>LL_PROJECT_LIST) ;
            Move 1 to iVar
        Else ;
            Move 0 to iVar
        
        Move (trim(uppercase(sField))) to sField

        Move sField to sFieldName
        Move (Left(sFieldName,(Pos(".",sFieldName)))) to sFileName
        Move (Replace(sFileName,sFieldName,"")) to sFieldName
        Move (Replace(".",sFileName,"")) to sFileName

        Move (eval( (sFileName + ".FILE_NUMBER"))) to iFile
        Get_Attribute DF_FILE_OPENED Of iFile to iRet

        If (iRet=DFFALSE) ;
            Open iFile

        Get fFileStruct iFile to aFile
        Move aFile.iNumberFields to iFields
        Move -1 to iField
        For iCou from 0 to iFields
            Move aFile.aFields[iCou].sName to sVar
            If (uppercase(trim(sVar))=(uppercase(trim(sFieldName)))) ;
                Move iCou to iField
            If (iField<>-1) ;
                Break
        Loop

        If (iField=-1) ;
            Function_Return -1
                
        Function_Return (DefineSingleDb(self,iFile,iField,iVar))
    End_Function
    Function DefineDbVariable String sField Returns Integer
        Integer iVar iFile iField iRet iFields iCou
        String sFieldName sFileName sVar
        tDbFile aFile
        
        Move (trim(uppercase(sField))) to sField

        Move sField to sFieldName
        Move (Left(sFieldName,(Pos(".",sFieldName)))) to sFileName
        Move (Replace(sFileName,sFieldName,"")) to sFieldName
        Move (Replace(".",sFileName,"")) to sFileName

        Move (eval( (sFileName + ".FILE_NUMBER"))) to iFile
        Get_Attribute DF_FILE_OPENED Of iFile to iRet

        If (iRet=DFFALSE) ;
            Open iFile
            
        Get fFileStruct iFile to aFile
        Move aFile.iNumberFields to iFields
        Move -1 to iField
        FOR iCou From 0 to iFields
            Move aFile.aFields[iCou].sName to sVar
            If (uppercase(trim(sVar))=(uppercase(trim(sFieldName)))) ;
                Move iCou to iField
            If (iField<>-1) ;
                Break
        Loop

        If (iField=-1) ;
            Function_Return -1
                
        Function_Return (DefineSingleDb(self,iFile,iField,TRUE))
    End_Function
    
    // Functions for defining an old Window Image Field in List & Label
    // just for fun
    // i.E.: Get DefineWindowVariable "Window.Date" LL_DATE_LOCALIZED window.1 to iRet
    Function DefineWindowVariable String sName Integer iType String sVal Returns Integer
        Integer iCurWind iRet
        Move current_window to iCurWind
        Get LLDefineVariableExt sName sVal iType to iRet
        Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sName + ":WI"+(String(iCurWind))+","+(String(iType)))
        Function_Return iRet
    End_Function
    Function DefineWindowField String sName Integer iType String sVal Returns Integer
        Integer iCurWind iRet
        Move current_window to iCurWind
        
        If ( (psUsedIdentifiers(self)="") Or ((Pos((";"+uppercase(sName)+";"),(psUsedIdentifiers(self)))<>0)) ) Begin
            If (piProjectType(Self)<>LL_PROJECT_LIST) Begin
                Get LLDefineVariableExt sName sVal iType to iRet
                Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sName + ":WI"+(String(iCurWind))+","+(String(iType)))
            End
            Else Begin
                Get LLDefineFieldExt sName sVal iType to iRet
                Set array_value of (oAllFields(Self)) (item_count(oAllFields(Self))) to (sName + ":WI"+(String(iCurWind))+","+(String(iType)))
            End
        End    
        Function_Return iRet
    End_Function    
    Function DefineProperty String sName Integer iType Integer iProperty Integer iObj Integer iVariable Returns Integer
        String sVal2
        Integer iRet
        Get iProperty Of iObj to sVal2
        If ( (psUsedIdentifiers(self)="") Or ((Pos((";"+uppercase(sName)+";"),(psUsedIdentifiers(self)))<>0)) ) Begin
            If (iVariable) Begin
                Get LLDefineVariableExt sName sVal2 iType to iRet
                Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sName + ":PT"+(String(iProperty))+","+(String(iObj))+","+(String(iType)))
            End
            Else Begin
                Get LLDefineFieldExt sName sVal2 iType to iRet
                Set array_value Of (oAllFields(self)) (item_count(oAllFields(self))) to (sName + ":PT"+(String(iProperty))+","+(String(iObj))+","+(String(iType)))            
            End
        End    
        Function_Return iRet        
    End_Function
    Function DefineStruct Integer iProperty Integer iMsg String sName Integer iVariable Returns Integer
        If ( (psUsedIdentifiers(self)="") Or ((Pos((";"+uppercase(sName)+"."),(psUsedIdentifiers(self)))<>0)) ) Begin
            Send iMsg iProperty sName iVariable 
            If (iVariable) Begin
                Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sName + ":ST"+(String(iProperty))+","+(String(iMsg)))
            End
            Else Begin
                Set array_value of (oAllFields(Self)) (item_count(oAllFields(Self))) to (sName + ":ST"+(String(iProperty))+","+(String(iMsg)))
            End            
        End
    End_Function
    
    // Functions for defining a property in List & Label
    // maybe this could be done something more "elegant"
    // i.E.: Get DefinePropertyField "CURRENTUSERNUMBER" LL_NUMERIC "piCurrentUser" "(main.obj)" to iRet
    Function DefinePropertyVariable String sName Integer iType String sProperty String sObj Returns Integer
        Integer iCurWind iRet iProperty iObj
        String sVal2
        Move (trim(uppercase(sProperty))) to sProperty
        If (Left(sProperty,4)<>"GET_") ;
            Move ("GET_"+ sProperty) to sProperty
        Move (eval(sProperty)) to iProperty
        Move (eval(sObj)) to iObj
        Get DefineProperty sName iType iProperty iObj TRUE to iRet
        Function_Return iRet
    End_Function
    Function DefinePropertyField String sName Integer iType String sProperty String sObj Returns Integer
        Integer iCurWind iRet iProperty iObj
        String sVal2
        Move (trim(uppercase(sProperty))) to sProperty
        If (Left(sProperty,4)<>"GET_") ;
            Move ("GET_"+ sProperty) to sProperty
        Move (eval(sProperty)) to iProperty
        Move (eval(sObj)) to iObj
        If (piProjectType(Self)<>LL_PROJECT_LIST) ;
            Get DefineProperty sName iType iProperty iObj True to iRet
        Else ;
            Get DefineProperty sName iType iProperty iObj False to iRet 
        Function_Return iRet
    End_Function
    
    // Functions for defining a string-Pointer or memory block in List & Label
    // maybe needed for really large strings
    // i.E.: Get DefinePointerVariable "LongText" LL_TEXT hMemoryHandle to iRet
    Function DefinePointerVariable String sName Integer iType Handle hHandle Returns Integer
        Integer iCurWind iRet iProperty iObj
        String sVal2
        String sVar1 sVar2
        Pointer pVar1 pVar2
        #IF (!@>199)
        Move (LLDefineVariableExtEf(piJobNumber(Self),sName,hHandle,iType,0)) to iRet
        #ELSE
        Move (ToAnsiStr(self,sName)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move hHandle to pVar2
        Move (LLDefineVariableExtEf(piJobNumber(Self),pVar1,pVar2,iType,0)) to iRet
        #ENDIF
        Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sName + ":PO"+(String(hHandle))+","+(String(iType)))
        Function_Return iRet
    End_Function
    Function DefinePointerField String sName Integer iType Handle hHandle Returns Integer
        Integer iCurWind iRet iProperty iObj
        String sVal2
        String sVar1 sVar2
        Pointer pVar1 pVar2

        If ( (psUsedIdentifiers(self)="") Or ((Pos((";"+uppercase(sName)+";"),(psUsedIdentifiers(self)))<>0)) ) Begin
            If (piProjectType(Self)<>LL_PROJECT_LIST) Begin
                #IF (!@>199)
                Move (LLDefineVariableExtEf(piJobNumber(Self),sName,hHandle,iType,0)) to iRet
                #ELSE
                Move (ToAnsiStr(Self,sName)) to sVar1
                Move (AddressOf(sVar1)) to pVar1
                Move hHandle to pVar2                
                Move (LLDefineVariableExtEf(piJobNumber(Self),pVar1,pVar2,iType,0)) to iRet
                #ENDIF
                Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sName + ":PO"+(String(hHandle))+","+(String(iType)))
            End
            Else Begin
                #IF (!@>199)
                Move (LLDefineFieldExtEf(piJobNumber(Self),sName,hHandle,iType,0)) to iRet
                #ELSE
                Move (ToAnsiStr(Self,sName)) to sVar1
                Move (AddressOf(sVar1)) to pVar1
                Move hHandle to pVar2                
                Move (LLDefineFieldExtEf(piJobNumber(Self),pVar1,pVar2,iType,0)) to iRet
                #ENDIF
                Set array_value of (oAllFields(Self)) (item_count(oAllFields(Self))) to (sName + ":PO"+(String(hHandle))+","+(String(iType)))
            End
        End    
        Function_Return iRet
    End_Function
    
    // Functions for defining a global memory block in List & Label
    // maybe needed for really large strings
    // i.E.: Get DefineGlobalMemoryVariable "LongText" LL_TEXT hGlobalPointer to iRet
    Function DefineGlobalMemoryVariable String sName Integer iType Handle hHandle Returns Integer
        Integer iCurWind iRet iProperty iObj
        String sVal2
        String sVar1 sVar2
        Pointer pVar1 pVar2
        #IF (!@>199)
        Move (LLDefineVariableExtEf(piJobNumber(Self),sName,hHandle,iType,0)) to iRet
        #ELSE
        Move (ToAnsiStr(self,sName)) to sVar1
        Move (AddressOf(sVar1)) to pVar1
        Move hHandle to pVar2
        Move (LLDefineVariableExtEf(piJobNumber(Self),pVar1,pVar2,iType,0)) to iRet
        #ENDIF
        Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sName + ":GM"+(String(hHandle))+","+(String(iType)))
        Function_Return iRet
    End_Function
    Function DefineGlobalMemoryField String sName Integer iType Handle hHandle Returns Integer
        Integer iCurWind iRet iProperty iObj
        String sVal2
        String sVar1 sVar2
        Pointer pVar1 pVar2
        If ( (psUsedIdentifiers(self)="") Or ((Pos((";"+uppercase(sName)+";"),(psUsedIdentifiers(self)))<>0)) ) Begin
            If (piProjectType(Self)<>LL_PROJECT_LIST) Begin
                #IF (!@>199)
                Move (LLDefineVariableExtEf(piJobNumber(Self),sName,hHandle,iType,0)) to iRet
                #ELSE
                Move (ToAnsiStr(Self,sName)) to sVar1
                Move (AddressOf(sVar1)) to pVar1
                Move hHandle to pVar2
                Move (LLDefineVariableExtEf(piJobNumber(Self),pVar1,pVar2,iType,0)) to iRet
                #ENDIF
                Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sName + ":GM"+(String(hHandle))+","+(String(iType)))
            End
            Else Begin
                #IF (!@>199)
                Move (LLDefineFieldExtEf(piJobNumber(Self),sName,hHandle,iType,0)) to iRet
                #ELSE
                Move (ToAnsiStr(Self,sName)) to sVar1
                Move (AddressOf(sVar1)) to pVar1
                Move hHandle to pVar2                
                Move (LLDefineFieldExtEf(piJobNumber(Self),pVar1,pVar2,iType,0)) to iRet
                #ENDIF
                Set array_value of (oAllFields(Self)) (item_count(oAllFields(Self))) to (sName + ":GM"+(String(hHandle))+","+(String(iType)))
            End
        End    
        Function_Return iRet
    End_Function        
    
    // messages used by the Commands DefineLLField and DefineLLVariable

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF    
    Procedure DefinePropertyVariableCommand String sName Integer iType Integer iProperty Integer iObj
        Integer iRet
        Get DefineProperty sName iType iProperty iObj TRUE to iRet
    End_Procedure

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefinePropertyFieldCommand String sName Integer iType Integer iProperty Integer iObj
        Integer iCurWind iRet
        String sVal2
        If (piProjectType(Self)<>LL_PROJECT_LIST) ;
            Get DefineProperty sName iType iProperty iObj True to iRet
        Else ;
            Get DefineProperty sName iType iProperty iObj False to iRet 
    End_Procedure    
    
    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineStructVariableCommand Integer iProperty Integer iMsg String sName
        Integer iCurWind iRet
        String sVal2
        Get DefineStruct iProperty iMsg sName True to iRet
    End_Procedure        
    
    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineStructFieldCommand Integer iProperty Integer iMsg String sName
        Integer iCurWind iRet
        String sVal2
        If (piProjectType(Self)<>LL_PROJECT_LIST) ;
            Get DefineStruct iProperty iMsg sName True to iRet
        Else ;
            Get DefineStruct iProperty iMsg sName False to iRet 
    End_Procedure    

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineDbFieldsCommand Integer iFile
        Integer iRet
        If (piProjectType(Self)<>LL_PROJECT_LIST) ;
            Get DefineCompleteDb iFile True to iRet
        Else ;
            Get DefineCompleteDb iFile False to iRet
    End_Procedure

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineDbVariablesCommand Integer iFile
        Integer iRet
        Get DefineCompleteDb iFile TRUE to iRet
    End_Procedure
    
    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineAliasDbFieldsCommand Integer iFile String sAlias
        Integer iRet
        #IF (!@>109)
            If (piProjectType(Self)<>LL_PROJECT_LIST) ;
                Get DefineAliasDb iFile sAlias True to iRet
            Else ;
                Get DefineAliasDb iFile sAlias False to iRet
        #ENDIF    
    End_Procedure

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineAliasDbVariablesCommand Integer iFile String sAlias
        Integer iRet
        #IF (!@>109)
            Get DefineAliasDb iFile sAlias TRUE to iRet
        #ENDIF    
    End_Procedure    

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineDbFieldCommand Integer iFile Integer iField
        Integer iRet
        If (piProjectType(Self)<>LL_PROJECT_LIST) ;
            Get DefineSingleDb iFile iField True to iRet
        Else ;
            Get DefineSingleDb iFile iField False to iRet
    End_Procedure

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineDbVariableCommand Integer iFile Integer iField
        Integer iRet
        Get DefineSingleDb iFile iField TRUE to iRet
    End_Procedure        

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineWindowFieldCommand String sName Integer iType Integer iCurWindow
        Integer iRet
        String sVal
        
        If ( (psUsedIdentifiers(self)="") Or ((Pos((";"+uppercase(sName)+";"),(psUsedIdentifiers(self)))<>0)) ) Begin
            Move windowindex to iRet
            Move (iCurWindow - 1) to windowindex
            Move |WS1& to sVal
            Move iRet to windowindex
            
            If (piProjectType(Self)<>LL_PROJECT_LIST) Begin
                Get LLDefineVariableExt sName sVal iType to iRet
                Set array_value Of (oAllVariables(self)) (item_count(oAllVariables(self))) to (sName + ":WI"+(String(iCurWindow))+","+(String(iType)))
            End
            Else Begin
                Get LLDefineFieldExt sName sVal iType to iRet
                Set array_value Of (oAllFields(self)) (item_count(oAllFields(self))) to (sName + ":WI"+(String(iCurWindow))+","+(String(iType)))
            End
        End    
    End_Procedure

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF        
    Procedure DefineWindowVariableCommand String sName Integer iType Integer iCurWindow
        Integer iRet
        String sVal
        
        Move windowindex to iRet
        Move (iCurWindow - 1) to windowindex
        Move |WS1& to sVal
        Move iRet to windowindex
        
        Get LLDefineVariableExt sName sVal iType to iRet
        Set array_value of (oAllVariables(Self)) (item_count(oAllVariables(Self))) to (sName + ":WI"+(String(iCurWindow))+","+(String(iType)))
    End_Procedure        

    // Functions for defining and finding the really used fields in the Layout.

    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF
    Procedure DefineUsedDataObjectFields Integer bVariables
        #IF (!@>109)
        Integer iCou iField iIndex iRet
        Handle hoObj
        tLLDataField[] aUsedFields
        Variant[][] vData
        String sCont
        
        For iCou from 0 to (Item_Count(oDataObjects(Self))-1)
            Get Value of oDataObjects iCou to hoObj
            If (hoObj<>0) Begin
                If ( ((pbIsVariable(hoObj)) and (bVariables)) or ( (pbIsField(hoObj)) and (not(bVariables))) ) Begin
                    Get paUsedDataFields of hoObj to aUsedFields
                    Get pvData of hoObj to vData
                    Get piDataIndex of hoObj to iIndex
                    For iField from 0 to (SizeOfArray(aUsedFields)-1)
                        Move "" to sCont
                        If ( (iIndex<>-1) and (SizeOfArray(vData)>iIndex) ) Begin
                            If (SizeOfArray(vData[iIndex])>aUsedFields[iField].iDataIndex) Begin
                                Move vData[iIndex][aUsedFields[iField].iDataIndex] to sCont
                            End
                        End
                        If ( (pbIsVariable(hoObj)) and (bVariables) ) Begin
                            Get LLDefineVariableExt (psName(hoObj)+"."+aUsedFields[iField].sName) sCont aUsedFields[iField].iType to iRet
                        End
                        If ( (pbIsField(hoObj)) and (not(bVariables)) ) Begin
                            Get LLDefineFieldExt (psName(hoObj)+"."+aUsedFields[iField].sName) sCont aUsedFields[iField].iType to iRet
                        End
                    Loop
                End
            End
        Loop
        #ENDIF
    End_Procedure
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF
    Procedure DefineUsedFields
        Integer iCou iFile iField iType iRet iWindInd iProperty iObj iMsg
        String sVar sType sField sVar2 sCont sVar1
        Pointer pVar1 pVar2
        #IF (!@>199)
        Longptr pVal
        #ELSE
        Integer pVal
        #ENDIF
        Move windowindex to iWindInd
        FOR iCou From 0 to ( (item_count(oUsedFields(self)))-1)
            Get array_value of (oUsedFields(Self)) iCou to sVar
            Move (Left(sVar,(Pos(":",sVar)))) to sField
            Move (Replace(sField,sVar,"")) to sVar
            Move (Replace(":",sField,"")) to sField
            Move (Left(sVar,2)) to sType
            Move (Replace(sType,sVar,"")) to sVar
            Case Begin
                Case (sType="DB") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iFile
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iField
                    Move sVar to iType
                    get_field_value iFile iField to sCont
                    If (piTrimDbValues(Self)) ;
                        Move (trim(sCont)) to sCont
                    Get LLDefineFieldExt sField sCont iType to iRet
                End
                Case (sType="WI") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iField
                    Move sVar to iType
                    Move (iField - 1) to windowindex
                    Move |WS1& to sCont
                    Get LLDefineFieldExt sField sCont iType to iRet
                End
                Case (sType="PT") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iProperty
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iObj
                    Move sVar to iType
                    Get iProperty Of iObj to sCont
                    Get LLDefineFieldExt sField sCont iType to iRet
                End
                Case (sType="ST") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iProperty
                    Move sVar to iMsg
                    Send iMsg iProperty sField False
                End                
                Case (sType="PO") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to pVal
                    Move sVar to iType
                    #IF (!@>199)
                    Move (LLDefineFieldExtEf(piJobNumber(Self),sField,pVal,iType,0)) to iRet
                    #ELSE
                    Move (ToAnsiStr(self,sField)) to sVar1
                    Move (AddressOf(sVar1)) to pVar1
                    Move (LLDefineFieldExtEf(piJobNumber(Self),pVar1,pVal,iType,0)) to iRet
                    #ENDIF
                End
                Case (sType="GM") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to pVal
                    Move sVar to iType
                    #IF (!@>199)
                    Move (LlGlobalLockEf(pVal)) to pVar2
                    Move (LLDefineFieldExtEf(piJobNumber(Self),sField,pVar2,iType,0)) to iRet
                    Move (LlGlobalUnlockEf(pVal)) to pVar2                    
                    #ELSE
                    Move (ToAnsiStr(self,sField)) to sVar1
                    Move (AddressOf(sVar1)) to pVar1
                    Move (LlGlobalLockEf(pVal)) to pVar2
                    Move (LLDefineFieldExtEf(piJobNumber(self),pVar1,pVar2,iType,0)) to iRet
                    Move (LlGlobalUnlockEf(pVal)) to pVar2
                    #ENDIF
                End                
            Case End
        Loop
        Move iWindInd to windowindex
        Send DefineUsedDataObjectFields False
    End_Procedure
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF
    Procedure DefineUsedVariables
        Integer iCou iFile iField iType iRet iProperty iObj iMsg
        String sVar sType sField sVar2 sCont sVar1
        Pointer pVar1 pVar2 
        #IF (!@>199)
        Longptr pVal
        #ELSE
        Integer pVal
        #ENDIF
        FOR iCou From 0 to ( (item_count(oUsedVariables(self)))-1)
            Get array_value of (oUsedVariables(Self)) iCou to sVar
            Move (Left(sVar,(Pos(":",sVar)))) to sField
            Move (Replace(sField,sVar,"")) to sVar
            Move (Replace(":",sField,"")) to sField
            Move (Left(sVar,2)) to sType
            Move (Replace(sType,sVar,"")) to sVar
            Case Begin
                Case (sType="DB") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iFile
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iField
                    Move sVar to iType
                    get_field_value iFile iField to sCont
                    If (piTrimDbValues(Self)) ;
                        Move (trim(sCont)) to sCont
                    Get LLDefineVariableExt sField sCont iType to iRet
                End
                Case (sType="WI") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iField
                    Move sVar to iType
                    Move (iField - 1) to windowindex
                    Move |WS1& to sCont
                    Get LLDefineVariableExt sField sCont iType to iRet
                End
                Case (sType="PT") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iProperty
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iObj
                    Move sVar to iType
                    Get iProperty Of iObj to sCont
                    Get LLDefineVariableExt sField sCont iType to iRet
                End
                Case (sType="PO") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to pVal
                    Move sVar to iType
                    #IF (!@>199)
                    Move (LLDefineVariableExtEf(piJobNumber(Self),sField,pVal,iType,0)) to iRet
                    #ELSE
                    Move (ToAnsiStr(self,sField)) to sVar1
                    Move (AddressOf(sVar1)) to pVar1
                    Move (LLDefineVariableExtEf(piJobNumber(Self),pVar1,pVal,iType,0)) to iRet
                    #ENDIF
                End
                Case (sType="ST") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to iProperty
                    Move sVar to iMsg
                    Send iMsg iProperty sField True
                End                
                Case (sType="GM") Begin
                    Move (Left(sVar,(Pos(",",sVar)))) to sVar2
                    Move (Replace(sVar2,sVar,"")) to sVar
                    Move (Replace(",",sVar2,"")) to pVal
                    Move sVar to iType
                    #IF (!@>199)
                    Move (LlGlobalLockEf(pVal)) to pVar2
                    Move (LLDefineVariableExtEf(piJobNumber(Self),sField,pVar2,iType,0)) to iRet
                    Move (LlGlobalUnlockEf(pVal)) to pVar2                                        
                    #ELSE
                    Move (ToAnsiStr(self,sField)) to sVar1
                    Move (AddressOf(sVar1)) to pVar1
                    Move (LlGlobalLockEf(pVal)) to pVar2
                    Move (LLDefineVariableExtEf(piJobNumber(self),pVar1,pVar2,iType,0)) to iRet
                    Move (LlGlobalUnlockEf(pVal)) to pVar2                    
                    #ENDIF
                End                
            Case End
        Loop
        Send DefineUsedDataObjectFields True
    End_Procedure

    Procedure DoDefineUsedAliasFields String sAlias
        #IF (!@>109)
        tAliasDb[] sUsedFields
        Integer iCou iCou2 iRet
        String sCont
        Get paUsedAliasFields to sUsedFields
        FOR iCou From 0 to (SizeOfArray(sUsedFields)-1)
            If (uppercase(trim(sUsedFields[iCou].sAliasName))=(uppercase(trim(sAlias)))) Begin
                FOR iCou2 From 0 to (SizeOfArray(sUsedFields[iCou].sFields)-1)
                    get_field_value sUsedFields[iCou].sFields[iCou2].iFile sUsedFields[iCou].sFields[iCou2].iField to sCont
                    If (piTrimDbValues(Self)) ;
                        Move (trim(sCont)) to sCont
                    Get LLDefineFieldExt (sUsedFields[iCou].sAliasName+"."+sUsedFields[iCou].sFields[iCou2].sField) sCont sUsedFields[iCou].sFields[iCou2].iType to iRet
                Loop
            End
        Loop
        #ENDIF
    End_Procedure
    
    Procedure DoDefineUsedAliasVariables String sAlias
        #IF (!@>109)
        tAliasDb[] sUsedFields
        Integer iCou iCou2 iRet
        String sCont
        Get paUsedAliasVariables to sUsedFields
        FOR iCou From 0 to (SizeOfArray(sUsedFields)-1)
            If (uppercase(trim(sUsedFields[iCou].sAliasName))=(uppercase(trim(sAlias)))) Begin
                FOR iCou2 From 0 to (SizeOfArray(sUsedFields[iCou].sFields)-1)
                    get_field_value sUsedFields[iCou].sFields[iCou2].iFile sUsedFields[iCou].sFields[iCou2].iField to sCont
                    If (piTrimDbValues(Self)) ;
                        Move (trim(sCont)) to sCont
                    Get LLDefineVariableExt (sUsedFields[iCou].sAliasName+"."+sUsedFields[iCou].sFields[iCou2].sField) sCont sUsedFields[iCou].sFields[iCou2].iType to iRet
                Loop
            End
        Loop
        #ENDIF
    End_Procedure
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF    
    Procedure SearchUsedAliasFields
        #IF (!@>109)
        tAliasDb[] sAllFields
        tAliasDb[] sUsedFields
        tAliasDb sAliasDb
        Integer iCou iCou2
        Get paAllAliasFields to sAllFields        
        FOR iCou From 0 to (SizeOfArray(sAllFields)-1)
            Move (ResizeArray(sAliasDb.sFields,0)) to sAliasDb.sFields
            FOR iCou2 From 0 to (SizeOfArray(sAllFields[iCou].sFields)-1)
                If (LLPrintIsFieldUsed(self,(sAllFields[iCou].sAliasName+"."+sAllFields[iCou].sFields[iCou2].sField))=1) Begin
                    Move sAllFields[iCou].sAliasName to sAliasDb.sAliasName
                    Move sAllFields[iCou].sFields[iCou2] to sAliasDb.sFields[(SizeOfArray(sAliasDb.sFields))]
                End
            Loop
            If (SizeOfArray(sAliasDb.sFields)<>0) Begin
                Move sAliasDb to sUsedFields[(SizeOfArray(sUsedFields))]
            End
        Loop
        Set paUsedAliasFields to sUsedFields
        #ENDIF
    End_Procedure    
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF
    Procedure SearchUsedFields
        Integer iCou
        String sVar sField sVar2
        Send delete_data to (oUsedFields(self))
        FOR iCou From 0 to ( (item_count(oAllFields(self)))-1)
            Get value Of (oAllFields(self)) iCou to sVar
            Move sVar to sVar2
            Move (Left(sVar,(Pos(":",sVar)))) to sField
            Move (Replace(sField,sVar2,"")) to sVar2
            Move (Replace(":",sField,"")) to sField
            If (Left(sVar2,2)="ST") Begin
                Move (sField + "*") to sField
            End
            If ( (trim(sField)<>"") and (LLPrintIsFieldUsed(Self,sField)=1) ) Begin
                Set array_value of (oUsedFields(Self)) (item_count(oUsedFields(Self))) to sVar
            End
        Loop
        Send SearchUsedAliasFields
        Send SearchUsedDataObjectFields False
    End_Procedure
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF
    Procedure SearchUsedDataObjectFields Integer bVariables
        #IF (!@>109)
        Integer iCou iField 
        Handle hoObj
        Integer bIsUsed
        tLLDataField[] aAllFields aUsedFields
        
        For iCou from 0 to (Item_Count(oDataObjects(Self))-1)
            Get Value of oDataObjects iCou to hoObj
            If (hoObj<>0) Begin
                If ( ((pbIsVariable(hoObj)) and (bVariables)) or ( (pbIsField(hoObj)) and (not(bVariables))) ) Begin
                    Get paAllDataFields of hoObj to aAllFields
                    Move (ResizeArray(aUsedFields,0)) to aUsedFields
                    For iField from 0 to (SizeOfArray(aAllFields)-1)
                        Move False to bIsUsed
                        If ((pbIsVariable(hoObj)) and (bVariables)) Begin
                            Move (LLPrintIsVariableUsed(Self,(psName(hoObj)+"."+aAllFields[iField].sName))=1) to bIsUsed
                        End
                        If ((pbIsField(hoObj)) and (not(bVariables))) Begin
                            Move (LLPrintIsFieldUsed(Self,(psName(hoObj)+"."+aAllFields[iField].sName))=1) to bIsUsed
                        End
                        If (bIsUsed) Begin
                            Move aAllFields[iField] to aUsedFields[(SizeOfArray(aUsedFields))]
                        End
                    Loop
                    Set paUsedDataFields of hoObj to aUsedFields
                End
            End
        Loop
        #ENDIF
    End_Procedure
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF
    Procedure SearchUsedAliasVariables
        #IF (!@>109)
        tAliasDb[] sAllFields
        tAliasDb[] sUsedFields
        tAliasDb sAliasDb
        Integer iCou iCou2
        Get paAllAliasVariables to sAllFields        
        FOR iCou From 0 to (SizeOfArray(sAllFields)-1)
            Move (ResizeArray(sAliasDb.sFields,0)) to sAliasDb.sFields
            FOR iCou2 From 0 to (SizeOfArray(sAllFields[iCou].sFields)-1)
                If (LLPrintIsVariableUsed(self,(sAllFields[iCou].sAliasName+"."+sAllFields[iCou].sFields[iCou2].sField))=1) Begin
                    Move sAllFields[iCou].sAliasName to sAliasDb.sAliasName
                    Move sAllFields[iCou].sFields[iCou2] to sAliasDb.sFields[(SizeOfArray(sAliasDb.sFields))]
                End
            Loop
            If (SizeOfArray(sAliasDb.sFields)<>0) Begin
                Move sAliasDb to sUsedFields[(SizeOfArray(sUsedFields))]
            End
        Loop
        Set paUsedAliasVariables to sUsedFields
        #ENDIF
    End_Procedure
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF    
    Procedure SearchUsedVariables
        Integer iCou
        String sVar sField sVar2
        Send delete_data to (oUsedVariables(self))
        FOR iCou From 0 to ( (item_count(oAllVariables(self)))-1)
            Get value Of (oAllVariables(self)) iCou to sVar
            Move sVar to sVar2
            Move (Left(sVar,(Pos(":",sVar)))) to sField
            Move (Replace(sField,sVar2,"")) to sVar2
            Move (Replace(":",sField,"")) to sField
            If (Left(sVar2,2)="ST") Begin
                Move (sField + "*") to sField
            End            
            If ( (trim(sField)<>"") and (LLPrintIsVariableUsed(Self,sField)=1) ) Begin
                Set array_value of (oUsedVariables(Self)) (item_count(oUsedVariables(Self))) to sVar
            End
        Loop
        Send SearchUsedAliasVariables
        Send SearchUsedDataObjectFields True
    End_Procedure
    
    // These are the entry-points for the report to define the List & Label Variables and Fields
    // In this Procedures the above defining functions must (and can) be called
    
    // DefineAllFields: Called to define all available Fields in a Layout
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure DefineAllFields
    End_Procedure
    
    // DefineAllFields: Called to define all available Variables in a Layout
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure DefineAllVariables
    End_Procedure
    
    // DefineStandardVariables: Called to define Variables that must always be defined (they are also defined
    // if you print a List-Project that normaly defines Variables only one time a page and not for each record
    // printed). Use this carefully as it could slow down the report
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure DefineStandardVariables
    End_Procedure
    
    // DefineOneTimeVariables: Called to define Variables only one time at starting printing or layouting
    // May speed up the report if you have Values, that are the same the whole report
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure DefineOneTimeVariables
    End_Procedure
    
    // Functions for encapsulating printing List,Card and Label-Projects in one single call
    Function PrintFirstData Returns Integer
        Integer iRet

        If (piProjectType(Self)=LL_PROJECT_LIST) Begin
            Get LLPrint to iRet
            While (LLPrintFields(Self)=LL_WRN_REPEAT_DATA)
                Get LLPrint to iRet
            End
        End
        Else Begin
            While (LLPrint(Self)=LL_WRN_REPEAT_DATA)
            End
        End
        Function_Return 0
    End_Function

    Function PrintData Returns Integer
        Integer iRet
        If (piFirstPrint(self)) Begin
            Send DoCheckPreviewPanelBeforePrint
            Get PrintFirstData to iRet
            Set piFirstPrint to FALSE
            Function_Return iRet
        End

        If (piProjectType(Self)=LL_PROJECT_LIST) Begin
            Get LLPrintFields to iRet
            While (iRet = LL_WRN_REPEAT_DATA)
                Get LLPrint to iRet
                Get LLPrintFields to iRet
            End
        End
        Else Begin
            Get LLPrint to iRet
            While (iRet=LL_WRN_REPEAT_DATA)
                Get LLPrint to iRet
            End
        End
        Function_Return iRet
    End_Function
End_Class

// **********************************************************************************************************
// Class-Definition for the Inline Viewer Control
// **********************************************************************************************************

// The cListLabelViewer Class can be used to display the printed or saved List & Label Preview Files (*.LL) 
// directly within VDF. Several Properties and Notifications can be used to control the Preview Objekt. 
// The Class is Studio/IDE aware. You have to copy the files
// cListLabelViewer.bmp
// cListLabelViewer.dfc
// into the IdeSrc Directory of your Project. After that, you have to define the Class in the Studio/Ide with
// the Configure Class List Option.

#IF (!@ >= 120)
{ MethodType=Method Visibility=Private }
#ENDIF    
Function LsGetViewerControlClassName Global Returns String
    #IF (!@>199)
    Pointer pSource
    WString wVar
    Move (LsGetViewerControlClassNameEf()) to pSource
    If (pSource) Begin
        Move (PointerToWString(pSource)) to wVar
        Function_Return (CString(wVar))
    End     
    #ELSE
    String sRet sPart
    Pointer pPart pSource pRet
    Integer iRet iFinished
    Move (LsGetViewerControlClassNameEf()) to pSource
    If (pSource) Begin
        While (Not(iFinished))
            Move (Character(0)) to sPart
            Move (AddressOf(sPart)) to pPart
            Move (CopyMemoryE(pPart,pSource,1)) to iRet
            If (sPart=(Character(0))) Begin
                Move 1 to iFinished
            End
            Else Begin
                Move (sRet + sPart) to sRet
                Increment pSource
            End
        End
    End
    Move (sRet + (Character(0)) ) to sRet
    Move (AddressOf(sRet)) to pRet
    Move (AnsiToOem(pRet,pRet)) to iRet
    Function_Return (cString(sRet))
    #ENDIF
End_Function

Use help_mx.pkg

#IF (!@ >= 120)
{ DesignerClass=cDTTextBox }
#ENDIF

Class cVDFListLabelViewer is a DFControl
    
    #IF (!@>199)
    Register_Procedure LLViewerMessage Longptr wParam Longptr lParam
    #ELSE
    Register_Procedure LLViewerMessage Integer wParam Integer lParam
    #ENDIF
    Import_Class_Protocol help_mixin
    #IF (!@ >= 120)
    { MethodType=Property Visibility=Private }
    #ENDIF
    
    #IF (!@>199)
    Function StringFromPointer Longptr pSource Returns String
        WString wVar
        String sRetVal
        Move (PointerToWString(pSource)) to wVar
        Move (CString(wVar)) to sRetVal
        Function_Return sRetVal        
    End_Function
    #ELSE    
    Function StringFromPointer Integer pSource Returns String
        String sPos sRetVal
        Pointer pPos
        Integer iRet
        While (pSource)
            Move (Character(0)) to sPos
            Move (AddressOf(sPos)) to pPos
            Move (CopyMemoryE(pPos,pSource,1)) to iRet
            Move (sRetVal + sPos) to sRetVal
            If (sPos=(Character(0))) ;
                Move 0 to pSource
            Else ;
                Increment pSource
        End
        If (sRetVal <> "") Begin
            Move (AddressOf(sRetVal)) to pPos
            Move (AnsiToOem(pPos,pPos)) to iRet
        End
        Function_Return (cString(sRetVal))
    End_Function    
    #ENDIF
    
    #IF (!@ >= 120)
    { Visibility=Private MethodType=Event }
    #ENDIF
    Procedure Construct_Object
        Set external_class_name "cVDFListLabelViewer" to (LsGetViewerControlClassName())
        Set external_message (WM_USER + 531) to msg_LLViewerMessage            
        Set border_style to border_ClientEdge
        
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer Private.pbToolbarVisible           True
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer Private.pbSketchbarVisible         True
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer Private.piSketchbarWidth           0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer Private.piToolbarStyle             LS_OPTION_TOOLBARSTYLE_STANDARD
        #IF (USELLVERSION>17)
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer Private.piMousemode                LS_OPTION_MOUSEMODE_ZOOM
        #ENDIF
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer Private.piBgColor                  0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer Private.piLanguage                 CMBTLANG_DEFAULT
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property String  Private.psFileUrl                  ""
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer Private.piLastKeyMessage           0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer Private.piLastKey                  0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        #IF (!@>199)
        Property Longptr Private.phStgHandle                0
        #ELSE
        Property Handle  Private.phStgHandle                0
        #ENDIF
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer piOriginalSketchbarWidth           0
        
        Property String  psFileToDisplay                    ""
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF
        Property Integer piAssociatedLLObj                  0
        Property Integer pbPreviewRunning                   False
        Property Integer pbIsEmbeddedObject                 False
        Property Integer piObjectAssociatedToLLObj          0
        
        Property Integer Client_Area_State                  False
        Send Define_Help_Mixin
        Forward Send Construct_Object
    End_Procedure
    
    Function fIsLLPreviewObject Returns Integer
        Function_Return (Self)
    End_Function
    
    // Notifications sent from the Viewer Object
    
    // OnPageLoaded: The Viewer has loaded and displayed a Page
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnPageLoaded Integer iPage
    End_Procedure
    
    // OnUpdateToolbar: Called when the Viewer don't display it's own Toolbar (pbToolbarVisible=FALSE) and
    // a user defined Toolbar need's to be updated (i.E. Zoom changed, Page changed....)
    // iPagesChanged is just for compatibility Reasons, it is always 0
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnUpdateToolbar Integer iPagesChanged
    End_Procedure
    
    // OnToolbarUpdate: Called when the Viewer uses his own Toolbar (pbToolbarVisible=TRUE) and the Toolbar
    // gets changed.
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnToolbarUpdate
    End_Procedure
    
    // OnBtnPressed: Is called when the User selects one of the internal Toolbar Buttons. Look into the file
    // menuid.txt in your List & Label Directory for the possible Control-Id's
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnBtnPressed Integer iControlId
    End_Procedure
    
    // OnExitBtnPressed: Is called when the user selects the Exit Button of the internal Toolbar
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnExitBtnPressed
    End_Procedure
    
    // OnPrintPage: Is called whenever the Preview Objects print's a page. You can return 1 (procedure_return 1) 
    // to cancel the Print.
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnPrintPage Integer iPages Integer iAbcAbcCopies Integer iPage Integer iCopy Integer iAbcAbcCopy String sDevice String sProject String sJobname
    End_Procedure
    
    // OnPrintStart: Is called when a printout is starting. You can return 1 (procedure_return 1) 
    // to cancel the Print.
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnPrintStart Integer iPages Integer iAbcAbcCopies Integer iPage Integer iCopy Integer iAbcAbcCopy String sDevice String sProject String sJobname
    End_Procedure
    
    // OnPrintEnd: Is called when a printout is finished.
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnPrintEnd Integer iPages Integer iAbcAbcCopies Integer iPage Integer iCopy Integer iAbcAbcCopy String sDevice String sProject String sJobname
    End_Procedure
    
    // OnBeforeIncrementalPreviewStart: Is called before an incremental Preview is about to be started. iLLObj is the Object-Id of the List & Label Report Object
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnBeforeIncrementalPreviewStart Integer iLLObj
    End_Procedure    
    
    // OnIncrementalPreviewStart: Is called when an incremental Preview is started. iLLObj is the Object-Id of the List & Label Report Object
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnIncrementalPreviewStart Integer iLLObj
    End_Procedure
    
    // OnIncrementalPreviewEnd: Is called when a Report that uses incremental Preview is finished. iLLObj is the Object-Id of the List & Label Report Object
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnIncrementalPreviewEnd Integer iLLObj
    End_Procedure
    
    // OnQuestBtnState: Is called to control which buttons are active in the internal Toolbar. Look into the file
    // menuid.txt in your List & Label Directory for the possible Control-Id's. You can Return
    // -1  hide
    // 1   show
    // 2   show and disable 
    // 0   use default
    // the Button requested.
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnQuestBtnState Integer iControlID
    End_Procedure
    
    // OnDownloadFinished: Is called, when the complete file is loaded by the Viewer Object
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnDownloadFinished Integer iDownloadOk
    End_Procedure

    #IF (!@ >= 120)
    { MethodType=Event }
    { Visibility=Private }
    #ENDIF    
    #IF (!@>199)
    Procedure OnKeyboardMessage Integer iMsg Longptr wParam Longptr lParam
    End_Procedure    
    #ELSE
    Procedure OnKeyboardMessage Integer iMsg Integer wParam Integer lParam
    End_Procedure
    #ENDIF
    
    // Internal Functions and procedures
    #IF (!@ >= 120)
    { Visibility=Private MethodType=Event }
    #ENDIF
    #IF (!@>199)
    Procedure LLViewerMessage Longptr wParam Longptr lParam
    #ELSE
    Procedure LLViewerMessage Integer wParam Integer lParam
    #ENDIF
        String sPrinterData sDevice sProject sJobName sMsg sChangedData sViewInfo
        Pointer pPrinterData pMsg pChangedData pViewInfo
        Integer iRet iSize iPages iAbcCopies iPage iCopy iAbcCopy iPointer iMsg iKey lPara wPara iLastKey iLastKeyMessage iIsCtrl iIsAlt iIsShift iRetVal
        scViewerControlPrintData aPrinterData
        scViewerKeyboardMSG aKeyboardMsg
        Set windows_override_state to False
        Case Begin
            Case (wParam = LS_VIEWERCONTROL_NTFY_PAGELOADED)
                Send OnPageloaded (lParam + 1)
                Case Break
            Case (wParam = LS_VIEWERCONTROL_NTFY_UPDATETOOLBAR)
                Send OnUpdateToolbar 0
                Case Break
            Case (wParam = LS_VIEWERCONTROL_NTFY_TOOLBARUPDATE)
                Send OnToolbarUpdate
                Case Break                
            Case (wParam = LS_VIEWERCONTROL_NTFY_BTNPRESSED)
                Send OnBtnPressed lParam
                If (lParam=114) Begin
                    If (piAssociatedLLObj(Self)<>0) Begin
                        Set pbPreviewExitButtonClicked of (piAssociatedLLObj(Self)) to True
                    End
                End
                Case Break                
            Case (wParam = LS_VIEWERCONTROL_NTFY_EXITBTNPRESSED)
                Send OnExitBtnPressed
                Case Break
            Case ( (wParam = LS_VIEWERCONTROL_NTFY_PRINT_PAGE) Or ;
                   (wParam = LS_VIEWERCONTROL_NTFY_PRINT_START) Or ;
                   (wParam = LS_VIEWERCONTROL_NTFY_PRINT_END) )
                Move (CopyMemoryE(AddressOf(aPrinterData),lParam,SizeOfType(scViewerControlPrintData))) to iRet
                Move aPrinterData.nSize to iSize
                Move aPrinterData.nPages to iPages
                Move aPrinterData.nAbcAbcCopies to iAbcCopies
                Move aPrinterData.nPage to iPage
                Move aPrinterData.nCopy to iCopy
                Move aPrinterData.nAbcAbcCopy to iAbcCopy
                If (aPrinterData.pszDevice<>0) ;
                    Get StringFromPointer aPrinterData.pszDevice to sDevice
                If (aPrinterData.pszProject<>0) ;
                    Get StringFromPointer aPrinterData.pszProject to sProject
                If (aPrinterData.pszJobName<>0) ;
                    Get StringFromPointer aPrinterData.pszJobName to sJobName
                If (wParam = LS_VIEWERCONTROL_NTFY_PRINT_PAGE) ;
                    Get msg_OnPrintPage iPages iAbcCopies (iPage+1) iCopy iAbcCopy sDevice sProject sJobName to iRet
                If (wParam = LS_VIEWERCONTROL_NTFY_PRINT_START) ;
                    Get msg_OnPrintStart iPages iAbcCopies iPage iCopy iAbcCopy sDevice sProject sJobName to iRet
                If (wParam = LS_VIEWERCONTROL_NTFY_PRINT_END) ;
                    Get msg_OnPrintEnd iPages iAbcCopies iPage iCopy iAbcCopy sDevice sProject sJobName to iRet
                Set windows_override_state to TRUE
                Procedure_Return iRet
                Case Break                
            Case (wParam = LS_VIEWERCONTROL_QUEST_BTNSTATE) 
                Get msg_OnQuestBtnState lParam to iRet
                Set windows_override_state to True
                If ( (pbIsEmbeddedObject(Self)) and (lParam=114) ) Begin
                    Move -1 to iRet
                End
                Procedure_Return iRet
                Case Break
            Case (wParam = LS_VIEWERCONTROL_NTFY_KEYBOARDMESSAGE)
                Move (CopyMemoryE(AddressOf(aKeyboardMsg),lParam,SizeOfType(scViewerKeyboardMSG))) to iRet
                Move aKeyboardMsg.message to iMsg
                Move aKeyboardMsg.wParam to wPara
                Move aKeyboardMsg.lParam to lPara
                
                Get msg_onKeyboardMessage iMsg wPara lPara to iRet
                If (iRet<>0) Begin
                    Set windows_override_state to TRUE
                    Procedure_Return 1
                End
                
                If (GetForegroundWindowEf()<>(window_handle(self))) Begin
                    If ( (iMsg=WM_KEYDOWN) Or (iMsg=WM_KEYUP) Or (iMsg=WM_CHAR) ) Begin
                        Move (SendMessage(window_handle(self),iMsg,wPara,lPara)) to iRet
                        If (Not(active_state(self))) Begin
                            Set windows_override_state to TRUE
                            Procedure_Return 1                        
                        End    
                    End
                End
                Case break
            Case (wParam = LS_VIEWERCONTROL_NTFY_DOWNLOADFINISHED)
                Send OnDownloadFinished lParam
                Case Break
            Case (wParam = LS_VIEWERCONTROL_QUEST_DRILLDOWNSUPPORT)
                Get pbPreviewRunning to iRet
                Set Windows_Override_State to True
                Procedure_Return (not(iRet))
                Case Break
            Case (wParam = LS_VIEWERCONTROL_NTFY_SETDFFOCUS)
                Set focus to (self)
                Case break
        Case End
        Procedure_Return 0
    End_Procedure

    #IF (!@ >= 120)
    { MethodType=Event Visibility=Private }
    #ENDIF    
    Procedure Set focus Handle hoObj
        Integer iRet
        Forward Set focus to hoObj
        Move (SetFocus(window_handle(self))) to iRet
    End_Procedure
    #IF (!@ > 79)
    Function ContainerFocusWillNotChange Returns Integer
        Function_Return (client_area_state(self) And containsFocus(self))
    End_Function
    #ENDIF
    
    // Properties to Control the Viewer
    
    // pbToolbarVisible: Controls if the internal Toolbar is used.
    #IF (!@ >= 120)
    { MethodType=Property }
    { EnumList="True,False" }
    #ENDIF    
    Procedure Set pbToolbarVisible Integer iState
        Integer iRet
        Set Private.pbToolbarVisible to iState
        If (window_handle(self)) Begin
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_TOOLBAR,iState)) to iRet
        End    
    End_Procedure
    #IF (!@ >= 120)
    { MethodType=Property }
    { EnumList="True,False" }
    #ENDIF    
    Function pbToolbarVisible Returns Integer
        Function_Return (Private.pbToolbarVisible(self))
    End_Function
    
    // pbSketchbarVisible: Controls if the Sketchbar (the small Page-Previews) is visible.
    #IF (!@ >= 120)
    { MethodType=Property  }
    { EnumList="True,False" }
    #ENDIF    
    Procedure Set pbSketchbarVisible Integer iState
        Integer iRet
        Set Private.pbSketchbarVisible to iState
        If (window_handle(self)) Begin
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_SKETCHBAR,iState)) to iRet
        End    
    End_Procedure
    #IF (!@ >= 120)
    { MethodType=Property }
    { EnumList="True,False" }
    #ENDIF    
    Function pbSketchbarVisible Returns Integer
        Function_Return (Private.pbSketchbarVisible(self))
    End_Function
    
    // piSketchbarWidth: Controls the Width of the Sketchbar in Pixels 
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Procedure Set piSketchbarWidth Integer iWidth
        Integer iRet
        Set Private.piSketchbarWidth to iWidth
        If (window_handle(self)) Begin
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_SKETCHBARWIDTH,iWidth)) to iRet
        End            
    End_Procedure
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Function piSketchbarWidth Returns Integer
        Integer iRet
        If (window_handle(self)) Begin
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_GET_OPTION,LS_OPTION_SKETCHBARWIDTH,0)) to iRet
            Set Private.piSketchbarWidth to iRet
        End                    
        Function_Return (Private.piSketchbarWidth(self))
    End_Function
    
    // piToolbarStyle: Controls the Style of the internal Toolbar. Possible Values are
    // LS_OPTION_TOOLBARSTYLE_STANDARD
    // LS_OPTION_TOOLBARSTYLE_OFFICEXP
    // LS_OPTION_TOOLBARSTYLE_OFFICE2003
    #IF (!@ >= 120)
    { MethodType=Property }
    { EnumList="LS_OPTION_TOOLBARSTYLE_STANDARD, LS_OPTION_TOOLBARSTYLE_OFFICEXP, LS_OPTION_TOOLBARSTYLE_OFFICE2003" }
    #ENDIF    
    Procedure Set piToolbarStyle Integer iStyle
        Set Private.piToolbarStyle to iStyle
    End_Procedure
    #IF (!@ >= 120)
    { MethodType=Property }
    { EnumList="LS_OPTION_TOOLBARSTYLE_STANDARD, LS_OPTION_TOOLBARSTYLE_OFFICEXP, LS_OPTION_TOOLBARSTYLE_OFFICE2003" }
    #ENDIF    
    Function piToolbarStyle Returns Integer
        Function_Return (Private.piToolbarStyle(self))
    End_Function
    
    // piMouseMode: Controls whether dragging the Mouse do a Zoom or a move
    // LS_OPTION_MOUSEMODE_MOVE
    // LS_OPTION_MOUSEMODE_ZOOM
    #IF (USELLVERSION>17)
    #IF (!@ >= 120)
    { MethodType=Property }
    { EnumList="LS_OPTION_MOUSEMODE_MOVE, LS_OPTION_MOUSEMODE_ZOOM" }
    #ENDIF    
    Procedure Set piMousemode Integer iMode
        Integer iRet
        Set Private.piMousemode to iMode
        If (window_handle(Self)<>0) Begin
            Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_MOUSEMODE,iMode)) to iRet
        End
    End_Procedure
    #IF (!@ >= 120)
    { MethodType=Property }
    { EnumList="LS_OPTION_MOUSEMODE_MOVE, LS_OPTION_MOUSEMODE_ZOOM" }
    #ENDIF    
    Function piMousemode Returns Integer
        Function_Return (Private.piMouseMode(Self))
    End_Function    
    #ENDIF
    
    // piBgColor: Set's the Background Color of the Viewer Object as a (rgb(r,g,b)) Value
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Procedure Set piBgColor Integer iColor
        Integer iRet
        Set Private.piBgColor to iColor
        If ( (window_handle(self)) And (iColor <> 0) ) Begin
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_BGCOLOR,iColor)) to iRet
        End            
    End_Procedure
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Function piBgColor Returns Integer
        Function_Return (Private.piBgColor(self))
    End_Function
    
    // piLanguage: Set's the used Language of the Object. You can use all CMBTLANG_ Constants
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Procedure Set piLanguage Integer iLanguage
        Integer iRet
        Set Private.piLanguage to iLanguage
        If (window_handle(self)) Begin
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_LANGUAGE,iLanguage)) to iRet
        End            
    End_Procedure
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Function piLanguage Returns Integer
        Function_Return (Private.piLanguage(self))
    End_Function
    
    // Used to set the Objects Properties after the Control is displayed
    #IF (!@ >= 120)
    { MethodType=Event }
    { Visibility=Private }
    #ENDIF        
    Procedure page Integer iPage
        Integer iRet
        Handle hWndFocus
        Forward Send Page iPage
        If (iPage) Begin
            Set Private.piLastKeyMessage to 0
            Set Private.piLastKey to 0
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_MESSAGE,(WM_USER+531))) to iRet
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_USERDATA,(window_handle(self)))) to iRet
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_LANGUAGE,(Private.piLanguage(self)))) to iRet
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_TOOLBARSTYLE,(Private.piToolbarStyle(self)))) to iRet
            Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_TOOLBAR,(Private.pbToolbarVisible(Self)))) to iRet
            #IF (USELLVERSION>17)
            Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_MOUSEMODE,(Private.piMouseMode(Self)))) to iRet
            #ENDIF
            If (Private.piBgColor(self)<>0) Begin
                Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_BGCOLOR,(Private.piBgColor(self)))) to iRet
            End
            If (psFileToDisplay(self)<>"") Begin
                Set FileUrl to (psFileToDisplay(self))
                Set psFileToDisplay to ""
            End
        End
    End_Procedure
    #IF (!@ >= 120)
    { MethodType=Event }
    { Visibility=Private }
    #ENDIF
    
    Function subview_changed Returns Integer
        Integer iRetVal iObj
        Get object_id Of (piAssociatedLLObj(self)) to iObj
        If (iObj<>0) Begin
            Send DoDisableOtherWindows to (piAssociatedLLObj(self)) False
        End        
        Function_Return 0
    End_Function
    
    Procedure deactivating
        Integer iRetVal iObj iRet 
        If (piObjectAssociatedToLLObj(Self)<>0) Begin
            Get Object_Id of (piObjectAssociatedToLLObj(Self)) to iObj
            If (iObj<>0) Begin
                Get LLAssociatePreviewControl of iObj 0 0 to iRet
                Set piObjectAssociatedToLLObj to 0
            End
        End
        If (Private.phStgHandle(Self)<>0) Begin
            Move (LlStgsysStorageCloseEf(private.phStgHandle(Self))) to iRet
            Set private.phStgHandle to 0
        End
        If (pbPreviewRunning(Self)<>0) Begin
            Get object_id of (piAssociatedLLObj(Self)) to iObj
            If (iObj<>0) Begin
                Send DoDisableOtherWindows to (piAssociatedLLObj(Self)) False
            End        
        End
        Forward Get msg_deactivating to iRetVal
        If (iRetVal=0) Begin
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_PROGRESSINFO,-1,0)) to iRet
            Get object_id Of (piAssociatedLLObj(self)) to iObj
            If (pbPreviewRunning(self)<>0) Begin
                If (iObj<>0) Begin
                    Get LLPrintAbort Of iObj to iRet
                End    
            End
        End
        Procedure_Return iRetVal
    End_Procedure
    
    // This solves a problem with the width of the Sketchbar when the Viewer-Window is minimized and restored
    // again.
    #IF (!@ >= 120)
    { MethodType=Event }
    { Visibility=Private }
    #ENDIF        
    Procedure DoApplyAnchors Integer iX Integer iY
        Integer iSketchbarWidth iWidth iHeight
        Move (piSketchbarWidth(self)) to iSketchbarWidth
        Forward Send DoApplyAnchors iX iY
        If ( (hi(GuiSize(self))<40) Or (low(GuiSize(self))<40) ) Begin
            If (piOriginalSketchbarWidth(Self)=0) ;
                Set piOriginalSketchbarWidth to iSketchbarWidth
        End
        Else Begin
            If (piOriginalSketchbarWidth(self)<>0) Begin
                Set piSketchbarWidth to (piOriginalSketchbarWidth(self))
            End    
            Set piOriginalSketchbarWidth to 0
        End
    End_Procedure    
    
    // Commands 
    
    // Set FileUrl: Loads and displays the passed *.LL Preview File
    
    Procedure Set FileUrl String sFile
        String sVar1 sVar2
        Pointer pVar1 pVar2
        Integer iRet iStg hoFocus hFocusWnd 
        #IF (!@>199)
        Longptr hStg
        #ELSE
        Handle hStg
        #ENDIF
        Set Private.psFileUrl to sFile
        If (not(window_handle(Self))) ;
            Procedure_Return
        
        Move (Focus(desktop)) to hoFocus
        
        If (private.phStgHandle(self)<>0) Begin
            Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_HANDLE,0,0)) to iRet
            Move (LlStgsysStorageCloseEf(private.phStgHandle(self))) to iRet
            Set private.phStgHandle to 0
        End
        
        If (trim(sFile)<>"") Begin
            #IF (!@>199)
            Move (LlStgsysStorageOpenEf(sFile,"",False,True)) to hStg
            #ELSE
            Move (sFile + (Character(0))) to sVar1
            Move (AddressOf(sVar1)) to pVar1
            Move (OemToAnsi(pVar1,pVar1)) to iRet
            
            Get TempDirectory to sVar2
            Move (sVar2+(Character(0))) to sVar2
            Move (AddressOf(sVar2)) to pVar2
            Move (OemToAnsi(pVar2,pVar2)) to iRet
            
            Move (LlStgsysStorageOpenEf(pVar1,0,False,True)) to hStg
            #ENDIF
            If (hStg<>0) Begin
                Set private.phStgHandle to hStg
                Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_HANDLE,hStg,0)) to iRet
                Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_OPTION,LS_OPTION_SKETCHBAR,(Private.pbSketchbarVisible(self)))) to iRet
            End    
            If (Private.piSketchbarWidth(self)<>0) Begin
                Set piSketchbarWidth to (Private.piSketchbarWidth(self))
            End            
        End    
        Send activate to hoFocus 
    End_Procedure    
    
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF        
    Function FileUrl Returns String
        Function_Return (Private.psFileUrl(self))
    End_Function
    Function FileName Returns String
        #IF (!@>199)
        WString wBuff
        Integer iRet
        Move (Repeat(Character(0),2048)) to wBuff
        Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_GET_FILENAME,4096,AddressOf(wBuff))) to iRet
        Function_Return (CString(wBuff))
        #ELSE
        String sFile
        Pointer pFile
        Integer iRet
        Move (LLZeroString(2048)) to sFile
        Move (AddressOf(sFile)) to pFile
        Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_GET_FILENAME,2048,pFile)) to iRet
        Move (AnsiToOem(pFile,pFile)) to iRet
        Function_Return (CString(sFile))
        #ENDIF
    End_Function
    
    // Pages: returns the Number of Pages that are available in the loaded Preview File
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Function Pages Returns Integer
        Function_Return (SendMessage(window_handle(self),LS_VIEWERCONTROL_GET_PAGECOUNT,0,0))        
    End_Function
    
    // CurrentPage: Returns or sets the Page currently visible.
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Function CurrentPage Returns Integer
        Integer iPage
        Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_GET_PAGE,0,0)) to iPage
        Function_Return (iPage+1)
    End_Function    

    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Procedure Set CurrentPage Integer iPage
        Move (iPage-1) to iPage
        If (iPage<0) ;
            Procedure_Return
        Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_PAGE,iPage,0)) to iPage
    End_Procedure
    
    // GotoLast: Jumps to last Page
    Procedure GotoLast
        Integer iRet iPage
        Move (pages(self)) to iPage
        Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_PAGE,(iPage-1),0)) to iRet 
    End_Procedure
    
    // GotoFirst: Jumps to first Page
    Procedure GotoFirst
        Integer iRet 
        Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_SET_PAGE,0,0)) to iRet 
    End_Procedure
    
    // GotoPrev: Displays the Previous Page
    Procedure GotoPrev
        Integer iRet iPage
        Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_GET_PAGE,0,0)) to iPage
        If (iPage>0) ;
            Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_SET_PAGE,(iPage-1),0)) to iRet  
    End_Procedure
    
    // GotoNext: Displays the next Page
    Procedure GotoNext
        Integer iRet iPage
        Move (SendMessage(window_handle(self),LS_VIEWERCONTROL_GET_PAGE,0,0)) to iPage
        If (iPage<(pages(Self)-1)) ;
            Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_SET_PAGE,(iPage+1),0)) to iRet          
    End_Procedure
    
    // GotoNextStorage: Displays the next Storage
    Procedure GotoNextStorage
        Integer iRet iPage
        Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_OPEN_NEXTSTG,0,0)) to iRet
    End_Procedure    
    
    // GotoPrevStorage: Displays the previous Storage
    Procedure GotoPrevStorage
        Integer iRet iPage
        Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_OPEN_PREVSTG,0,0)) to iRet
    End_Procedure        
    
    // ZoomTimes2: Set the Zoom 2 times greater
    Procedure ZoomTimes2
        Integer iRet
        Move (sendMessage(window_handle(self),LS_VIEWERCONTROL_SET_ZOOM_TWICE,0,0)) to iRet
    End_Procedure
    
    // ZoomReset: Resets the Zoom to display the complete Page
    Procedure ZoomReset
        Integer iRet
        Move (sendMessage(window_handle(self),LS_VIEWERCONTROL_RESET_ZOOM,0,0)) to iRet
    End_Procedure
    
    // ZoomRevert: Undo the Zoom Action
    Procedure ZoomRevert
        Integer iRet
        Move (sendMessage(window_handle(self),LS_VIEWERCONTROL_POP_ZOOM,0,0)) to iRet
    End_Procedure
    
    // ZoomPageWidth: Zoom to Page Width
    Procedure ZoomPageWidth
        Integer iRet
        Move (SendMessage(Window_Handle(Self),LS_VIEWERCONTROL_SET_ZOOM,0,1)) to iRet
    End_Procedure
    
    // Display Preview as Screen-Presentation 
    // iMode: 1=With Frame
    //        2=Without Frame
    Procedure SwitchToTheaterMode Integer iMode
        Integer iRet
        Move (sendMessage(window_handle(self),LS_VIEWERCONTROL_SET_THEATERMODE,iMode,0)) to iRet
    End_Procedure

    // PrintAll: Prints all Pages. If you deliver 1 for the iPrinterSelect Parameter the Printer
    // Selection Window is also displayed.
    Procedure PrintAll Integer iPrinterSelect
        Integer iRet
        Move (sendMessage(window_handle(self),LS_VIEWERCONTROL_PRINT_ALL,iPrinterSelect,0)) to iRet        
    End_Procedure

    // PrintAll: Prints the current Page. If you deliver 1 for the iPrinterSelect Parameter the Printer
    // Selection Window is also displayed.
    Procedure PrintCurrent Integer iPrinterSelect
        Integer iRet
        Move (sendMessage(window_handle(self),LS_VIEWERCONTROL_PRINT_CURRENT,iPrinterSelect,0)) to iRet        
    End_Procedure

    // SaveToFile: Saves the current Preview File into a LL File.
    Procedure SaveToFile String sOptFormat
        Integer iRet 
        String sFormat
        Pointer pFormat
        #IF (!@>199)
        WString wVar
        #ENDIF        
        If (num_arguments>=1) Begin
            #IF (!@>199)
            Move (sOptFormat +Character(0)) to wVar
            #ELSE
            Move sOptFormat to sFormat
            Move (sFormat+(Character(0))) to sFormat
            Move (AddressOf(sFormat)) to pFormat
            Move (OemToAnsi(pFormat,pFormat)) to iRet
            #ENDIF
        End
        #IF (!@>199)
        Move (sendMessage(window_handle(Self),LS_VIEWERCONTROL_SAVE_TO_FILE,0,addressof(wVar))) to iRet        
        #ELSE
        Move (sendMessage(window_handle(Self),LS_VIEWERCONTROL_SAVE_TO_FILE,0,pFormat)) to iRet        
        #ENDIF
    End_Procedure    
    
    // Returns the StorageHandle of the displayed LL File
    #IF (!@>199)
    Function CurrentStgHandle Returns Longptr
        Longptr hRet
        Move (private.phStgHandle(Self)) to hRet
        If (hRet=0) Begin
            Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_GET_HANDLE,0,0)) to hRet
        End
        Function_Return hRet
    End_Function        
    #ELSE
    Function CurrentStgHandle Returns Integer
        Handle hRet
        Move (private.phStgHandle(self)) to hRet
        If (hRet=0) Begin
            Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_GET_HANDLE,0,0)) to hRet
        End
        Function_Return hRet
    End_Function    
    #ENDIF
    
    // IsZoomed: Returns TRUE if the Display is currently zoomed
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Function IsZoomed Returns Integer
        Function_Return (SendMessage(window_handle(self),LS_VIEWERCONTROL_GET_ZOOMED,0,0)) 
    End_Function
    
    // ZoomFactor: Returns/Set's the current Zoom Factor
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Function ZoomFactor Returns Integer
        Function_Return (SendMessage(window_handle(Self),LS_VIEWERCONTROL_GET_ZOOM,0,0)) 
    End_Function    
    
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Procedure Set ZoomFactor Integer iPercent
        Integer iRet
        Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_SET_ZOOM,iPercent,1)) to iRet
    End_Procedure
    
    // HasPrevStorage: Returns True if the Current Preview has a previous Storage (Drilldown)
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Function HasPrevStorage Returns Integer
        Function_Return (SendMessage(window_handle(Self),LS_VIEWERCONTROL_GET_ENABLED,LS_VCITEM_PREVSTG,0)) 
    End_Function    
    
    // HasNextStorage: Returns True if the Current Preview has a next Storage (Drilldown)
    #IF (!@ >= 120)
    { MethodType=Property }
    #ENDIF    
    Function HasNextStorage Returns Integer
        Function_Return (SendMessage(window_handle(Self),LS_VIEWERCONTROL_GET_ENABLED,LS_VCITEM_NEXTSTG,0)) 
    End_Function
    // SendAsMail: Sends the current Preview File as a Mail Attachment via MAPI
    Procedure SendAsMail
        Integer iRet
        Move (sendMessage(window_handle(self),LS_VIEWERCONTROL_SEND_AS_MAIL,0,0)) to iRet
    End_Procedure
    
    Procedure DoSearch String sText Integer bFindNext Integer bCaseSensitive
        Integer iRet iOpts iLength
        String sVal
        Pointer pVal
        
        If (bFindNext) ;
            Move LS_VCITEM_SEARCH_NEXT to iOpts
        Else ;
            Move LS_VCITEM_SEARCH_FIRST to iOpts
        If (not(bCaseSensitive)) ;
            Move (iOpts ior LS_VCITEM_SEARCHFLAG_CASEINSENSITIVE) to iOpts
        #IF (!@>199)
        WString wVal
        Move sText to wVal
        Move (SendMessage(Window_Handle(Self),LS_VIEWERCONTROL_SEARCH,iOpts,AddressOf(wVal))) to iRet
        #ELSE
        Move (sText + (Character(0))) to sVal
        Move (AddressOf(sVal)) to pVal
        Move (OemToAnsi(pVal,pVal)) to iRet
        Move (SendMessage(Window_Handle(Self),LS_VIEWERCONTROL_SEARCH,iOpts,pVal)) to iRet
        #ENDIF
    End_Procedure
    
    Function IsSearchActive Returns Integer
        Integer iRet
        Move (SendMessage(Window_Handle(Self),LS_VIEWERCONTROL_GET_SEARCHSTATE,0,0)) to iRet
        Function_Return iRet
    End_Function
    
    // Clears the current Preview and releases temporary Files
    Procedure DoClearPreview
        Integer iRet
        Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_SET_HANDLE,0,0)) to iRet
        If (private.phStgHandle(self)<>0) Begin
            Move (LlStgsysStorageCloseEf(private.phStgHandle(Self))) to iRet
            Set private.phStgHandle to 0
        End        
    End_Procedure

    #IF (!@ >= 120)
    { MethodType=Event Visibility=Private }
    #ENDIF    
    Procedure destroy
        Integer iRet
        If (private.phStgHandle(self)<>0) Begin
            Move (SendMessage(window_handle(Self),LS_VIEWERCONTROL_SET_HANDLE,0,0)) to iRet
            Move (LlStgsysStorageCloseEf(private.phStgHandle(self))) to iRet
            Set private.phStgHandle to 0
        End
        Forward Send destroy
    End_Procedure
End_Class

#IF (!@ >= 120)
{ OverrideProperty=Bitmap DesignTime=False }
{ OverrideProperty=Size InitialValue=100,100 }
{ OverrideProperty=Size DesignTime=False }
{ OverrideProperty=Size InitialValue=60,120 }
{ OverrideProperty=Location InitialValue=0,0 }
{ OverrideProperty=Border_Style InitialValue=Border_ClientEdge }
{ OverrideProperty=Border_Style EnumList="Border_None, Border_Normal, Border_Dialog, Border_ClientEdge, Border_WindowEdge, Border_StaticEdge" }
#ENDIF
#IFNDEF Is$WebApp
Class cListLabelViewer is a cVDFListLabelViewer
End_Class
Use Dfrptvw.pkg
#IF (!@ >= 120)
{ ComponentType=RVClass }
#ENDIF
Class cListLabelReportView is a ReportView
    Procedure Close_Panel_Or_Cancel_Report
        Handle hoObj hoLL
        Integer iRet iJob
        Broadcast Recursive Get fIsLLPreviewObject to hoObj
        If (hoObj<>0) Begin
            If (pbPreviewRunning(hoObj)) Begin
                Get piAssociatedLLObj of hoObj to hoLL    
                If (hoLL<>0) Begin
                    Get piJobNumber of hoLL to iJob
                    If (iJob<>0) Begin
                        Get LLPrintAbort of hoLL to iRet
                    End
                End
                Procedure_Return                        
            End
        End
        Send Close_Panel
    End_Procedure
    Function Verify_Exit_Application Returns Integer
        Handle hoObj    
        Broadcast Recursive Get fIsLLPreviewObject to hoObj
        If (hoObj<>0) Begin
            If (pbPreviewRunning(hoObj)) Begin        
                Function_Return 1            
            End
        End
        Function_Return 0
    End_Function    
    Procedure Close_Panel
        Handle hoObj    
        Broadcast Recursive Get fIsLLPreviewObject to hoObj
        If (hoObj<>0) Begin
            If (pbPreviewRunning(hoObj)) Begin
                Procedure_Return
            End        
        End
        Forward Send Close_Panel
    End_Procedure    
End_Class

#ENDIF

// Commands for easily defining Fields and Variables in List & Label
// Note: These commands are only valid inside the cListLabelWrapper Class in the DefineXXXField and DefineXXXVariable
//       so don't use them outside.
//
// Syntax is the same for DefineLLField and DefineLLVariable so only the DefineLLField is documented
//
// Syntax: DefineLLField Database
//         DefineLLField Database AS AliasnameforListLabel(string)
//         DefineLLField Database.Field
//         DefineLLField Property {of object} NameForListLabel(string) ListLabelType(ListLabelConstant i.E. LL_TEXT)
//         DefineLLField Image.N NameForListLabel(string)
//         DefineLLField StructureProperty VDFStructureType NameForListlabel(string)
//
// Examples:
//         DefineLLField FLEXERRS                      
//                       make complete DB Flexerrs available to List & Label (Name and type are evaluated from the database)
//
//         DefineLLField FLEXERRS as "VDFERRORDB"
//                       make complete DB Flexerrs available to List & Label, but not with the name FLEXERRS but with VDFERRORDB
//                       You can use this to define one Database a second Time in List & Label with a different name.
//                       When doing this you are self-responsible for transfering the correct Record 
//                       Each time the Alias Database have to be filled with actual data you have to 
//  
//                       - Store the current record of the Database
//                       - Find the needed record in the Database
//                       - Call the DoDefineUsedAliasFields/DoDefineUsedAliasVariables "AliasDBName"
//                       - Restore the original Record in the Database
// 
//         DefineLLField FLEXERRS.Note                 
//                       make only the Field Flexerrs.Note available to List & Label (Name and type is evaluated from the database)
//
//         DefineLLField psProperty "VALUE" LL_TEXT    
//                       make the property psProperty available to List & Label as Text with the name Value
//
//         DefineLLField psProperty of (someObject(someGroup(self))) "VALUE" LL_TEXT
//                       make the property psProperty defined in (someObject(someGroup)) available to List & Label as Text with the name Value
//
//         DefineLLField Window.1 "WINDOWVALUE"
//                       make the Image Window.1 available to List & Label with the name Windowvalue (type is evaluated from the window)          
//
//         DefineLLField paStructureProperty tStructureType "NAME"
//                       Define a Structure Property in Listlabel of type tStructureType and give the whole Structure the Name "NAME" 
//                       To use Structures you have to do the following:
//                       Define a normal VDF Structure with Struct/End_Struct
//                       Inside the List & Label Object you have to Define the same structure for List & Label with LLStruct/LLStructField/End_LLStruct 
//                       Create a Property inside the the List & Label Object based on the VDF Structure
//                       Set the Property with the Values needed.
//                       Example:
//
//                       // VDF Structure Definition
//                       Struct tAdditionalFooterLines
//                           String sLine1
//                           String sLine2
//                           String sLine3
//                           String sLine4
//                       End_Struct
//  
//                       // Inside the Listlabel Object
//                       Property tAdditionalFooterLines paFooterLines
//
//                       // Now tell List & Label about the Structure Definition
//                       // Format for LLStructField: 
//                       // LLStructField (Name of VDF Struct Part) (List & Label Name for this Field) (List & Label Type)
//                       LLStruct tAdditionalFooterLines
//                           LLStructField sLine1 "Footerline 1" LL_Text
//                           LLStructField sLine2 "Footerline 2" LL_Text
//                           LLStructField sLine3 "Footerline 3" LL_Text
//                           LLStructField sLine4 "Footerline 4" LL_Text
//                       End_LLStruct
//
//                       // Define the Structure in List & Label
//                       Procedure DefineAllFields
//                           Forward Send DefineAllFields
//                           DefineLLVariable paFooterLines tAdditionalFooterlines "Footerlines"
//                       End_Procedure
// 
//                       Now you can set and transfer a whole bunch of values to List & Label with only
//                       one call
//                       set paFooterLines to {NameofyourtAdditionalFooterlinesVariable}

#COMMAND DefineLLField
    #IFCLASS !1 "FW"                     // FIELD or Image
        #IFCLASS !1 "W"                  // Image
            #IF (!0>2)
                Send DefineWindowFieldCommand !2 !3 $!1
            #ELSE   
                #IFTYPE !1 "S"                   // String
                    Send DefineWindowFieldCommand !2 LL_TEXT $!1
                #ENDIF
                #IFTYPE !1 "D"                   // Date
                    Send DefineWindowFieldCommand !2 LL_DATE_LOCALIZED $!1
                #ENDIF
                #IFTYPE !1 "IN"                  // Number or Integer
                    Send DefineWindowFieldCommand !2 LL_NUMERIC $!1
                #ENDIF
            #ENDIF    
        #ELSE                            // Field
            #PUSH !g
            #PUSH !h
            #SET G$ !1
            #SET H$ %!1
            Send DefineDbFieldCommand |CI!g |CI!h
            #POP H$
            #POP G$        
        #ENDIF    
    #ELSE
        #SPUSH !$
        #SET $$ !1
        #IFDEF !$.FILE_NUMBER           // FILE
            #IF (!0>2)
                #IFSAME !2 AS
                    #IF (!@>109)
                        Send DefineAliasDbFieldsCommand !$.FILE_NUMBER !3
                    #ELSE
                        #ERROR 700 DefineLLField Database AS is only supported on VDF 11.0 Or higher
                    #ENDIF    
                #ELSE
                    #ERROR 700 Unknown Parameter passed to DefineLLField    
                #ENDIF
            #ELSE
                Send DefineDbFieldsCommand !$.FILE_NUMBER
            #ENDIF
        #ELSE
            #IFDEF GET_!1                           // Property
                #IFDEF _struct_!2
                    #IFDEF GET_!1
                        #IFDEF MSG_DoTransfertptLL!2Struct
                            Send DefineStructFieldCommand GET_!1 MSG_DoTransfertptLL!2Struct !3
                        #ELSE
                            #ERROR 700 Illegal Structure Definition passed to DefineLLField
                        #ENDIF
                    #ELSE
                        #ERROR 700 Illegal Structure Property passed to DefineLLField
                    #ENDIF
                #ELSE
                    #IFSAME !2 Of
                        #IFDEF GET_!3
                            #IF (GET_!3>$40000000)
                                 Send DefinePropertyFieldCommand !4 !5 GET_!1 (!3(self))
                            #ENDIF
                        #ELSE
                        Send DefinePropertyFieldCommand !4 !5 GET_!1 !3
                        #ENDIF        
                    #ELSE
                        Send DefinePropertyFieldCommand !2 !3 GET_!1 self
                    #ENDIF
                #ENDIF
            #ELSE                                  
                #ERROR 700 Unknown Parameter passed to DefineLLField
            #ENDIF                
        #ENDIF
        #SPOP $$    
    #ENDIF                    
#ENDCOMMAND

#COMMAND DefineLLVariable
    #IFCLASS !1 "FW"                     // FIELD or Image
        #IFCLASS !1 "W"                  // Image
            #IF (!0>2)
                Send DefineWindowVariableCommand !2 !3 $!1
            #ELSE
                #IFTYPE !1 "S"                   // String
                    Send DefineWindowVariableCommand !2 LL_TEXT $!1
                #ENDIF
                #IFTYPE !1 "D"                   // Date
                    Send DefineWindowVariableCommand !2 LL_DATE_LOCALIZED $!1
                #ENDIF
                #IFTYPE !1 "IN"                  // Number or Integer
                    Send DefineWindowVariableCommand !2 LL_NUMERIC $!1
                #ENDIF
            #ENDIF    
        #ELSE                            // Field
            #PUSH !g
            #PUSH !h
            #SET G$ !1
            #SET H$ %!1
            Send DefineDbVariableCommand |CI!g |CI!h
            #POP H$
            #POP G$        
        #ENDIF    
    #ELSE    
        #SPUSH !$
        #SET $$ !1
        #IFDEF !$.FILE_NUMBER           // FILE
            #IF (!0>2)
                #IFSAME !2 AS
                    #IF (!@>109)
                        Send DefineAliasDbVariablesCommand !$.FILE_NUMBER !3
                    #ELSE
                        #ERROR 700 DefineLLVariable Database AS is only supported on VDF 11.0 Or higher
                    #ENDIF                
                #ELSE
                    #ERROR 700 Unknown Parameter passed to DefineLLVariable
                #ENDIF
            #ELSE
                Send DefineDbVariablesCommand !$.FILE_NUMBER
            #ENDIF
        #ELSE
            #IFDEF GET_!1                           // Property
                #IFDEF _struct_!2
                    #IFDEF GET_!1
                        #IFDEF MSG_DoTransfertptLL!2Struct
                            Send DefineStructVariableCommand GET_!1 MSG_DoTransfertptLL!2Struct !3
                        #ELSE
                            #ERROR 700 Illegal Structure Definition passed to DefineLLField
                        #ENDIF
                    #ELSE
                        #ERROR 700 Illegal Structure Property passed to DefineLLField
                    #ENDIF
                #ELSE            
                    #IFSAME !2 Of
                        #IFDEF GET_!3
                            #IF (GET_!3>$40000000)
                                 Send DefinePropertyVariableCommand !4 !5 GET_!1 (!3(self))
                            #ENDIF
                        #ELSE
                        Send DefinePropertyVariableCommand !4 !5 GET_!1 !3
                        #ENDIF        
                    #ELSE
                        Send DefinePropertyVariableCommand !2 !3 GET_!1 self
                    #ENDIF
                #ENDIF
            #ELSE                                  
                #ERROR 700 Unknown Parameter passed to DefineLLVariable
            #ENDIF                
        #ENDIF
        #SPOP $$    
    #ENDIF                    
#ENDCOMMAND

#COMMAND LLStruct
#IF (!@ >= 120)    
#IFDEF __@INSIDE_LLSTRUCT@__    
#ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "LLSTRUCT command within a LLSTRUCT. LLStructs cannot be Nested"
#ELSE
#IFDEF _struct_!1
Procedure DoTransfertptLL!1Struct Integer iProperty String sName Integer iAsVariables
    Integer iRet
    !1 sStructVar
    Get iProperty to sStructVar
    #SREP __@INSIDE_LLSTRUCT@__   |CI1
#ELSE
Error 700 Illegal Structure passed to LLStruct
#ENDIF
#ENDIF
#ELSE
#error 700 Structs can only be used with VDF 12 And higher
#ENDIF
#ENDCOMMAND

#COMMAND LLStructField
    #IF (!@ >= 120)
    #IFNDEF __@INSIDE_LLSTRUCT@__
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "LLSTRUCTField outside a LLStruct/End_LLStruct block."
    #ELSE
    If (iAsVariables<>1) ;
        Get LLDefineFieldExt (sName + "."+ !2) sStructVar.!1 !3 to iRet    
    Else ;
        Get LLDefineVariableExt (sName + "." +!2) sStructVar.!1 !3 to iRet    
    #ENDIF
    #ENDIF
#ENDCOMMAND

#COMMAND End_LLStruct
#IF (!@ >= 120)
#IFNDEF __@INSIDE_LLSTRUCT@__
#ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "End_LLStruct Command without LLStruct Command"
#ELSE
End_Procedure    
#UNDEF __@INSIDE_LLSTRUCT@__
#ENDIF
#ENDIF
#ENDCOMMAND

// **********************************************************************************************************
// Class-Definition for the cListLabelReport Class
// 
// The cListLabelReport Class is derived from the original cListLabelWrapper Class and therefore, it contains
// all Functionality of the original cListLabelWrapper Class. 
//
// The main advantages of this extended Class are:
//      * All Datadictionaries that are defined in your ReportView are automatically identified and all
//        Database Fields are automatically defined for your Report. There is no longer a need for defining
//        each Database with DefineLLField within the DefineAllFields Notification.
//      * All Child/Parent Relations are automatically defined within List & Label (only for List-Projects)
//      * For each Database, every Index is automatically defined within List & Label as Up or Down Index.
//        The Enduser can select the desired Sort-Order for each Table himself (again only for List-Projects)
//      * For List-Projects, the complete Report-Loop is completely encapsulated into the Class. The Programmer
//        just have to define the DataDictionaries in the Report View, let the user make Selections, set the 
//        appropriate Constraints and then print the complete Report with only one single Function (DoPrintList).
//        The Developer don't have to take care, if there are any attached Sub-Tables or following Tables,
//        all the Database Findings and the complete Report Loop are "hidden" behind the DoPrintList Function.
//      * Even almost everything is done automatically there are a bunch of Notifications which give the 
//        Developer the Opportunity to make the DB-Findings himself or to influence the Report.
// **********************************************************************************************************                    
                    
#IF (!@ >= 120)
{ ClassType=Normal }
{ ClassLibrary=Common }
{ Visibility=PUBLIC }
#ENDIF

Class cListLabelReport is a cListLabelWrapper  
    
    // Internal Functions and Definitions

    #IF (!@ >= 120)
    { MethodType=Method Visibility=Private }
    #ENDIF    
    Procedure construct_object
        Forward Send Construct_Object
        Property Integer phoMasterDD 0
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property String  psPrivate.ReportTable
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property String  psPrivate.ReportSortOrder
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property String  psPrivate.ReportRelation
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property String  psPrivate.ReportRelationParent
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer piPrivate.SaveTableSettings
        #IF (!@ >= 120)
        { Visibility=Private }
        #ENDIF        
        Property Integer pbPrivate.TableSelectCancelled
        Property Integer pbDesignerPreview False
        Object oDDos is a Set 
        End_Object
        Object oTableIds is a Array 
        End_Object
        Object oCurrentDDos is a Array 
        End_Object
        Object oTables is a Array 
        End_Object
        Object oTableSortOrders is a Array 
        End_Object
        Object oTableRelations is a Array 
        End_Object
    End_Procedure
    
    Function LLDbAddTable String sTableId String sDisplayName Returns Integer
        Integer iRetVal
        If (piProjectType(Self)=LL_PROJECT_LIST) Begin
            Forward Get LLDbAddTable sTableId sDisplayName to iRetVal
        End
        Else Begin
            Move 0 to iRetVal
        End
        #IF (!@>109)
        String[] sAdditionalTables
        Get psDrillDownAdditionalTables to sAdditionalTables
        Move (trim(sTableId)) to sAdditionalTables[(SizeOfArray(sAdditionalTables))]
        Set psDrilldownAdditionalTables to sAdditionalTables
        #ENDIF
        Set value of (oTables(Self)) (item_count(oTables(Self))) to (trim(sTableId) + ";" + (trim(sDisplayName)))
        Function_Return iRetVal
    End_Function
    
    Function LlDbAddTableSortOrder String sTableId String sSortOrderId String sDisplayName Returns Integer
        Integer iRetVal
        If (piProjectType(self)=LL_PROJECT_LIST) Begin
            Forward Get LlDbAddTableSortOrder sTableId sSortOrderId sDisplayName to iRetVal
        End
        Else Begin
            Move 0 to iRetVal
        End
        Set value of (oTableSortOrders(Self)) (item_count(oTableSortOrders(Self))) to (trim(sTableId) + ";" + (trim(sSortOrderId)) + ";" + (trim(sDisplayName)) )
        Function_Return iRetVal
    End_Function
    
    Function LlDbAddTableRelation String sTableId String sParentId String sRelationId String sDisplayName Returns Integer
        Integer iRetVal
        If (piProjectType(self)=LL_PROJECT_LIST) Begin
            Forward Get LLDbAddTableRelation sTableId sParentId sRelationId sDisplayName to iRetVal
        End
        Else Begin
            Move 0 to iRetVal
        End
        Set value Of (oTableRelations(self)) (item_count(oTableRelations(self))) to (trim(sTableId)+";"+(trim(sParentId))+";"+(trim(sRelationId))+";"+(trim(sDisplayName)))
        Function_Return iRetVal
    End_Function
    
    Function LlDbAddTableRelationEx String sTableId String sParentId String sRelationId String sDisplayName String sKeyField String sParentKeyField Returns Integer
        Integer iRetVal
        If (piProjectType(Self)=LL_PROJECT_LIST) Begin
            Forward Get LLDbAddTableRelationEx sTableId sParentId sRelationId sDisplayName sKeyField sParentKeyField to iRetVal
        End
        Else Begin
            Move 0 to iRetVal
        End
        Set value of (oTableRelations(Self)) (item_count(oTableRelations(Self))) to (trim(sTableId)+";"+(trim(sParentId))+";"+(trim(sRelationId))+";"+(trim(sDisplayName)))
        Function_Return iRetVal    
    End_Function
    
    Function LLPrintDbGetCurrentTable Integer bCompletePath Returns String
        String sRetVal
        If (piProjectType(self)=LL_PROJECT_LIST) Begin
            Forward Get LLPrintDbGetCurrentTable bCompletePath to sRetVal
        End
        Else Begin
            Move (psPrivate.ReportTable(self)) to sRetVal
        End
        Function_Return sRetVal
    End_Function
    
    Function LLPrintDbGetCurrentTableSortOrder Returns String
        String sRetVal
        If (piProjectType(self)=LL_PROJECT_LIST) Begin
            Forward Get LLPrintDbGetCurrentTableSortOrder to sRetVal
        End
        Else Begin
            Move (psPrivate.ReportSortOrder(self)) to sRetVal
        End
        Function_Return sRetVal        
    End_Function

    Function LLPrintDbGetCurrentTableRelation Returns String
        String sRetVal
        If (piProjectType(self)=LL_PROJECT_LIST) Begin
            Forward Get LLPrintDbGetCurrentTableRelation to sRetVal
        End
        Else Begin
            Move (psPrivate.ReportRelation(self)) to sRetVal
        End
        Function_Return sRetVal        
    End_Function    
    
    
    Function LLJobClose Returns Integer
        Integer iRetVal iType iRet iCou iTableSet iSortOrderSet iRelationSet
        String sFile sVal sTable sSortOrder sRelation sMsg
        Handle hDom hVars hVar
        Get psCurrentProjectFile to sFile
        Get piProjectType to iType
        
        If (piPrivate.SaveTableSettings(self)=1) Begin
            Move (psPrivate.ReportTable(self)) to sTable
            Move (psPrivate.ReportSortOrder(self)) to sSortOrder
            Move (psPrivate.ReportRelation(self)) to sRelation
            Move (LLProjectOpen(self,iType,sFile,(LL_PRJOPEN_CD_OPEN_EXISTING Ior LL_PRJOPEN_AM_READWRITE))) to iRet
            If (iRet<>LL_ERR_LICENSEVIOLATION) Begin
                Move (LLDomGetProject(Self)) to hDom
                If (hDom>0) Begin
                    Move (LLDomGetObject(Self,hDom,"ProjectParameters")) to hVars
                    If (hVars>0) Begin
                        For iCou from 0 to (LLDomGetSubobjectCount(Self,hVars)-1)
                            Move (LLDomGetSubobject(Self,hVars,iCou)) to hVar
                            If (hVar<>0) Begin
                                Move (LLDomGetProperty(Self,hVar,"Name")) to sVal
                                If (sVal="VDF.Report.Table") Begin
                                    Move (LLDomSetProperty(Self,hVar,'Contents',((trim(sTable))))) to iRet
                                    Move 1 to iTableSet
                                End
                                If (sVal="VDF.Report.SortOrder") Begin
                                    Move (LLDomSetProperty(Self,hVar,'Contents',((trim(sSortOrder))))) to iRet
                                    Move 1 to iSortOrderSet
                                End
                                If (sVal="VDF.Report.Relation") Begin
                                    Move (LLDomSetProperty(Self,hVar,'Contents',((trim(sRelation))))) to iRet
                                    Move 1 to iRelationSet
                                End
                            End    
                        Loop
                        If (iRelationSet<>1) Begin
                            Move (LLDomCreateSubObject(Self,hVars,(LLDomGetSubObjectCount(Self,hVars)),"ProjectParameters")) to hVar
                            If (hVar<>0) Begin
                                Move (LLDomSetProperty(Self,hVar,"Name","VDF.Report.Relation")) to iRet
                                Move (LLDomSetProperty(Self,hVar,'Contents',((trim(sRelation))))) to iRet
                            End
                        End                                        
                        If (iSortOrderSet<>1) Begin
                            Move (LLDomCreateSubObject(Self,hVars,(LLDomGetSubObjectCount(Self,hVars)),"ProjectParameters")) to hVar
                            If (hVar<>0) Begin
                                Move (LLDomSetProperty(Self,hVar,"Name","VDF.Report.SortOrder")) to iRet
                                Move (LLDomSetProperty(Self,hVar,'Contents',((trim(sSortOrder))))) to iRet
                            End
                        End                    
                        If (iTableSet<>1) Begin
                            Move (LLDomCreateSubObject(Self,hVars,(LLDomGetSubObjectCount(Self,hVars)),"ProjectParameters")) to hVar
                            If (hVar<>0) Begin
                                Move (LLDomSetProperty(Self,hVar,"Name","VDF.Report.Table")) to iRet
                                Move (LLDomSetProperty(Self,hVar,'Contents',((trim(sTable))))) to iRet
                            End
                        End
                    End                
                End
                Move (LLProjectSave(self,"")) to iRet
                Move (LLProjectClose(self)) to iRet
            End
            Else Begin
                
                Move "Table Settings can't be saved automatically with the Standard-Edition of List & Label." to sMsg
                Move (sMsg + "\n\nSave the Project Properties with the List & Label Designer into the Projectfile as follows:") to sMsg
                Move (sMsg + "\n\nVDF.Report.Table: " + sTable) to sMsg
                Move (sMsg + "\nVDF.Report.SortOrder: " + sSortOrder) to sMsg
                Move (sMsg + "\nVDF.Report.Relation: " + sRelation) to sMsg
                #IFNDEF Is$WebApp
                Send info_box sMsg
                #ELSE
                Error 999 sMsg
                #ENDIF
            End
        End
        
        Forward Get LLJobClose to iRetVal
        
        Function_Return iRetVal
    End_Function
    
    Function DDoForTable String sTable Returns Integer
        Integer iItems iItem
        Integer hoDDo
        String sVal
        Get item_count Of oTableIds to iItems
        While (Pos(".",sTable)<>0)
            Move (Left(sTable,(Pos(".",sTable)))) to sVal
            Move (Replace(sVal,sTable,"")) to sTable
        End
        FOR iItem From 0 to (iItems-1)
            Get value Of oTableIds iItem to sVal
            If ((uppercase(sVal)=(uppercase(sTable)))) Begin
                Get value of oDDos iItem to hoDDo
                Function_Return hoDDo
            End
        Loop
        Function_Return 0
    End_Function
    
    // OnAddDictionary
    // Is called for each Dictionary Object that is about to be added to the Report
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object in Question
    //
    // Return Values:
    //              TRUE  Add the Dictionary and all connected Dictionaries to the Report
    //              FALSE Don't add the Dictionary and all connected Dictionaries
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnAddDictionary Integer hoDDo
        Procedure_Return (True)
    End_Procedure    
    Procedure DefineDDoStruct Handle hoDDo Integer bClients Integer bServers
        Integer iClients iCou iClientFile iServers iFile iRet iIndexes iIndex iSegments iSegment iField iDDoPos iFieldCou iFields iRelatedFile iRelatedField iParentFile iFirstIndex iRecnumTable
        Integer hoClient hoServer
        String sName sVal sIndex sParent sParentField sChildField
        tDbFile aFile aParentFile
        If (find_element(oDDOs(Self),hoDDo)<>-1) ;
            Procedure_Return
        
        Get msg_OnAddDictionary hoDDo to iRet
        If (not(iRet)) ;
            Procedure_Return
        
        Send add_element to oDDos hoDDo
        Get find_element Of oDDos hoDDo to iDDoPos
        Get main_file Of hoDdo to iFile
        If (iFile<>0) Begin
            Get fFileStruct iFile to aFile
            Move aFile.sLogicalName to sName
            Get LLDbAddTable sName sName to iRet
            Set value of oTableIds iDDoPos to sName            
            Move aFile.iRecnumTable to iRecnumTable
            If (iRecnumTable=(True)) ;
                Move 0 to iFirstIndex
            Else ;
                Move 1 to iFirstIndex
            Move aFile.iLastIndexNumber to iIndexes
            For iIndex from iFirstIndex to iIndexes
                Move aFile.aIndexes[iIndex].iSegments to iSegments
                If (iSegments<>0) Begin
                    Move "" to sIndex
                    FOR iSegment From 1 to iSegments
                        Move aFile.aIndexes[iIndex].aSegments[iSegment].iField to iField
                        Move aFile.aFields[iField].sName to sVal
                        If (iSegment=1) ;
                            Move (trim(sVal)) to sIndex
                        Else ;
                            Move (sIndex + ", " + (trim(sVal)) ) to sIndex
                    Loop
                    If (iIndex<>0) Begin
                        Get LLDbAddTableSortOrder sName iIndex (sIndex + " (Up)") to iRet
                        Get LLDbAddTableSortOrder sName (iIndex*-1) (sIndex + " (Down)") to iRet
                    End
                    Else Begin
                        Get LLDbAddTableSortOrder sName iIndex sIndex to iRet
                    End
                End
            Loop
            If (piProjectType(self)=LL_PROJECT_LIST) Begin
                If (hoDdo<>(phoMasterDD(self))) Begin
                    Get DefineCompleteDB iFile FALSE to iRet
                End
                Else Begin
                    Get LLDbSetMasterTable sName to iRet
                    Get DefineCompleteDB iFile TRUE to iRet
                End
                If (pbIsDrilldown(Self)) Begin
                    If (Uppercase(Trim(sName))=(psDrilldownBaseTable(Self))) Begin
                        Get DefineCompleteDb iFile True to iRet
                    End
                    #IF (!@>109)
                    Get msg_OnDrilldownUseTableAsVariable (Uppercase(Trim(sName))) (psDrilldownBaseTable(Self)) (psDrilldownSubreportTable(Self)) (psDrilldownRelationId(Self)) to iRet
                    If (iRet) Begin
                        Get DefineCompleteDb iFile True to iRet
                    End
                    #ENDIF
                End
            End
            Else Begin
                Get DefineCompleteDB iFile TRUE to iRet
            End
        End    

        If (bServers) Begin
            Get data_set_server_count Of hoDDo to iServers
            FOR iCou From 0 to (iServers-1)
                Get data_set_server Of hoDDo iCou to hoServer
                If (hoServer<>0) Begin
                    Send DefineDDoStruct hoServer FALSE TRUE
                End
            Loop
        End
        If (bClients) Begin
            Get data_set_client_count Of hoDDo to iClients
            FOR iCou From 0 to (iClients-1)
                Get data_set_client Of hoDDo iCou to hoClient
                If (hoClient<>0) Begin
                    Send DefineDDoStruct hoClient TRUE FALSE
                End
            Loop
        End
        
        Get main_file Of hoDdo to iFile
        If (iFile<>0) Begin
            Get fFileStruct iFile to aFile
            Move aFile.sLogicalName to sName
            Get data_set_server_count Of hoDDo to iServers
            FOR iCou From 0 to (iServers-1)
                Get data_set_server Of hoDDo iCou to hoServer
                If (hoServer<>0) Begin
                    Get main_file Of hoServer to iParentFile
                    If (iParentFile<>0) Begin
                        Get fFileStruct iParentFile to aParentFile
                        Move aParentFile.sLogicalName to sParent
                        #IF (!@>109)
                        If (pbUseDrilldown(Self)) Begin
                            Move "" to sParentField
                            Move "" to sChildField
                            Move aFile.iNumberFields to iFields
                            For iFieldCou from 0 to iFields
                                Move aFile.aFields[iFieldCou].iRelatedFile to iRelatedFile
                                If (iRelatedFile=iParentFile) Begin
                                    Move aFile.aFields[iFieldCou].iRelatedField to iRelatedField
                                    Move aFile.aFields[iFieldCou].sName to sVal
                                    Move (sChildField + sName + "." + sVal + (Character(9))) to sChildField
                                    Move aParentFile.aFields[iRelatedField].sName to sVal
                                    Move (sParentField + sParent + "." + sVal + (Character(9))) to sParentField
                                End
                            Loop
                            If ( (sParentField<>"") and (sChildField<>"") ) Begin
                                Move (Left(sParentField, (Length(sParentField)-1))) to sParentField
                                Move (Left(sChildField,(Length(sChildField)-1))) to sChildField
                                Get LLdbAddTableRelationEx sName sParent (sName+"->"+sParent) (sName+"->"+sParent) sChildField sParentField to iRet
                            End
                            Else Begin
                                Get LLdbAddTableRelation sName sParent (sName+"->"+sParent) (sName+"->"+sParent) to iRet
                            End
                        End
                        Else Begin
                            Get LLdbAddTableRelation sName sParent (sName+"->"+sParent) (sName+"->"+sParent) to iRet
                        End
                        #ELSE
                        Get LLdbAddTableRelation sName sParent (sName+"->"+sParent) (sName+"->"+sParent) to iRet
                        #ENDIF
                    End
                End
            Loop                        
        End
    End_Procedure
    
    Procedure DefineDDo Handle hoObj
        Send DefineDDoStruct hoObj TRUE TRUE
    End_Procedure
    
    Procedure DefineAllDDOs Handle hoObj
        Integer iChildCount iServerCount iClientCount iCou iFile
        Integer hoChild hoLast hoTmp hoParent hoRecordBuffer hoServer hoClient
        
        Move (child_count(hoObj)) to iChildCount
        //Broadcast Get object_id Of hoObj to hoChild
        Get Parent of hoObj to hoChild
        Broadcast NO_STOP Get object_id of hoObj to hoLast
        If (hoLast<hoChild) Begin
            Move hoLast to hoTmp
            Move hoChild to hoLast
            Move hoTmp to hoChild
        End
        Move (hoObj) to hoParent
        While (iChildCount>0)
            If ( (object_id(hoChild)<>0) and (parent(hoChild)=hoParent) ) Begin
                Get object_id Of (record_buffer(hoChild)) to hoRecordBuffer
                If ( (hoRecordBuffer<>0) And (parent(hoRecordBuffer)=hoChild) ) Begin
                    Send DefineDDoStruct hoChild false false
                End
                Else Begin
                    If (child_count(hoChild)<>0) ;
                        Send DefineAllDDOs hoChild
                End    
                Decrement iChildCount
            End    
            Increment hoChild
            If (hoChild>hoLast) ;
                Move 0 to iChildCount
        End
    End_Procedure
    
    
    // IsDbUsedInLayout: Delivers TRUE if any Field of a passed FileNumber is used within the Report
    Function IsDbUsedInLayout Integer iFileNumber Returns Integer
        String sFile
        Integer iIsUsed
        tDbFile aFile
        Get fFileStruct iFileNumber to aFile
        Move aFile.sLogicalName to sFile
        Move (sFile + ".*") to sFile
        Get LLPrintIsVariableUsed sFile to iIsUsed
        If (iIsUsed<>1) ;
            Move (False) to iIsUsed
        If (not(iIsUsed)) ;
            Get LLPrintIsFieldUsed sFile to iIsUsed
        If (iIsUsed=1) ;
            Function_Return (True)
        Else ;
            Function_Return (False)
    End_Function
    
    Function IsFieldUsedInLayout String sField Returns Integer
        String sFile
        Integer iIsUsed
        If (piProjectType(Self)<>LL_PROJECT_LIST) Begin
            Get LLPrintIsVariableUsed sField to iIsUsed
            If (iIsUsed=1) ;
                Function_Return True
        End
        Else Begin
            Get LLPrintIsFieldUsed sField to iIsUsed
            If (iIsUsed=1) ;
                Function_Return True
        End
        Function_Return False
    End_Function
    
    Function IsVariableUsedInLayout String sVariable Returns Integer
        String sFile
        Integer iIsUsed
        Get LLPrintIsVariableUsed sVariable to iIsUsed
        If (iIsUsed=1) ;
            Function_Return True
        Function_Return False        
    End_Function
    
    // DefineAllFields: Is overriden to automatically define all defined Datadictionaries. If you use
    //                  this in your Object don't forget to forward it.
    Procedure DefineAllFields
        Handle hoMainDD
        Integer iRet
        Forward Send DefineAllFields
        Send delete_data to oDDos
        Send Delete_data to oTables
        Send delete_data to oTableSortOrders
        Send delete_data to oTableRelations
        Set psPrivate.ReportTable to ""
        Set psPrivate.ReportSortOrder to ""
        Set psPrivate.ReportRelation to ""
        Set psPrivate.ReportRelationParent to ""
        Set piPrivate.SaveTableSettings to 0
        
        Send DefineAllDDOs (parent(self))
        If (piProjectType(self)=LL_PROJECT_LIST) Begin
            Get LLDbAddTable "LLStaticTable" "LLStaticTable" to iRet
        End
        #IF (!@>109)
        If (pbIsDrilldown(Self)) Begin
            Send OnDrilldownAdditionalTables (psDrilldownBaseTable(Self)) (psDrilldownSubreportTable(Self)) (psDrilldownRelationId(Self))
        End
        #ENDIF
    End_Procedure
    
    // Report Notifications: The Notifications are only sent, if a List Project is printed.
    //                       Otherwise this Notification's would not make any sense.
    
    // OnDefineIndexForTable
    // Is called when the Report should know what Index to use for finding records
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object for which the Index is needed
    //              Integer hoParentDDo     The ObjectID of the DataDictionary Object which is the Server for the current DDo
    //              Integer iTableLevel     The child Level of the current Table (starting with 0)
    //              String  sRelation       The relation as defined in the Layout in the Format "CHILDTABLE->PARENTTABLE" (i.E.: NUMBERS->CONTACTS)
    //              string  sLayoutIndex    The Index selected in the Layout
    //
    // Return Values:
    //              LL_REPORT_USEDEFAULT    Use the Index that was selected in the List-Layout
    //              LL_INDEX_OPTIMIZED_UP   Let the DataDictionaries decide (upward)
    //              LL_INDEX_OPTIMIZED_DOWN Let the DataDictionaries decide (downward)
    //              Positiv Index Number    i.E.: 1 to use Index.1 starting from the Beginning
    //              Negativ Index Number    i.E.: -1 to use Index.1 starting from the End
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnDefineIndexForTable Integer hoDDo Integer hoParentDDo Integer iTableLevel String sRelation String sTableName String sLayoutIndex
        Procedure_Return LL_REPORT_USEDEFAULT
    End_Procedure
    
    // OnFindFirstRecord
    // Is called when the Report need's the first record of a Table
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object for which the Record is needed
    //              Integer hoParentDDo     The ObjectID of the DataDictionary Object which is the Server for the current DDo
    //              Integer iTableLevel     The child Level of the current Table (starting with 0)
    //              String  sRelation       The relation as defined in the Layout in the Format "CHILDTABLE->PARENTTABLE" (i.E.: NUMBERS->CONTACTS)
    //              integer iIndex          The selected Index
    //              boolean bFromEnd        True if the Table should be searched from End
    //              string  sTableName      Name of the Table
    // Return Values:
    //              LL_REPORT_USEDEFAULT    Let the Report Class do the job :-)
    //              LL_REPORT_EOF           No or no more records Found
    //              LL_REPORT_CANCELPRINT   Cancel the whole Print Job
    //              0                       Record was found and is ready for printing
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnFindFirstRecord Integer hoDDo Integer hoParentDDo Integer iTableLevel String sRelation Integer iIndex Integer bFromEnd String sTableName
        Procedure_Return LL_REPORT_USEDEFAULT
    End_Procedure
    
    // OnFindNextRecord
    // Is called when the Report need's the next record of a Table
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object for which the Record is needed
    //              Integer hoParentDDo     The ObjectID of the DataDictionary Object which is the Server for the current DDo
    //              Integer iTableLevel     The child Level of the current Table (starting with 0)
    //              String  sRelation       The relation as defined in the Layout in the Format "CHILDTABLE->PARENTTABLE" (i.E.: NUMBERS->CONTACTS)
    //              Integer iFindMode       The selected Find Mode
    //              integer iIndex          The selected Index
    //              string  sTableName      Name of the Table
    //
    // Return Values:
    //              LL_REPORT_USEDEFAULT    Let the Report Class do the job :-)
    //              LL_REPORT_EOF           No or no more records Found
    //              LL_REPORT_CANCELPRINT   Cancel the whole Print Job
    //              0                       Record was found and is ready for printing    
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnFindNextRecord Integer hoDDo Integer hoParentDDo Integer iTableLevel String sRelation Integer iFindMode Integer iIndex String sTableName
        Procedure_Return LL_REPORT_USEDEFAULT
    End_Procedure
    
    // OnBeforePrintFirstRecordForTable
    // Is called when the first Record for a table was searched and is ready for Printing
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object 
    //              Integer hoParentDDo     The ObjectID of the DataDictionary Object which is the Server for the current DDo
    //              Integer iTableLevel     The child Level of the current Table (starting with 0)
    //              String  sRelation       The relation as defined in the Layout in the Format "CHILDTABLE->PARENTTABLE" (i.E.: NUMBERS->CONTACTS)
    //              integer iIndex          The selected Index
    //              boolean bFromEnd        True if the Table is searched from End
    //              string  sTableName      Name of the Table
    // Return Values:
    //              LL_REPORT_EOF           Don't print this Record and skip the whole Table
    //              LL_REPORT_CANCELPRINT   Cancel the whole Print Job
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnBeforePrintFirstRecordForTable Integer hoDDo Integer hoParentDDo Integer iTableLevel String sRelation Integer iIndex Integer bFromEnd String sTableName
    End_Procedure    
    
    // OnAfterPrintLastRecordForTable
    // Is called after the last Record of a Table was printed but before the Table is finished.
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object 
    //              Integer hoParentDDo     The ObjectID of the DataDictionary Object which is the Server for the current DDo
    //              Integer iTableLevel     The child Level of the current Table (starting with 0)
    //              String  sRelation       The relation as defined in the Layout in the Format "CHILDTABLE->PARENTTABLE" (i.E.: NUMBERS->CONTACTS)
    //              integer iIndex          The selected Index
    //              boolean bFromEnd        True if the Table is searched from End
    //              string  sTableName      Name of the Table
    // Return Values:
    //              0                       Continue normaly and finish the Table
    //              1                       Another Record for this table was found, continue printing this Table
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnAfterPrintLastRecordForTable Integer hoDDo Integer hoParentDDo Integer iTableLevel String sRelation Integer iIndex Integer bFromEnd String sTableName
    End_Procedure    
    
    // OnBeforePrintRecord
    // Is called before a record is printed
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object for which the Record will be printed
    //              Integer hoParentDDo     The ObjectID of the DataDictionary Object which is the Server for the current DDo
    //              Integer iTableLevel     The child Level of the current Table (starting with 0)
    //              String  sRelation       The relation as defined in the Layout in the Format "CHILDTABLE->PARENTTABLE" (i.E.: NUMBERS->CONTACTS)
    //              string  sTableName      The Name of the Table
    //
    // Return Values:
    //              LL_REPORT_SKIPRECORD    Don't print this record and continue
    //              LL_REPORT_CANCELPRINT   Cancel the whole Print Job
    //              0                       Print the record normaly
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnBeforePrintRecord Integer hoDDo Integer hoParentDDo Integer iTableLevel String sRelation String sTableName
    End_Procedure
    
    // OnAfterPrintRecord
    // Is called after a record was successfully printed
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object for which the Record was printed
    //              Integer hoParentDDo     The ObjectID of the DataDictionary Object which is the Server for the current DDo
    //              Integer iTableLevel     The child Level of the current Table (starting with 0)
    //              String  sRelation       The relation as defined in the Layout in the Format "CHILDTABLE->PARENTTABLE" (i.E.: NUMBERS->CONTACTS)
    //              string  sTableName      The Name of the Table
    //
    // Return Values: None
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnAfterPrintRecord Integer hoDDo Integer hoParentDdo Integer iTableLevel String sRelation String sTableName
    End_Procedure
    
    // OnStartReport
    // Is called before the Report is started
    //
    // Return Values:
    //              LL_REPORT_CANCELPRINT   Cancel the whole Print Job
    //              0                       Print the Report
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnStartReport
    End_Procedure
    
    // OnFinishedReport
    // Is called after the Report is finished
    //
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnFinishedReport
    End_Procedure    
    
    // OnStartTable
    // Is called before a new Table is started
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object for the Table
    //              Integer hoParentDDo     The ObjectID of the DataDictionary Object which is the Server for the current DDo
    //              Integer iTableLevel     The child Level of the current Table (starting with 0)
    //              String  sRelation       The relation as defined in the Layout in the Format "CHILDTABLE->PARENTTABLE" (i.E.: NUMBERS->CONTACTS)
    //              string  sTableName      The Name of the Table
    //
    // Return Values:
    //              LL_REPORT_SKIPTABLE     Skip the whole Table (and therefore all the Records)
    //              LL_REPORT_CANCELPRINT   Cancel the whole Print Job
    //              0                       Print the Table normally
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnStartTable Integer hoDDo Integer hoParentDdo Integer iTableLevel String sRelation String sTableName
    End_Procedure
    
    // OnPrintStaticTable
    // Is called before a Static-Table (LLStaticTable) is printed
    // Parameters: 
    //              string sLastTable       The name of the last Table printed before the Static-Table
    //
    // Return Values:
    //              LL_REPORT_SKIPTABLE     Skip the Static-Table
    //              LL_REPORT_CANCELPRINT   Cancel the whole Print Job
    //              0                       Print the Table normally
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnPrintStaticTable String sLastTable
    End_Procedure    
    
    // OnFinishedTable
    // Is called before a record is printed
    // Parameters: 
    //              Integer hoDDo           The ObjectID of the DataDictionary Object for the Table
    //              Integer hoParentDDo     The ObjectID of the DataDictionary Object which is the Server for the current DDo
    //              Integer iTableLevel     The child Level of the current Table (starting with 0)
    //              String  sRelation       The relation as defined in the Layout in the Format "CHILDTABLE->PARENTTABLE" (i.E.: NUMBERS->CONTACTS)
    //              string  sTableName      The Name of the Table
    //
    // Return Values: None
    //
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF    
    Procedure OnFinishedTable Integer hoDDo Integer hoParentDDo Integer iTableLevel String sRelation String sTableName
    End_Procedure
    
    #IF (!@>109)
    // OnStartDrilldownReport
    // Is called when a Drilldown-Report is about to be started
    // Parameters: 
    //              String sTableId             The Parent-Table of the Drilldown-Report
    //              String[] sKeyFields         The Keyfields of the Parent-Table
    //              String[] sKeyValues         The Values for the Keyfields
    //              String sSubreportTableId    The Child-Table
    //              String sSubreportKeyField   The Keyfield in the Child-Table
    //              String sRelationId          The used Relation Id
    //              String sProjectFileName     The used List & Label Project File
    //              String sPreviewFileName     The Filename for the resulting Preview
    //              String sTabText             The Text displayed in the Tab     
    //              String sTooltipText         The Tooltip Text displayed
    //
    // Return Values:
    //              LL_REPORT_USEDEFAULT      Let the Report Class find the correct Parent Record and start the Drilldown
    //              0                         The parent Record is found and the Drilldown should start
    //              any other Return          Don't print the Drilldown
    //    
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF        
    Procedure OnStartDrilldownReport String sTableId String[] sKeyFields String[] sKeyValues String sSubreportTableId String sSubreportKeyField String sRelationId String sProjectFileName String sPreviewFileName String sTabText String sTooltipText
        Procedure_Return LL_REPORT_USEDEFAULT
    End_Procedure
    
    // OnFinishedDrilldownReport
    // Is called when a Drilldown-Report has ended
    // Parameters: 
    //              String sTableId             The Parent-Table of the Drilldown-Report
    //              String sSubreportTableId    The Child-Table
    //              String sRelationId          The used Relation Id
    //              integer bCanceled           True when the Drilldown did not start for several reasons (Parent Record not found, Error in Project .....)
    //
    // Return Values:
    //              None
    //    
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF        
    Procedure OnFinishedDrilldownReport String sTableId String sSubreportTableId String sRelationId Integer bCanceled
    End_Procedure
    

    // OnBeforePrintDrilldown
    // Is called before a Drilldown-Report get's actually printed. The Parent Record is already found here
    // Parameters: 
    //              String sTableId             The Parent-Table of the Drilldown-Report
    //              String sSubreportTableId    The Child-Table
    //              String sRelationId          The used Relation Id
    //
    // Return Values:
    //              None
    //    
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF        
    Procedure OnBeforePrintDrilldown String sTableId String sSubreportTableId String sRelationId 
    End_Procedure    
    
    // OnDrilldownAdditionalTables
    // Is only called when the pbDrilldownQueryDatabases is set to TRUE
    // Is called when a Drilldown-Job is started (either Design or Report)
    // Additional Tables can be defined here that are only needed inside a Drilldown
    // Parameters: 
    //              String sMainTableId         The Parent-Table of the Drilldown-Report
    //              String sSubreportTableId    The Child-Table
    //              String sRelationId          The used Relation Id
    //
    // Return Values: None
    //    
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF
    Procedure OnDrilldownAdditionalTables String sMainTableId String sSubreportTableId String sRelationId
    End_Procedure
    // OnDrilldownUseTable
    // Is only called when the pbDrilldownQueryDatabases is set to TRUE
    // You can decide for each queried Table if it should be used in the Drilldown or if it should be hidden (1)
    // 
    // Parameters: 
    //              String sTableToQuery        The Table that is queried
    //              String sMainTableId         The Parent-Table of the Drilldown-Report
    //              String sSubreportTableId    The Child-Table
    //              String sRelationId          The used Relation Id
    //
    // Return Values: 
    //              LL_DRILLDOWN_HIDETABLE to hide table
    //              LL_DRILLDOWN_SHOWTABLE to display table
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF
    Procedure OnDrilldownUseTable String sTableToQuery String sMainTableId String sSubreportTableId String sRelationId
    End_Procedure
    // OnDrilldownUseTableAsVariable
    // Is only called when the pbDrilldownBasetableAsVariable is set to TRUE
    // You can decide for each queried Table if it should be used as a Parent Table and therefore be displayed as Variables instead of Fields
    // 
    // Parameters: 
    //              String sTableToQuery        The Table that is queried
    //              String sMainTableId         The Parent-Table of the Drilldown-Report
    //              String sSubreportTableId    The Child-Table
    //              String sRelationId          The used Relation Id
    //
    // Return Values: 
    //              1 to display the Table as Variables
    //              0 to display the Table normally as Fields
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF
    Procedure OnDrilldownUseTableAsVariable String sTableToQuery String sMainTableId String sSubreportTableId String sRelationId
    End_Procedure    
    #ENDIF
    
    #IF (!@ >= 120)
    { MethodType=Event }
    #ENDIF
    #if (!@>109)
    Procedure OnVarHelptext String sField String ByRef sHelptext
    End_Procedure
    #ENDIF
    
    #IF (!@>109)
    Procedure OnLL_CMND_VARHELPTEXT String sField String ByRef sHelptext
        String sFile sFileField sVal
        Handle hoDDo
        Integer iFile iField iTotalFields iFieldCou iRet
        tDbFile aFile
        If (Pos(".",sField)<>0) Begin
            Move (Left(sField,(Pos(".",sField)))) to sFile
            Move (Replace(sFile,sField,"")) to sFileField
            Move (Replace(".",sFile,"")) to sFile
            Get DDOForTable sFile to hoDDo
            If (hoDDo<>0) Begin
                Move (eval( (sFile + ".FILE_NUMBER"))) to iFile
                If (iFile<>0) Begin
                    Get_Attribute DF_FILE_OPENED of iFile to iRet
                    If (iRet=DFTRUE) Begin
                        Get fFileStruct iFile to aFile
                        Move aFile.iNumberFields to iTotalFields
                        For iFieldCou from 0 to iTotalFields
                            Move aFile.aFields[iFieldCou].sName to sVal
                            If (Uppercase(Trim(sVal))=(Uppercase(Trim(sFileField)))) Begin
                                Get File_Field_Status_Help of hoDDo iFile iFieldCou to sHelptext
                                If (Trim(sHelptext)="") Begin
                                    Get File_Field_Label of hoDDo iFile iFieldCou DD_LABEL_LONG to sHelptext
                                    If (Trim(sHelptext)="") Begin
                                        Get File_Field_Label of hoDDo iFile iFieldCou DD_LABEL_SHORT to sHelptext
                                    End                                    
                                End
                                Move iTotalFields to iFieldCou
                            End
                        Loop
                    End
                End
            End
        End
        Send OnVarHelptext sField (&sHelptext)
    End_Procedure
    #ENDIF
    
    Function fRelationField Integer iParentFile Integer iChildFile Returns Integer
        Integer iFields iField iRelateFile
        tDbFile aFile
        Get fFileStruct iChildFile to aFile
        Move aFile.iNumberFields to iFields
        For iField from 1 to iFields
            Move aFile.aFields[iField].iRelatedFile to iRelateFile
            If (iRelateFile=iParentFile) Begin
                Function_Return iField
            End
        Loop
        Function_Return -1
    End_Function 
    
    Function fRecommendedIndex Integer iFile Integer iRelatedField Returns Integer
        Integer iIndexes iIndex iNumSegments iSegmentField iRecnumTable
        tDbFile aFile
        Get fFileStruct iFile to aFile
        Move aFile.iLastIndexNumber to iIndexes
        For iIndex from 1 to iIndexes
            Move aFile.aIndexes[iIndex].iSegments to iNumSegments
            If (iNumSegments > 0) Begin
                If (SizeOfArray(aFile.aIndexes[iIndex].aSegments)>0) Begin
                    Move aFile.aIndexes[iIndex].aSegments[1].iField to iSegmentField
                    If (iSegmentField=iRelatedField) Begin
                        Function_Return iIndex
                    End
                End
            End
        Loop
        #IF (!@>120)
        Move aFile.iRecnumTable to iRecnumTable
        If (iRecnumTable<>(True)) Begin
            Move aFile.iPrimaryIndex to iIndex
            Function_Return iIndex
        End        
        #ENDIF
        Function_Return 0
    End_Function
    
    // A helper Function for Printing a single Table and eventually all Sub-Tables
    Function DoPrintTable String sTable Integer iLevel Returns Integer
        Integer iRet iIndex iFile iFindMode iPrintReturn iConstrainFile iRelationField iParentRec iCou iRecnumTable
        String sTableNew sIndex sRelation sParent sVal sVal2
        Integer bReverse bFound bIsDataObject
        Handle hoDDo hoParentDDo hoDrilldownParentDDo hoObj
        tDbFile aFile
        
        Move (Replaces(">",sTable,".")) to sTable
        
        Send DebugVDFReport "DoPrintTable - sTable: " sTable "Level:" iLevel
        If (sTable="LLStaticTable") Begin
            Send DebugVDFReport "OnPrintStaticTable sTable:" (psCurrentTable(Self))
            Get Msg_OnPrintStaticTable (psCurrentTable(Self)) to iRet
            Send DebugVDFReport "OnPrintStaticTable =" iRet
            If (iRet=LL_REPORT_SKIPTABLE) Begin
                Get LLPrintFieldsEnd to iRet
                While (iRet=LL_WRN_REPEAT_DATA)
                    Get LLPrintFieldsEnd to iRet
                End
                Function_Return iRet            
            End
            If (iRet=LL_REPORT_CANCELPRINT) Begin
                Function_Return LL_ERR_USER_ABORTED
            End
            If (piProjectType(Self)=LL_PROJECT_LIST) Begin
                If (piFirstPrint(Self)) Begin
                    Send DoCheckPreviewPanelBeforePrint
                    While (LLPrint(Self)=LL_WRN_REPEAT_DATA)
                    End
                    Set piFirstPrint to False
                End        
            End            
            Send DefineStandardVariables
            Send DefineUsedVariables            
            Get LLPrintFields to iPrintReturn
            While (iPrintReturn=LL_WRN_REPEAT_DATA)
                While (LLPrint(self)=LL_WRN_REPEAT_DATA)
                End
                Get LLPrintFields to iPrintReturn
            End
            Get LLPrintFieldsEnd to iPrintReturn
            While (iPrintReturn=LL_WRN_REPEAT_DATA)
                Get LLPrintFieldsEnd to iPrintReturn
            End
            Send DebugVDFReport "DoPrintTable returns:" iPrintReturn
            Function_Return iPrintReturn
        End
        Set psCurrentTable to sTable
        Get DDOForTable sTable to hoDDo
        If (hoDDo=0) Begin
            Move sTable to sVal
            While (Pos(".",sVal)<>0)
                Move (Left(sVal,(Pos(".",sVal)))) to sVal2
                Move (Replace(sVal2,sVal,"")) to sVal
            End
            For iCou from 0 to (Item_Count(oDataObjects(Self))-1)
                Get Value of oDataObjects iCou to hoObj
                If (hoObj<>0) Begin
                    If (Uppercase(Trim(psName(hoObj)))=(Uppercase(Trim(sVal)))) Begin
                        Move (Item_Count(oDataObjects(Self))) to iCou
                        Move hoObj to hoDDo
                        Move True to bIsDataObject
                    End
                End
            Loop
        End
//        If (hoDDo=0) Begin
//            If (piProjectType(Self)=LL_PROJECT_LIST) Begin
//                Get LLPrintFieldsEnd to iRet
//                While (iRet=LL_WRN_REPEAT_DATA)
//                    Get LLPrintFieldsEnd to iRet
//                End
//            End
//            Else Begin
//                Move 0 to iRet
//            End
//            Function_Return iRet            
//        End
        
        Set value Of oCurrentDDos iLevel to hoDDo
        If (iLevel>0) ;
            Get value of oCurrentDDos (iLevel-1) to hoParentDDo
        Else ;
            Move 0 to hoParentDDo
        
        Get LLPrintDbGetCurrentTableRelation to sRelation
        If ( (piProjectType(Self)<>LL_PROJECT_LIST) and (iLevel=0) and (Uppercase(Trim(sTable))=(Uppercase(Trim(psPrivate.ReportRelationParent(Self))))) ) Begin
            Move "" to sRelation
        End
        Send DebugVDFReport "OnStartTable hoDDo:" hoDDo "hoParentDDo:" hoParentDDo "Level:" iLevel "sRelation:" sRelation "sTable:" sTable
        Get msg_OnStartTable hoDDo hoParentDDo iLevel sRelation sTable to iRet
        Send DebugVDFReport "OnStartTable =" iRet
        If (iRet=LL_REPORT_SKIPTABLE) Begin
            If (piProjectType(self)=LL_PROJECT_LIST) Begin
                Get LLPrintFieldsEnd to iRet
                While (iRet=LL_WRN_REPEAT_DATA)
                    Get LLPrintFieldsEnd to iRet
                End
            End
            Else Begin
                Move 0 to iRet
            End
            Send DebugVDFReport "DoPrintTable returns:" iRet 
            Function_Return iRet            
        End
        Get LLPrintDbGetCurrentTableSortOrder to sIndex
        Send DebugVDFReport "OnDefineIndexForTable hoDDo:" hoDDo "hoParentDDo:" hoParentDDo "iLevel:" iLevel "sRelation:" sRelation "sTable:" sTable "sIndex:" sIndex 
        Get msg_OnDefineIndexForTable hoDDo hoParentDDo iLevel sRelation sTable sIndex to iIndex
        Send DebugVDFReport "OnDefineIndexForTable =" iIndex
        If (iIndex=LL_REPORT_USEDEFAULT) Begin
            Move sIndex to iIndex
            If (iIndex<0) Begin
                Move (iIndex*-1) to iIndex
                Move (True) to bReverse
            End
            Else Begin
                Move (False) to bReverse
            End            
            If ( (piProjectType(Self)<>LL_PROJECT_LIST) and (iLevel=0) and (Uppercase(Trim(sTable))=(Uppercase(Trim(psPrivate.ReportRelationParent(Self))))) ) Begin
                Get Ordering of hoDDo to iIndex
            End            
        End
        Else Begin
            If ( (iIndex=LL_INDEX_OPTIMIZED_DOWN) or (iIndex=LL_INDEX_OPTIMIZED_UP) ) Begin
                If (iIndex=LL_INDEX_OPTIMIZED_UP) Begin
                    Move -1 to iIndex
                    Move (False) to bReverse
                End
                If (iIndex=LL_INDEX_OPTIMIZED_DOWN) Begin
                    Move -1 to iIndex
                    Move (True) to bReverse
                End
            End
            Else Begin
                If (iIndex<0) Begin
                    Move (iIndex*-1) to iIndex
                    Move (True) to bReverse
                End
                Else Begin
                    Move (False) to bReverse
                End
            End
        End
        #IF (!@>120)
        If ( (iIndex=0) and (hoDDo<>0) and (not(bIsDataObject)) ) Begin
            Get fFileStruct (Main_File(hoDDo)) to aFile
            Move aFile.iRecnumTable to iRecnumTable
            If (iRecnumTable<>(True)) Begin
                Move aFile.iPrimaryIndex to iIndex
            End
        End
        #ENDIF
        
        Move (true) to bFound
        Move -1 to iConstrainFile
        
        Send DebugVDFReport "OnFindFirstRecord hoDDo: " hoDDo "hoParentDDo:" hoParentDDo "iLevel:" iLevel "sRelation:" sRelation "iIndex:" iIndex "bReverse:" bReverse "sTable:" sTable
        Get msg_OnFindFirstRecord hoDDo hoParentDDo iLevel sRelation iIndex bReverse sTable to iRet
        Send DebugVDFReport "OnFindFirstRecord =" iRet
        If (iRet=LL_REPORT_USEDEFAULT) Begin
            // Record for Table without DDo can't be automatically found so step out
            If (hoDDo=0) Begin
                If (piProjectType(self)=LL_PROJECT_LIST) Begin
                    Get LLPrintFieldsEnd to iRet
                    While (iRet=LL_WRN_REPEAT_DATA)
                        Get LLPrintFieldsEnd to iRet
                    End
                End
                Else Begin
                    Move 0 to iRet
                End
                Send DebugVDFReport "DoPrintTable - hoDDo=0, can't automatically find records! Return " iRet
                Function_Return iRet                
            End
            If (not(bIsDataObject)) Begin
                If ( (pbIsDrilldown(Self)) and (iLevel=0) ) Begin
                    Get DDoForTable (psDrilldownBaseTable(Self)) to hoDrilldownParentDDo
                    Send DebugVDFReport "DoPrintTable - Drilldown Level 0, hoDrilldownParentDDo: " hoDrilldownParentDDo
                    If ( (hoDrilldownParentDDo<>0) and (Constrain_File(hoDDo)<>(Main_File(hoDrilldownParentDDo))) ) Begin
                        Get fRelationField (Main_File(hoDrilldownParentDDo)) (Main_File(hoDDo)) to iRelationField
                        If (iRelationField<>-1) Begin
                            Get Constrain_File of hoDDo to iConstrainFile
                            Set Constrain_File of hoDDo to (Main_File(hoDrilldownParentDDo))
                            Send DebugVDFReport "DoPrintTable - Drilldown Level 0. Constrain_file set to" (Main_File(hoDrilldownParentDDo))
                            Send Rebuild_Constraints to hoDDo
                            If (Trim(sIndex)="") Begin
                                Get fRecommendedIndex (Main_File(hoDDo)) iRelationField to iIndex
                                Send DebugVDFReport "DoPrintTable - Drilldown Level 0. Index set to recommended:" iIndex
                            End
                        End                    
                    End
                End
                If ( (Pos("->",sRelation)<>0) and (iLevel>0) and (hoParentDDo<>0) and (Constrain_File(hoDDo)<>(Main_File(hoParentDDo))) ) Begin
                    Get fRelationField (Main_File(hoParentDDo)) (Main_File(hoDDo)) to iRelationField
                    If (iRelationField<>-1) Begin
                        Get Constrain_File of hoDDo to iConstrainFile
                        Set Constrain_File of hoDDo to (Main_File(hoParentDDo))
                        Send DebugVDFReport "DoPrintTable - Constrain_file set to " (Main_File(hoParentDDo))
                        Send Rebuild_Constraints to hoDDo
                        If (Trim(sIndex)="") Begin
                            Get fRecommendedIndex (Main_File(hoDDo)) iRelationField to iIndex
                            Send DebugVDFReport "DoPrintTable - Index set to recommended:" iIndex
                        End
                    End
                End
                If ( ((Pos("->",sRelation)<>0) and (iLevel=0)) or ((trim(sRelation)="") and (constrain_file(hoDDo)<>0)) ) Begin
                    If (phoMasterDD(Self)=0) Begin
                        If (not(pbIsDrilldown(Self))) Begin
                            Get constrain_file of hoDDo to iConstrainFile
                            Set constrain_file of hoDDo to 0
                            Send rebuild_constraints to hoDDo  
                            Send DebugVDFReport "DoPrintTable - Constrain_file set to 0 (phoMasterDD=0)"
                        End
                    End
                    Else Begin
                        Move (Left(sRelation,(Pos("->",sRelation)+1))) to sParent
                        Move (Replace(sParent,sRelation,"")) to sParent
                        If (DDOForTable(Self,sParent)<>(phoMasterDD(Self))) Begin
                            Get constrain_file of hoDDo to iConstrainFile
                            Set constrain_file of hoDDo to 0
                            Send rebuild_constraints to hoDDo  
                            Send DebugVDFReport "DoPrintTable - Constrain_file set to 0 (phoMasterDD<>0)"
                        End
                        Else Begin
                            If (Constrain_File(hoDDo)<>(Main_File(phoMasterDD(Self)))) Begin
                                Get Constrain_File of hoDDo to iConstrainFile
                                Set Constrain_File of hoDDo to (Main_File(phoMasterDD(Self)))
                                Send Rebuild_Constraints to hoDDo
                                Send DebugVDFReport "DoPrintTable - Constrain_file set to Main_file of phoMasterDD"
                            End
                            Send Find to (phoMasterDD(Self)) FIRST_RECORD (Ordering(phoMasterDD(Self)))
                        End
                    End    
                End    
                If ( (Pos("->",sRelation)<>0) and (iLevel>0) and (hoParentDDo<>0) ) Begin
                    Get Current_Record of hoParentDDo to iParentRec
                End
                If (bReverse) ;
                    Move last_record to iFindMode
                Else ;
                    Move first_record to iFindMode
                Send Find to hoDDo iFindMode iIndex
                If (not(Found)) ;
                    Move (False) to bFound
            End
            Else Begin
                Get FindRecord of hoDDo FIRST_RECORD to bFound
            End
        End
        Else Begin
            If (iRet=LL_REPORT_CANCELPRINT) ;
                Function_Return LL_ERR_USER_ABORTED
            If (iRet=LL_REPORT_EOF) ;
                Move (False) to bFound
        End
        
        If (bReverse) ;
            Move (Lt) to iFindMode
        Else ;
            Move next_record to iFindMode
        
        If (bFound) Begin
            Send DebugVDFReport "OnBeforePrintFirstRecordForTable hoDDo: " hoDDo "hoParentDDo:" hoParentDDo "iLevel:" iLevel "sRelation:" sRelation "iIndex:" iIndex "bReverse:" bReverse "sTable:" sTable
            Get msg_OnBeforePrintFirstRecordForTable hoDDo hoParentDDo iLevel sRelation iIndex bReverse sTable to iRet
            Send DebugVDFReport "OnBeforePrintFirstRecordForTable =" iRet
            If (iRet=LL_REPORT_CANCELPRINT) Begin
                If (hoDDo<>0) Begin
                    If (iConstrainFile<>-1) Begin
                        Set constrain_file of hoDDo to iConstrainFile
                        Send rebuild_constraints to hoDDo  
                        Move -1 to iConstrainFile
                    End
                End
                Send DebugVDFReport "DoPrintTable returns: LL_ERR_USER_ABORTED"
                Function_Return LL_ERR_USER_ABORTED            
            End
            If (iRet=LL_REPORT_EOF) Begin
                Move False to bFound
            End
        End
        
        If (piProjectType(self)=LL_PROJECT_LIST) Begin
            If (piFirstPrint(self)) Begin
                Send DoCheckPreviewPanelBeforePrint
                While (LLPrint(self)=LL_WRN_REPEAT_DATA)
                End
                Set piFirstPrint to False
            End        
        End
        
        If (piProjectType(Self)=LL_PROJECT_LIST) Begin
            Send DefineStandardVariables
            Send DefineUsedVariables            
        End
        
        While (bFound)
            Send DebugVDFReport "OnBeforePrintRecord hoDDo:" hoDDo "hoParentDDo:" hoParentDDo "iLevel:" iLevel "sRelation:" sRelation "sTable" sTable
            Get msg_OnBeforePrintRecord hoDDo hoParentDDo iLevel sRelation sTable to iRet
            Send DebugVDFReport "OnBeforePrintRecord =" iRet
            If (iRet=LL_REPORT_CANCELPRINT) Begin
                If (hoDDo<>0) Begin
                    If (iConstrainFile<>-1) Begin
                        Set constrain_file Of hoDDo to iConstrainFile
                        Send rebuild_constraints to hoDDo  
                        Move -1 to iConstrainFile
                    End
                End
                Send DebugVDFReport "DoPrintTable returns: LL_ERR_USER_ABORTED"
                Function_Return LL_ERR_USER_ABORTED
            End
            If (iRet=0) Begin
                If (piProjectType(self)=LL_PROJECT_LIST) Begin            
                    Get LLPrintFields to iPrintReturn
                    While (iPrintReturn=LL_WRN_REPEAT_DATA)
                        While (LLPrint(self)=LL_WRN_REPEAT_DATA)
                        End
                        Get LLPrintFields to iPrintReturn
                    End
                End
                Else Begin
                    If ( (iLevel=0) and (Uppercase(Trim(sTable))=(Uppercase(Trim(psPrivate.ReportRelationParent(Self))))) ) Begin
                        Move LL_WRN_TABLECHANGE to iPrintReturn
                    End
                    Else Begin
                        Get PrintData to iPrintReturn    
                    End
                End
                If ( (pbDesignerPreviewRunning(Self)) and (piDesignerPreviewPagesRequested(Self)<>0) ) Begin
                    Get LlPrintGetCurrentPage to iRet
                    If (iRet>(piDesignerPreviewPagesRequested(Self))) Begin
                        Get LLPrintAbort to iRet
                    End
                End
                If (pbDesignerPreviewAbortRequested(Self)) Begin
                    Get LLPrintAbort to iRet
                End
                Send DebugVDFReport "OnAfterPrintRecord hoDDo:" hoDDo "hoParentDDo:" hoParentDDo "iLevel:" iLevel "sRelation:" sRelation "sTable:" sTable
                Get msg_OnAfterPrintRecord hoDDo hoParentDDo iLevel sRelation sTable to iRet
                Send DebugVDFReport "OnAfterPrintRecord =" iRet
                While (iPrintReturn=LL_WRN_TABLECHANGE)
                    Move (LLPrintDbGetCurrentTable(Self,True)) to sTableNew
                    If ( (piProjectType(Self)<>LL_PROJECT_LIST) and (iLevel=0) and (Uppercase(Trim(sTable))=(Uppercase(Trim(psPrivate.ReportRelationParent(Self))))) ) Begin
                        Move (psPrivate.ReportTable(Self)) to sTableNew
                    End
                    Get DoPrintTable sTableNew (iLevel+1) to iPrintReturn
                End
                If (iPrintReturn=LL_ERR_USER_ABORTED) Begin
                    If (iConstrainFile<>-1) Begin
                        Set constrain_file of hoDDo to iConstrainFile
                        Send rebuild_constraints to hoDDo  
                        Move -1 to iConstrainFile
                    End
                    Send DebugVDFReport "DoPrintList returnes: LL_ERR_USER_ABORTED"
                    Function_Return LL_ERR_USER_ABORTED
                End                
            End
            Send DebugVDFReport "OnFindNextRecord hoDDo:" hoDDo "hoParentDDo:" hoParentDDo "sRelation:" sRelation "iIndex:" iIndex "sTable:" sTable
            Get msg_OnFindNextRecord hoDDo hoParentDDo iLevel sRelation iFindMode iIndex sTable to iRet
            Send DebugVDFReport "OnFindNextRecord =" iRet
            If (iRet=LL_REPORT_EOF) ;
                Move (False) to bFound
            If (iRet=LL_REPORT_CANCELPRINT) Begin
                If (hoDDo<>0) Begin
                    If (iConstrainFile<>-1) Begin
                        Set constrain_file Of hoDDo to iConstrainFile
                        Send rebuild_constraints to hoDDo  
                        Move -1 to iConstrainFile
                    End                
                End
                Send DebugVDFReport "DoPrintList returnes LL_ERR_USER_ABORTED"
                Function_Return LL_ERR_USER_ABORTED
            End    
            If (iRet=LL_REPORT_USEDEFAULT) Begin
                // Record for Table without DDo can't be automatically found so step out
                If (hoDDo=0) Begin
                    Move (False) to bFound
                End
                Else Begin
                    If (not(bIsDataObject)) Begin
                        Send Find to hoDDo iFindMode iIndex
                        If (not(Found)) ;
                            Move (False) to bFound
                    End
                    Else Begin
                        Get FindRecord of hoDDo NEXT_RECORD to bFound
                    End
                End
            End
            If (not(bFound)) Begin
                Send DebugVDFReport "OnAfterPrintLastRecordForTable hoDDo: " hoDDo "hoParentDDo:" hoParentDDo "iLevel:" iLevel "sRelation:" sRelation "iIndex:" iIndex "bReverse:" bReverse "sTable:" sTable
                Get msg_OnAfterPrintLastRecordForTable hoDDo hoParentDDo iLevel sRelation iIndex bReverse sTable to iRet
                Send DebugVDFReport "OnAfterPrintLastRecordForTable =" iRet
                If (iRet=1) Begin
                    Move True to bFound
                End
            End
        End
        If (piProjectType(self)=LL_PROJECT_LIST) Begin
            Get LLPrintFieldsEnd to iPrintReturn
            While (iPrintReturn=LL_WRN_REPEAT_DATA)
                Get LLPrintFieldsEnd to iPrintReturn
            End
        End
        // Restore the Parent Record if it has changed, should normaly not happen.
        If ( (Pos("->",sRelation)<>0) and (iLevel>0) and (hoParentDDo<>0) and (iParentRec<>0) ) Begin
            If (Current_Record(hoParentDDo)<>iParentRec) Begin
                Send Find_By_Recnum to hoParentDDo (Main_File(hoParentDDo)) iParentRec
            End
        End        
        Send DebugVDFReport "OnFinishedTable hoDDo: " hoDDo "hoParentDDo:" hoParentDDo "iLevel:" iLevel "sRelation:" sRelation "sTable:" sTable
        Get msg_OnFinishedTable hoDDo hoParentDDo iLevel sRelation sTable to iRet
        Send DebugVDFReport "OnFinishedTable =" iRet
        Set value of oCurrentDDos iLevel to 0
        If (hoDDo<>0) Begin
            If (iConstrainFile<>-1) Begin
                Set constrain_file Of hoDDo to iConstrainFile
                Send rebuild_constraints to hoDDo  
                Move -1 to iConstrainFile
            End        
        End
        Send DebugVDFReport "DoPrintList returns: " iPrintReturn
        Function_Return iPrintReturn
    End_Function
    
    Function LLPrintStart Integer iType String sFile Integer iOptions Returns Integer
        Integer iRet iRetVal
        If (iType<>LL_PROJECT_LIST) Begin
            Get LLSetDefaultProjectParameter "VDF.Report.Table" "" LL_PARAMETERFLAG_VALUE to iRet
            Get LLSetDefaultProjectParameter "VDF.Report.SortOrder" "" LL_PARAMETERFLAG_VALUE to iRet
            Get LLSetDefaultProjectParameter "VDF.Report.Relation" "" LL_PARAMETERFLAG_VALUE to iRet
        End
        Forward Get LLPrintStart iType sFile iOptions to iRetVal
        Function_Return iRetVal
    End_Function
    
    Function LLPrintWithBoxStart Integer iType String sFile Integer iOptions Integer iBoxType Handle hWndParent String sTitel Returns Integer
        Integer iRetval iRet
        If (iType<>LL_PROJECT_LIST) Begin
            Get LLSetDefaultProjectParameter "VDF.Report.Table" "" LL_PARAMETERFLAG_VALUE to iRet
            Get LLSetDefaultProjectParameter "VDF.Report.SortOrder" "" LL_PARAMETERFLAG_VALUE to iRet
            Get LLSetDefaultProjectParameter "VDF.Report.Relation" "" LL_PARAMETERFLAG_VALUE to iRet
        End        
        Forward Get LLPrintWithBoxStart iType sFile iOptions iBoxType hWndParent sTitel to iRetVal
        Function_Return iRetVal
    End_Function
    
    Function LLDefineLayout Handle hWnd String sText Integer iType String sFile Returns Integer
        Integer iRet iCleanType
        String sTable sSort sRelation
        
        Move iType to iCleanType
        If (iType iand LL_NONAMEINTITLE) Begin
            Move (iType - LL_NONAMEINTITLE) to iCleanType
        End
        
        If (pbDesignerPreview(Self)) Begin
            Get LLSetOption LL_OPTION_DESIGNERPREVIEWPARAMETER 1 to iRet
            Get LLSetOption LL_OPTION_DESIGNEREXPORTPARAMETER 1 to iRet
            Get LLSetOption LL_OPTION_DESIGNERPRINT_SINGLETHREADED True to iRet            
        End
        
        If (iCleanType<>LL_PROJECT_LIST) Begin
            File_Exist sFile iRet
            If (not(iRet)) Begin
                Set piProjectType to iCleanType
                Set psCurrentProjectFile to sFile
                If (piJobNumber(Self)<>0) Begin
                    #IF (!@>199)
                    Move (LlDbAddTableEf(piJobNumber(Self),"","")) to iRet
                    #ELSE
                    Move (LlDbAddTableEf(piJobNumber(Self),0,0)) to iRet
                    #ENDIF
                End                
                Send delete_data to (oAllFields(Self))
                Send delete_data to (oAllVariables(Self))
                #IF (!@>109)
                tAliasDb[] sAllFields
                Set paAllAliasFields to sAllFields
                Set paAllAliasVariables to sAllFields
                #ENDIF        
                Set psUsedIdentifiers to ""
                Set psCurrentTable to ""
                Get LLDefineFieldStart to iRet
                Get LLDefineVariableStart to iRet
                Send DefineOneTimeVariables
                Send DefineStandardVariables
                Send DefineAllFields
                Send DefineAllVariables
                
                Set pbForceUsedIdentifierIdentification to True
                Set pbDefinesNeeded to False
        
                Set piIsLayouting to True                
                Set psPrivate.ReportTable to ""
                Set psPrivate.ReportSortOrder to ""
                Set psPrivate.ReportRelation to ""
                Set psPrivate.ReportRelationParent to ""
                Send DoSelectTable
                If (pbPrivate.TableSelectCancelled(Self)) Begin
                    Function_Return LL_ERR_USER_ABORTED
                End
                Set piPrivate.SaveTableSettings to 0
                Get psPrivate.ReportTable to sTable
                Get psPrivate.ReportSortOrder to sSort
                Get psPrivate.ReportRelation to sRelation                
            End
            
            Get LLSetDefaultProjectParameter "VDF.Report.Table" sTable (LL_PARAMETERFLAG_VALUE ior LL_PARAMETERFLAG_SAVEDEFAULT) to iRet
            Get LLSetDefaultProjectParameter "VDF.Report.SortOrder" sSort (LL_PARAMETERFLAG_VALUE ior LL_PARAMETERFLAG_SAVEDEFAULT) to iRet
            Get LLSetDefaultProjectParameter "VDF.Report.Relation" sRelation (LL_PARAMETERFLAG_VALUE ior LL_PARAMETERFLAG_SAVEDEFAULT) to iRet
        End
        Forward Get LLDefineLayout hWnd sText iType sFile to iRet
        Function_Return iRet
    End_Function
    
    Procedure OnLL_CMND_SELECTMENU Integer iMenuItem
        String sTable sSort sRelation sVal
        Integer iRet iCou 
        Handle hDom hVars hVar hWnd
        If ( (piProjectType(Self)<>LL_PROJECT_LIST) and (iMenuItem=10999) ) Begin 
            Move (LLDomGetProject(Self)) to hDom
            If (hDom>0) Begin
                Move (LLDomGetObject(Self,hDom,"ProjectParameters")) to hVars
                If (hVars>0) Begin
                    For iCou from 0 to (LLDomGetSubobjectCount(Self,hVars)-1)
                        Move (LLDomGetSubobject(Self,hVars,iCou)) to hVar
                        If (hVar<>0) Begin
                            Move (LLDomGetProperty(Self,hVar,"Name")) to sVal
                            If (sVal="VDF.Report.Table") Begin
                                Move (LLDomGetProperty(Self,hVar,"Contents")) to sTable
                            End
                            If (sVal="VDF.Report.SortOrder") Begin
                                Move (LLDomGetProperty(Self,hVar,"Contents")) to sSort
                            End
                            If (sVal="VDF.Report.Relation") Begin
                                Move (LLDomGetProperty(Self,hVar,"Contents")) to sRelation
                            End
                        End    
                    Loop
                End                
            End
            Set psPrivate.ReportTable to sTable
            Set psPrivate.ReportSortOrder to sSort
            Set psPrivate.ReportRelation to sRelation
            Move (LLGetActiveWindowEf()) to hWnd
            Move (EnableWindow(hWnd,False)) to iRet
            Send DoSelectTable
            Move (EnableWindow(hWnd,True)) to iRet
            Move (LLSetActiveWindowEf(hWnd)) to iRet
            Set piPrivate.SaveTableSettings to 0
            If (not(pbPrivate.TableSelectCancelled(Self))) Begin
                Get psPrivate.ReportTable to sTable
                Get psPrivate.ReportSortOrder to sSort
                Get psPrivate.ReportRelation to sRelation                
                If (hVars>0) Begin
                    For iCou from 0 to (LLDomGetSubobjectCount(Self,hVars)-1)
                        Move (LLDomGetSubobject(Self,hVars,iCou)) to hVar
                        If (hVar<>0) Begin
                            Move (LLDomGetProperty(Self,hVar,"Name")) to sVal
                            If (sVal="VDF.Report.Table") Begin
                                Move (LLDomSetProperty(Self,hVar,"Contents",sTable)) to iRet
                            End
                            If (sVal="VDF.Report.SortOrder") Begin
                                Move (LLDomSetProperty(Self,hVar,"Contents",sSort)) to iRet
                            End
                            If (sVal="VDF.Report.Relation") Begin
                                Move (LLDomSetProperty(Self,hVar,"Contents",sRelation)) to iRet
                            End
                        End    
                    Loop
                End
            End
            Procedure_Return 1
        End
    End_Procedure    
    
    Procedure OnLL_NTFY_DRILLDOWN_ADDITIONALTABLES String sMainTableId String sSubreportTableId String sRelationId
        #IF (!@>109)
        Send OnDrilldownAdditionalTables sMainTableId sSubreportTableId sRelationId
        #ENDIF 
    End_Procedure
    Procedure OnLL_NTFY_DRILLDOWN_USE_TABLE String sTableToQuery String sMainTableId String sSubreportTableId String sRelationId
        #IF (!@>109)
        Integer iRet
        Get msg_OnDrilldownUseTable sTableToQuery sMainTableId sSubreportTableId sRelationId to iRet
        Procedure_Return iRet
        #ENDIF         
    End_Procedure
    Procedure OnLL_NTFY_DRILLDOWN_USE_TABLEASVARIABLE String sTableToQuery String sMainTableId String sSubreportTableId String sRelationId
        #IF (!@>109)
        Integer iRet
        Get msg_OnDrilldownUseTableAsVariable sTableToQuery sMainTableId sSubreportTableId sRelationId to iRet
        Procedure_Return iRet
        #ENDIF         
    End_Procedure    
    Procedure OnLL_NTFY_VIEWERDRILLDOWNSTART String sTableId String sKeyField String sKeyValue String sSubreportTableId String sSubreportKeyField String sRelationId String sProjectFileName String sPreviewFileName String sTabText String sTooltipText Handle hWnd Integer hAttachInfo    
        #IF (!@>109)
        Integer iRet iFile iCou iFields iField iMainIndex iCou2 iJobOrg iKeepJobOrg bDoCleanup
        String sFields sVals sVal sField sVal2 sOriginalLabel
        Handle hoDDo hoLabelObj
        RowID rId
        String[] sKeyFields
        String[] sKeyVals
        tDbFile aFile
        
        Send DebugVDFReport "OnLL_NTFY_VIEWERDRILLDOWNSTART"
        
        Get TabSeparatedToStringArray sKeyField to sKeyFields
        Get TabSeparatedToStringArray sKeyValue to sKeyVals
        
        Move (sKeyField+(Character(9))) to sFields
        Move (sKeyValue+(Character(9))) to sVals
        Send DebugVDFReport "OnStartDrilldownReport sTableId:" sTableId "sKeyFields:" (Replaces(Character(9),sFields,"/")) "sKeyVals:" (Replaces(Character(9),sVals,"/")) "sSubreportTableId:" sSubreportTableId "sSubreportKeyField:" sSubreportKeyField "sRelationId:" sRelationId "sProjectFileName:" sProjectFileName "sPreviewFileName:" sPreviewFileName "sTabText:" sTabText "sTooltipText:" sTooltipText
        Get Msg_OnStartDrilldownReport sTableId sKeyFields sKeyVals sSubreportTableId sSubreportKeyField sRelationId sProjectFileName sPreviewFileName sTabText sTooltipText to iRet
        Send DebugVDFReport "OnStartDrilldownReport =" iRet
        If ( (iRet=LL_REPORT_CANCELPRINT) or (iRet=LL_REPORT_EOF) or (iRet=LL_REPORT_SKIPRECORD) or (iRet=LL_REPORT_SKIPTABLE) ) Begin
            Send DebugVDFReport "OnLL_NTFY_VIEWERDRILLDOWNSTART returns 0 after OnStartDrilldownReport"
            Procedure_Return 0
        End
        If (iRet=LL_REPORT_USEDEFAULT) Begin
            Get DDOForTable sTableId to hoDDo
            If (hoDDo=0) Begin
                Send DebugVDFReport "OnLL_NTFY_VIEWERDRILLDOWNSTART returns 0, hoDDo=0"
                Send OnFinishedDrilldownReport sTableId sSubreportTableId sRelationId True
                Procedure_Return 0
            End
            Get Main_File of hoDDo to iFile
            If (iFile=0) Begin
                Send DebugVDFReport "OnLL_NTFY_VIEWERDRILLDOWNSTART returns 0, main_file of hoDDo=0"
                Send OnFinishedDrilldownReport sTableId sSubreportTableId sRelationId True
                Procedure_Return 0
            End
            
            Move -1 to iMainIndex
            Clear iFile
            Get fFileStruct iFile to aFile
            Move aFile.iNumberFields to iFields
            For iCou from 0 to iFields
                Move aFile.aFields[iCou].sName to sVal2
                For iCou2 from 0 to (SizeOfArray(sKeyFields)-1)
                    If (Uppercase(Trim(sKeyFields[iCou2]))=(Uppercase(Trim(sTableId)+"."+(Trim(sVal2))))) Begin
                        If (iMainIndex=-1) Begin
                            Move aFile.aFields[iCou].iIndex to iMainIndex
                        End
                        Set_Field_Value iFile iCou to sKeyVals[iCou2]
                    End
                Loop
            Loop
            If (iMainIndex=-1) Begin
                Send DebugVDFReport "OnLL_NTFY_VIEWERDRILLDOWNSTART returns 0, no Mainindex found"
                Send OnFinishedDrilldownReport sTableId sSubreportTableId sRelationId True
                Procedure_Return 0
            End
            Vfind iFile iMainIndex (EQ) 
            If (FindErr) Begin
                Send DebugVDFReport "OnLL_NTFY_VIEWERDRILLDOWNSTART returns 0, Parent Record not found"
                Send OnFinishedDrilldownReport sTableId sSubreportTableId sRelationId True
                Procedure_Return 0
            End
            Move (GetRowID(iFile)) to rId
            Send FindByRowId to hoDDo iFile rId
            If (FindErr) Begin
                Send DebugVDFReport "OnLL_NTFY_VIEWERDRILLDOWNSTART returns 0, Parent Record not found by RowId"
                Send OnFinishedDrilldownReport sTableId sSubreportTableId sRelationId True
                Procedure_Return 0                
            End
        End
        
        #IFNDEF Is$WebApp
        If (piEmbeddedPreviewObjectInt(Self)<>0) Begin
            If (pbIncrementalPreview(Self)) Begin
                Get Find_Scope of (piEmbeddedPreviewObjectInt(Self)) to hoLabelObj
            End
        End
        If ( (piPreviewPanel(self)<>0) And (piPreviewObject(self)<>0) ) Begin
            If (pbIncrementalPreview(Self)) Begin
                Get object_id of (piPreviewPanel(Self)) to hoLabelObj
            End
        End
        If (hoLabelObj<>0) Begin
            Get Label of hoLabelObj to sOriginalLabel
        End
        #ENDIF
        
        Get pbKeepJobOpen to iKeepJobOrg
        Set pbKeepJobOpen to False
        Move (piJobNumber(Self)) to iJobOrg
        Get LLJobOpen to iRet
        Move (LLSetOptionString(Self,LL_OPTIONSTR_PREVIEWFILENAME,sPreviewFileName)) to iRet
        Move (LLAssociatePreviewControl(Self,hAttachInfo,(LL_ASSOCIATEPREVIEWCONTROLFLAG_DELETE_ON_CLOSE ior LL_ASSOCIATEPREVIEWCONTROLFLAG_HANDLE_IS_ATTACHINFO))) to iRet
        Get LLPrintStart LL_PROJECT_LIST sProjectFileName LL_PRINT_PREVIEW to iRet
        
        If (iRet<>0) Begin
            Send DebugVDFReport "OnLL_NTFY_VIEWERDRILLDOWNSTART returns 0, LLPrintStart returned" iRet
            Get LLPrintEnd to iRet
            get pbDontCleanupOnJobClose to bDoCleanup
            set pbDontCleanupOnJobClose to true
            Get LLJobClose to iRet
            set pbDontCleanupOnJobClose to bDoCleanup
            Set piJobNumber to iJobOrg
            Set pbKeepJobOpen to iKeepJobOrg
            If (iKeepJobOrg) Begin
                Set pbDefinesNeeded to True
            End
            Send OnFinishedDrilldownReport sTableId sSubreportTableId sRelationId True
            #IFNDEF Is$WebApp
            If (hoLabelObj<>0) Begin
                Set Label of hoLabelObj to sOriginalLabel
            End
            #ENDIF
            Procedure_Return 0
        End
    
        Get DoPrintList to iRet
        
        Get LLPrintEnd to iRet
        get pbDontCleanupOnJobClose to bDoCleanup
        set pbDontCleanupOnJobClose to true        
        Get LLJobClose to iRet
        Set pbDontCleanupOnJobClose to bDoCleanup
        
        Set piJobNumber to iJobOrg
        Set pbKeepJobOpen to iKeepJobOrg
        If (iKeepJobOrg) Begin
            Set pbDefinesNeeded to True
        End
        Send OnFinishedDrilldownReport sTableId sSubreportTableId sRelationId False
        #IFNDEF Is$WebApp
        If (hoLabelObj<>0) Begin
            Set Label of hoLabelObj to sOriginalLabel
        End
        #ENDIF
        Send DebugVDFReport "OnLL_NTFY_VIEWERDRILLDOWNSTART returns 1"
        Procedure_Return 1
        #ENDIF
        Procedure_Return 0
    End_Procedure                
    Procedure OnLL_NTFY_VIEWERUSERREQUESTSTART String sProjectFileName String sPreviewFileName Handle hWnd Integer hAttachInfo
        #IF (!@>109)
        Integer iRet iFile iCou iFields iField iMainIndex iCou2 iJobOrg iKeepJobOrg bDoCleanup
        String sFields sVals sVal sField sVal2 sOriginalLabel
        Handle hoDDo hoLabelObj
        RowID rId
        String[] sKeyFields
        String[] sKeyVals
        
        #IFNDEF Is$WebApp
        If (piEmbeddedPreviewObjectInt(Self)<>0) Begin
            If (pbIncrementalPreview(Self)) Begin
                Get Find_Scope of (piEmbeddedPreviewObjectInt(Self)) to hoLabelObj
            End
        End
        If ( (piPreviewPanel(Self)<>0) and (piPreviewObject(Self)<>0) ) Begin
            If (pbIncrementalPreview(Self)) Begin
                Get object_id of (piPreviewPanel(Self)) to hoLabelObj
            End
        End
        If (hoLabelObj<>0) Begin
            Get Label of hoLabelObj to sOriginalLabel
        End
        #ENDIF
        
        Get pbKeepJobOpen to iKeepJobOrg
        Set pbKeepJobOpen to False
        Move (piJobNumber(Self)) to iJobOrg
        Get LLJobOpen to iRet
        Move (LLSetOptionString(Self,LL_OPTIONSTR_PREVIEWFILENAME,sPreviewFileName)) to iRet
        Move (LLAssociatePreviewControl(Self,hAttachInfo,(LL_ASSOCIATEPREVIEWCONTROLFLAG_DELETE_ON_CLOSE ior LL_ASSOCIATEPREVIEWCONTROLFLAG_HANDLE_IS_ATTACHINFO))) to iRet
        Get LLPrintStart LL_PROJECT_LIST sProjectFileName LL_PRINT_PREVIEW to iRet
        
        If (iRet<>0) Begin
            Get LLPrintEnd to iRet
            Get pbDontCleanupOnJobClose to bDoCleanup
            Set pbDontCleanupOnJobClose to True
            Get LLJobClose to iRet
            Set pbDontCleanupOnJobClose to bDoCleanup
            Set piJobNumber to iJobOrg
            Set pbKeepJobOpen to iKeepJobOrg
            If (iKeepJobOrg) Begin
                Set pbDefinesNeeded to True
            End
            #IFNDEF Is$WebApp
            If (hoLabelObj<>0) Begin
                Set Label of hoLabelObj to sOriginalLabel
            End
            #ENDIF
            Procedure_Return 0
        End
    
        Get DoPrintList to iRet
        
        Get LLPrintEnd to iRet
        Get pbDontCleanupOnJobClose to bDoCleanup
        Set pbDontCleanupOnJobClose to True        
        Get LLJobClose to iRet
        Set pbDontCleanupOnJobClose to bDoCleanup
        
        Set piJobNumber to iJobOrg
        Set pbKeepJobOpen to iKeepJobOrg
        If (iKeepJobOrg) Begin
            Set pbDefinesNeeded to True
        End
        #IFNDEF Is$WebApp
        If (hoLabelObj<>0) Begin
            Set Label of hoLabelObj to sOriginalLabel
        End
        #ENDIF
        Procedure_Return 1
        #ENDIF
        Procedure_Return 0
    End_Procedure                    
    Register_Object oLLReportTableSelect
    Procedure DoSelectTable
        #IFNDEF Is$WebApp
        Handle hoPanel hoCombo hoButton
        Integer iCou iDom iRet
        String sVal sTable sVal2 sVal3 sSort sRelation
        Integer bHasRelation
        
        
        
        Get Object_Id of oLLReportTableSelect to hoPanel
        If (hoPanel<>0) Begin
            Set piAssociatedLLObj of hoPanel to (Self)
            Set pbPrivate.TableSelectCancelled to False
            Send Popup to hoPanel
            Procedure_Return
        End
        
        Set pbPrivate.TableSelectCancelled to True
        
        Get create U_ModalPanel to hoPanel
        Get create Of hoPanel U_ComboForm to hoCombo
        Get create Of hoPanel U_Button to hoButton
        #IF (!@ >= 140)
        Set pbSizeToClientArea Of hoPanel to False
        #ENDIF
        Set size Of hoPanel to 53 254
        Set locate_mode Of hoPanel to center_on_screen
        
        Set size Of hoCombo to 13 246
        Set location Of hoCombo to 2 2
        Set entry_state Of hoCombo 0 to false
        
        Set size Of hoButton to 14 51
        Set location Of hoButton to 17 197
        Set label Of hoButton to "Ok"
        Set message Of hoButton to msg_close_panel
        
        Set label Of hoPanel to "Table"
        Send Combo_Delete_Data to hoCombo
        Send combo_add_item to hoCombo " "
        FOR iCou From 0 to (item_count(oTables(self))-1)
            Get value of (oTables(Self)) iCou to sVal
            Move (Left(sVal,(Pos(";",sVal)-1))) to sVal
            Send Combo_add_item to hoCombo sVal
        Loop
        
        Send popup to hoPanel
        Get value Of hoCombo to sTable
        If (trim(sTable)<>"") Begin
            Set label Of hoPanel to "Index"
            Send Combo_Delete_Data to hoCombo
            Send combo_add_item to hoCombo " "
            FOR iCou From 0 to (item_count(oTableSortOrders(self))-1)
                Get value of (oTableSortOrders(Self)) iCou to sVal
                If (uppercase(Left(sVal,(Pos(";",sVal)-1)))=(uppercase(trim(sTable)))) Begin
                    Move (Left(sVal,(Pos(";",sVal)))) to sVal2
                    Move (Replace(sVal2,sVal,"")) to sVal
                    Move (Left(sVal,(Pos(";",sVal)))) to sVal2
                    Move (Replace(sVal2,sVal,"")) to sVal
                    Move (Replace(";",sVal2,"")) to sVal2
                    Send Combo_add_item to hoCombo (sVal2 + "-" + sVal)
                End
            Loop
            Set value Of hoCombo to ""
            Send popup to hoPanel
            Get value Of hoCombo to sSort
            If (trim(sSort)<>"") Begin
                If (Left(sSort,1)="-") Begin
                    Move (Replace("-",sSort,"")) to sSort
                    Move (Left(sSort,(Pos("-",sSort)-1))) to sSort
                    Move ("-"+sSort) to sSort
                End
                Else Begin
                    Move (Left(sSort,(Pos("-",sSort)-1))) to sSort
                End
                Set label Of hoPanel to "Relation"
                Send Combo_Delete_Data to hoCombo
                Send combo_add_item to hoCombo " "
                Move (false) to bHasRelation
                FOR iCou From 0 to (item_count(oTableRelations(self))-1)
                    Get value of (oTableRelations(Self)) iCou to sVal
                    If (uppercase(Left(sVal,(Pos(";",sVal)-1)))=(uppercase(trim(sTable)))) Begin
                        Move (Left(sVal,(Pos(";",sVal)))) to sVal2
                        Move (Replace(sVal2,sVal,"")) to sVal
                        Move (Left(sVal,(Pos(";",sVal)))) to sVal2
                        Move (Replace(sVal2,sVal,"")) to sVal
                        Move (Left(sVal,(Pos(";",sVal)-1))) to sVal
                        Send Combo_add_item to hoCombo sVal
                        Move true to bHasRelation
                    End
                Loop
                If (bHasRelation) Begin
                    Set value Of hoCombo to ""
                    Send popup to hoPanel
                    Get value Of hoCombo to sRelation
                End    
                Set psPrivate.ReportTable to sTable
                Set psPrivate.ReportSortOrder to sSort
                Set psPrivate.ReportRelation to sRelation
                Set piPrivate.SaveTableSettings to 1
                Set pbPrivate.TableSelectCancelled to False
            End
        End
                
        Send destroy to hoButton 
        Send destroy to hoCombo 
        Send destroy to hoPanel   
        #ENDIF
    End_Procedure
    
    Function LLDoExist Handle hoDo Returns Integer
        Integer iCou 
        Handle hoObj
        #IF (!@>109)
        For iCou from 0 to (Item_Count(oDataObjects(Self))-1)
            Get Value of oDataObjects iCou to hoObj
            If (hoObj<>0) Begin
                If (hoObj=hoDo) Begin
                    Function_Return (True)
                End
            End
        Loop
        #ENDIF
        Function_Return (False)
    End_Function
    
    Function LLDoForTable String sName Returns Integer
        Integer iCou 
        Handle hoObj
        
        For iCou from 0 to (Item_Count(oDataObjects(Self))-1)
            Get Value of oDataObjects iCou to hoObj
            If (hoObj<>0) Begin
                If (Uppercase(Trim(psName(hoObj)))=(Uppercase(Trim(sName)))) Begin
                    Function_Return hoObj
                End
            End
        Loop        
        Function_Return 0
    End_Function
    
    Function CreateLLDo String sName Integer bOpt1 Returns Integer
        Integer iCou bAsVariables bIsTTX iPos iType iRet
        Handle hoData hoObj
        String sTTx sLine sVal
        #IF (!@>109)
        String[] sTTxLine
        
        Move (Pos(".TTX",(Uppercase(sName)))) to iPos
        If (iPos<>0) Begin
            Move sName to sTTx
            Move (Left(sName,(iPos-1))) to sName
            While (Pos("\",sName)<>0)
                Move (Right(sName,( (length(sName)) - (Pos("\",sName)) ) )) to sName
            End            
            Move True to bIsTTX
        End
        Get LLDoForTable sName to hoData
        If (num_arguments>1) Begin
            Move bOpt1 to bAsVariables
        End
        Else Begin
            If (piProjectType(Self)=LL_PROJECT_LIST) ;
                Move (False) to bAsVariables
            Else ;
                Move (True) to bAsVariables
        End        
        If (hoData=0) Begin
            Get Create U_cListLabelDataobject to hoData
            Set pbWasCreated of hoData to True
            Set Value of oDataObjects (Item_Count(oDataObjects(Self))) to hoData
        End
        Set psName of hoData to sName
        If (bAsVariables) Begin
            Set pbIsVariable of hoData to True
        End
        Else Begin
            Set pbIsField of hoData to True
        End
        Get LLDbAddTable sName sName to iRet
        If (bIsTTX) Begin
            Direct_Input ("BINARY:"+sTTx)
            Readln sLine
            While (not(SeqEof))
                Move (Trim(sLine)) to sLine
                If ( (Trim(sLine)<>"") and (pos(character(9),sLine)<>0) ) Begin
                    Move (ResizeArray(sTTxLine,0)) to sTTxLine
                    If (Right(sLine,1)<>(Character(9))) ;
                        Move (sLine + (Character(9))) to sLine
                    While (sLine<>"")
                        Move (Left(sLine,(Pos(Character(9),sLine)))) to sVal
                        Move (Replace(sVal,sLine,"")) to sLine
                        Move (Replace((character(9)),sVal,"")) to sVal
                        Move sVal to sTTxLine[(SizeOfArray(sTTxLine))]
                    End
                    If (SizeOfArray(sTTxLine)>=2) Begin
                        Move (Uppercase(Trim(sTTxLine[1]))) to sTTxLine[1]
                        Case Begin
                            Case (sTTxLine[1]="BOOLEAN")
                                Move LL_BOOLEAN to iType
                                Case Break
                            Case (sTTxLine[1]="BYTE")
                                Move LL_NUMERIC_INTEGER to iType
                                Case Break
                            Case (sTTxLine[1]="CURRENCY")
                                Move LL_NUMERIC to iType
                                Case Break
                            Case (sTTxLine[1]="DATE")
                                Move (piDateFormat(Self)) to iType
                                Case Break                                    
                            Case (sTTxLine[1]="LONG")
                                Move LL_NUMERIC to iType
                                Case Break
                            Case (sTTxLine[1]="NUMBER")
                                Move LL_NUMERIC to iType
                                Case Break
                            Case (sTTxLine[1]="SHORT")
                                Move LL_NUMERIC to iType
                                Case Break
                            Case Else
                                Move LL_TEXT to iType    
                                Case Break
                        Case End
                        Move "" to sVal
                        If (SizeOfArray(sTTxLine)>3) Begin
                            Move sTTxLine[3] to sVal
                        End
                        Send DoAddField to hoData sTTxLine[0] iType 0 0 sVal
                    End
                End
                Readln sLine
            Loop
            Close_Input
        End        
        #ENDIF
        
        Function_Return hoData
    End_Function
    
    Procedure AppendLLDoData Integer hoDo Variant[][] vData
        #IF (!@>109)
        Variant[][] vExistingData
        Integer iCou        
        If (not(LLDoExist(Self,hoDo))) ;
            Procedure_Return
        Get pvData of hoDo to vExistingData
        If (SizeOfArray(vExistingData)=0) Begin
            Send DoSetData to hoDo vData
            Procedure_Return
        End
        For iCou from 0 to (SizeOfArray(vData)-1)
            Move vData[iCou] to vExistingData[(SizeOfArray(vExistingData))]
        Loop
        Send DoSetData to hoDo vExistingData
        #ENDIF
    End_Procedure
    Procedure SetLLDoData Integer hoDo Variant[][] vData
        #IF (!@>109)
        Variant[][] vExistingData
        Integer iCou        
        If (not(LLDoExist(Self,hoDo))) ;
            Procedure_Return
        Send DoSetData to hoDo vData
        #ENDIF        
    End_Procedure
    Procedure AttachLLDo String sName Integer hoDo
        #IF (!@>109)
        If (LLDoExist(Self,hoDo)) ;
            Procedure_Return
        Set Value of oDataObjects (Item_Count(oDataObjects(Self))) to hoDo
        #ENDIF
    End_Procedure
    Procedure DetachLLdo Integer hoDo
        #IF (!@>109)
        Integer iCou 
        Handle hoObj
        For iCou from 0 to (Item_Count(oDataObjects(Self))-1)
            Get Value of oDataObjects iCou to hoObj
            If ( (hoObj<>0) and (hoObj=hoDo) ) Begin
                If (pbWasCreated(hoDo)) Begin
                    Send Destroy to hoDo
                End
                Set Value of oDataObjects iCou to 0
            End
        Loop
        #ENDIF
    End_Procedure
    // Helper Functions for using List & Label Reports without DataDictionaries
    
    // DefineRelation
    // Manually defines a Relationship between a Child and a Parent Table
    // Parameters: 
    //              string sChildFields           The Child-Field (or Child-Field-List seperated by ";") 
    //              string sParentFields          The Parent-Field (or Parent-Field-List seperated by ";") 
    // 
    // Example: Send DefineRelation "ChildTable.Field" "ParentTable.Field"
    //          or
    //          Send DefineRelation "ChildTable.Field1;ChildTable.Field2;ChildTable.Field3" "ParentTable.Field1;ParentTable.Field2;ParentTable.Field3"    
    // 
    // Keep in mind that Child- and Parent-Fields must match
    Procedure DefineRelation String sChildFields String sParentFields
        String sChild sParent sChildField sParentField sVal
        Integer iCou iRet iChildCount iParentCount
        
        If (Right(sChildFields,1)<>";") ;
            Move (sChildFields+";") to sChildFields
        If (Right(sParentFields,1)<>";") ;
            Move (sParentFields+";") to sParentFields
        
        While (sChildFields<>"")
            Increment iChildCount
            Move (Left(sChildFields,(Pos(";",sChildFields)))) to sVal
            Move (Replace(sVal,sChildFields,"")) to sChildFields
            Move (Replace(";",sVal,"")) to sVal
            If (pos(".",sVal)=0) Begin
                #IFDEF Is$WebApp
                Error 999 ("Invalid Child Field " +sVal)
                #ELSE
                Send info_box ("Invalid Child Field " +sVal)
                #ENDIF
                Procedure_Return            
            End
            If (sChild="") Begin
                Move (Left(sVal,(Pos(".",sVal)))) to sChild
                Move (Replace(".",sChild,"")) to sChild
            End
            If (uppercase(Left(sVal,(Length(sChild))))<>(Uppercase(sChild))) Begin
                #IFDEF Is$WebApp
                Error 999 ("Invalid Child Field " +sVal)
                #ELSE
                Send info_box ("Invalid Child Field " +sVal)
                #ENDIF
                Procedure_Return                        
            End
            Move (sChildField+sVal+(Character(9))) to sChildField
        Loop
        
        While (sParentFields<>"")
            Increment iParentCount
            Move (Left(sParentFields,(Pos(";",sParentFields)))) to sVal
            Move (Replace(sVal,sParentFields,"")) to sParentFields
            Move (Replace(";",sVal,"")) to sVal
            If (Pos(".",sVal)=0) Begin
                #IFDEF Is$WebApp
                Error 999 ("Invalid Parent Field " +sVal)
                #ELSE
                Send info_box ("Invalid Parent Field " +sVal)
                #ENDIF
                Procedure_Return            
            End
            If (sParent="") Begin
                Move (Left(sVal,(Pos(".",sVal)))) to sParent
                Move (Replace(".",sParent,"")) to sParent
            End
            If (uppercase(Left(sVal,(Length(sParent))))<>(Uppercase(sParent))) Begin
                #IFDEF Is$WebApp
                Error 999 ("Invalid Parent Field " +sVal)
                #ELSE
                Send info_box ("Invalid Parent Field " +sVal)
                #ENDIF
                Procedure_Return                        
            End
            Move (sParentField+sVal+(Character(9))) to sParentField
        Loop
        
        If (iChildCount<>iParentCount) Begin
            #IFDEF Is$WebApp
            Error 999 "Parent and Child Fields must match!"
            #ELSE
            Send info_box "Parent and Child Fields must match!"
            #ENDIF        
            Procedure_Return
        End
        If (pbUseDrilldown(Self)) Begin
            Move (Left(sParentField, (Length(sParentField)-1))) to sParentField
            Move (Left(sChildField,(Length(sChildField)-1))) to sChildField
            Get LLdbAddTableRelationEx sChild sParent (sChild+"->"+sParent) (sChild+"->"+sParent) sChildField sParentField to iRet            
        End
        Else Begin
            Get LLdbAddTableRelation sChild sParent (sChild+"->"+sParent) (sChild+"->"+sParent) to iRet
        End        
    End_Procedure
    
    // DefineFileRelation
    // Defines a Relationship between a Child and a Parent Table based on the File-Definition
    // Parameters: 
    //              integer iFile           File-Number of the Child File
    //              integer iParentFile     File-Number of the Parent File
    // 
    // Example: Send DefineFileRelation Orderdtl.File_Number OrderHea.File_Number
    
    Procedure DefineFileRelation Integer iFile Integer iParentFile
        String sName sParent sParentField sChildField sVal
        Integer iRelatedFile iFields iFieldCou iRelatedField iRet
        tDbFile aFile aParentFile
        
        Get fFileStruct iFile to aFile
        Get fFileStruct iParentFile to aParentFile
        Move aFile.sLogicalName to sName
        Move aParentFile.sLogicalName to sParent
        #IF (!@>109)
        If (pbUseDrilldown(Self)) Begin
            Move "" to sParentField
            Move "" to sChildField
            Move aFile.iNumberFields to iFields
            For iFieldCou from 0 to iFields
                Move aFile.aFields[iFieldCou].iRelatedFile to iRelatedFile
                If (iRelatedFile=iParentFile) Begin
                    Move aFile.aFields[iFieldCou].iRelatedField to iRelatedField
                    Move aFile.aFields[iFieldCou].sName to sVal
                    Move (sChildField + sName + "." + sVal + (Character(9))) to sChildField
                    Move aParentFile.aFields[iRelatedField].sName to sVal
                    Move (sParentField + sParent + "." + sVal + (Character(9))) to sParentField
                End
            Loop
            If ( (sParentField<>"") and (sChildField<>"") ) Begin
                Move (Left(sParentField, (Length(sParentField)-1))) to sParentField
                Move (Left(sChildField,(Length(sChildField)-1))) to sChildField
                Get LLdbAddTableRelationEx sName sParent (sName+"->"+sParent) (sName+"->"+sParent) sChildField sParentField to iRet
            End
            Else Begin
                Get LLdbAddTableRelation sName sParent (sName+"->"+sParent) (sName+"->"+sParent) to iRet
            End
        End
        Else Begin
            Get LLdbAddTableRelation sName sParent (sName+"->"+sParent) (sName+"->"+sParent) to iRet
        End
        #ELSE
        Get LLdbAddTableRelation sName sParent (sName+"->"+sParent) (sName+"->"+sParent) to iRet
        #ENDIF        
    End_Procedure    
    
    // DefineFileStruct
    // Defines a File as a Table in List & Label. All Fields, Indexes and Relations (optional) are defined
    // Parameters: 
    //              integer iFile                  File-Number of File
    //              boolean bWithParentRelation    If True all Parent Files and the Relations are also defined
    // 
    // Example: Send DefineFileStruct Orderdtl.File_Number True // Defines the complete Order-Entry Sample Database
        
    Procedure DefineFileStruct Integer iFile Integer bWithParentRelation 
        String sName sVal sIndex sParent 
        Integer iRet iRecnumTable iFirstIndex iIndexes iIndex iSegments iSegment iField iFields iRelatedFile 
        tDbFile aFile
        
        If (iFile<>0) Begin
            Get fFileStruct iFile to aFile
            Move aFile.sLogicalName to sName
            Get LLDbAddTable sName sName to iRet
            Move aFile.iRecnumTable to iRecnumTable
            If (iRecnumTable=(True)) ;
                Move 0 to iFirstIndex
            Else ;
                Move 1 to iFirstIndex
            Move aFile.iLastIndexNumber to iIndexes
            For iIndex from iFirstIndex to iIndexes
                Move aFile.aIndexes[iIndex].iSegments to iSegments
                If (iSegments<>0) Begin
                    Move "" to sIndex
                    For iSegment from 1 to iSegments
                        Move aFile.aIndexes[iIndex].aSegments[iSegment].iField to iField
                        Move aFile.aFields[iField].sName to sVal
                        If (iSegment=1) ;
                            Move (trim(sVal)) to sIndex
                        Else ;
                            Move (sIndex + ", " + (trim(sVal)) ) to sIndex
                    Loop
                    If (iIndex<>0) Begin
                        Get LLDbAddTableSortOrder sName iIndex (sIndex + " (Up)") to iRet
                        Get LLDbAddTableSortOrder sName (iIndex*-1) (sIndex + " (Down)") to iRet
                    End
                    Else Begin
                        Get LLDbAddTableSortOrder sName iIndex sIndex to iRet
                    End
                End
            Loop
            If (piProjectType(Self)=LL_PROJECT_LIST) Begin
                Get DefineCompleteDB iFile False to iRet
                If (pbIsDrilldown(Self)) Begin
                    If (Uppercase(Trim(sName))=(psDrilldownBaseTable(Self))) Begin
                        Get DefineCompleteDb iFile True to iRet
                    End
                    #IF (!@>109)
                    Get msg_OnDrilldownUseTableAsVariable (Uppercase(Trim(sName))) (psDrilldownBaseTable(Self)) (psDrilldownSubreportTable(Self)) (psDrilldownRelationId(Self)) to iRet
                    If (iRet) Begin
                        Get DefineCompleteDb iFile True to iRet
                    End
                    #ENDIF
                End
            End
            Else Begin
                Get DefineCompleteDB iFile True to iRet
            End
            
            If (bWithParentRelation) Begin
                Move aFile.iNumberFields to iFields
                For iField from 0 to iFields
                    Move aFile.aFields[iField].iRelatedFile to iRelatedFile
                    If (iRelatedFile<>0) Begin
                        Send DefineFileStruct iRelatedFile True
                        Send DefineFileRelation iFile iRelatedFile
                    End
                Loop
            End
        End
    End_Procedure
    
    Function FileNumberFromTableName String sTable Returns Integer
        String sParent
        Integer iFile
        
        While (Pos(".",sTable)<>0)
            Move (Left(sTable,(Pos(".",sTable)))) to sParent
            Move (Replace(sParent,sTable,"")) to sTable
        Loop
        Move (Eval(sTable+".file_number")) to iFile
        Function_Return iFile
    End_Function    
    
    #IF (!@ >= 120)
    { Visibility=Private }
    #ENDIF    
    Procedure LLStartDesignerPreview Integer wParam Integer lParam
        Integer iOriginalJob iOriginalKeepOpen iRet iOriginalEmbeddedPreviewObject iOriginalPreviewPanel iOriginalPreviewObject iOriginalIncremental iMsg
        Integer bExportCanceled
        String sProjectFile
        
        Get piJobNumber to iOriginalJob
        Get pbKeepJobOpen to iOriginalKeepOpen
        Get piEmbeddedPreviewObjectInt to iOriginalEmbeddedPreviewObject
        Get piPreviewObject to iOriginalPreviewObject
        Get piPreviewPanel to iOriginalPreviewPanel
        Get pbIncrementalPreview to iOriginalIncremental
        Set pbKeepJobOpen to False
        Set pbDesignerPreviewRunning to True
        Set piEmbeddedPreviewObjectInt to 0
        Set piPreviewObject to 0
        Set piPreviewPanel to 0
        Set pbIncrementalPreview to True
        Move (LLSetEventEf(phDesignerPreviewhEvent(Self))) to iRet
        Set pbDesignerPreviewAbortRequested to False
        
        Set pbDesignerPreviewRunningOverride to True
        Get LLJobOpen to iRet
        Set pbDesignerPreviewRunningOverride to False
        
        Get LLSetOptionString LL_OPTIONSTR_ORIGINALPROJECTFILENAME (psDesignerPreviewOriginalProjectName(Self)) to iRet
        If (wParam=0) Begin
            Set pbDesignerPreviewRunningOverride to True
            Get LLAssociatePreviewControl (phDesignerPreviewhWnd(Self)) 1 to iRet
            Get LLPrintStart (piProjectType(Self)) (psDesignerPreviewProjectName(Self)) LL_PRINT_PREVIEW to iRet
            Set pbDesignerPreviewRunningOverride to False
        End
        Else Begin
            Set pbDesignerPreviewRunningOverride to True
            Get LLPrintWithBoxStart (piProjectType(Self)) (psDesignerPreviewProjectName(Self)) LL_PRINT_EXPORT LL_BOXTYPE_STDABORT (phDesignerPreviewhWnd(Self)) "Export..." to iRet
            Get LLPrintOptionsDialog (phDesignerPreviewhWnd(Self)) "" to iRet
            Set pbDesignerPreviewRunningOverride to False
            If (iRet=LL_ERR_USER_ABORTED) Begin
                Move True to bExportCanceled
            End
        End
        Get LLPrintSetOption LL_PRNOPT_LASTPAGE (piDesignerPreviewPagesRequested(Self)) to iRet
        
        If (not(bExportCanceled)) Begin
            If (piDesignerPreviewStartMessage(Self)<>0) Begin
                Get piDesignerPreviewStartMessage to iMsg
                Send iMsg
            End
            Else Begin
                Get DoPrintList to iRet
            End
        End
        
        Get LLPrintEnd to iRet
        If (wParam=0) Begin
            Set pbDesignerPreviewRunningOverride to True
            Get LLAssociatePreviewControl 0 1 to iRet
            Set pbDesignerPreviewRunningOverride to False
        End
        Set pbDesignerPreviewRunningOverride to True
        Get LLJobClose to iRet 
        Set pbDesignerPreviewRunningOverride to False
        
        Set pbDesignerPreviewRunning to False
        Set piJobNumber to iOriginalJob
        Set pbKeepJobOpen to iOriginalKeepOpen
        Set piEmbeddedPreviewObjectInt to iOriginalEmbeddedPreviewObject
        Set piPreviewObject to iOriginalPreviewObject
        Set piPreviewPanel to iOriginalPreviewPanel
        Set pbIncrementalPreview to iOriginalIncremental
        Set pbDesignerPreviewAbortRequested to False        
        Move (LLSetEventEf(phDesignerPreviewhEvent(Self))) to iRet
        EraseFile (psDesignerPreviewProjectName(Self))
    End_Procedure    
    
    // And finally the one which start's the complete report :-)
    Function DoPrintList Returns Integer
        Integer iRet 
        Integer hoArray
        String sTable sVal sVal2 sSort sRelation sParent
        
        Get msg_OnStartReport to iRet
        If (iRet=LL_REPORT_CANCELPRINT) Begin        
            Send DebugVDFReport "OnStartReport returned LL_REPORT_CANCELPRINT"
            Function_Return 0
        End
        
        // List-Project: Run a normal Report
        If (piProjectType(Self)=LL_PROJECT_LIST) Begin
            Send delete_data to oCurrentDDos
            Move (LLPrintDbGetCurrentTable(Self,True)) to sTable
            #IF (!@>109)
            If (pbIsDrilldown(Self)) Begin
                Send OnBeforePrintDrilldown (psDrilldownBaseTable(Self)) (psDrilldownSubreportTable(Self)) (psDrilldownRelationId(Self))
            End
            #ENDIF
            Move (DoPrintTable(self,sTable,0)) to iRet
            While (iRet=LL_WRN_TABLECHANGE)
                Move (LLPrintDbGetCurrentTable(Self,True)) to sTable
                If (Trim(sTable)<>"") Begin
                    Move (DoPrintTable(Self,sTable,0)) to iRet
                End
                Else Begin
                    Move 0 to iRet
                End
            End
        End
        // Label or Card Project: 
        Else Begin
            Move (LLPrintGetProjectParameter(self,"VDF.Report.Table",False)) to sTable
            Move (LLPrintGetProjectParameter(self,"VDF.Report.SortOrder",False)) to sSort
            Move (LLPrintGetProjectParameter(self,"VDF.Report.Relation",False)) to sRelation            
            
            If (trim(sTable)="") Begin
                Send DoSelectTable
            End
            Else Begin
                Set psPrivate.ReportTable to sTable
                Set psPrivate.ReportSortOrder to sSort
                Set psPrivate.ReportRelation to sRelation                
            End
            
            Move (trim(psPrivate.ReportTable(self))) to sTable
            
            If (sTable<>"") Begin
                Send delete_data to oCurrentDDos
                Move (Trim(psPrivate.ReportRelation(Self))) to sRelation
                If (Trim(sRelation)="") Begin
                    Set psPrivate.ReportRelationParent to ""   
                    Move (DoPrintTable(Self,sTable,0)) to iRet
                End
                Else Begin
                    Move (Left(sRelation,(Pos("->",sRelation)+1))) to sVal
                    Move (Replace(sVal,sRelation,"")) to sParent
                    Set psPrivate.ReportRelationParent to sParent
                    Move (DoPrintTable(Self,sParent,0)) to iRet
                End
            End
            Else Begin
                Move 0 to iRet
            End
        End
        Send OnFinishedReport
        Function_Return iRet        
    End_Function
    
    #IFDEF Is$WebApp
    Procedure DoRemoveTempWebReport
        String sReport
        Integer iRet
        
        Get psTempExportToRemove to sReport
        If (Trim(sReport)="") ;
            Procedure_Return
        EraseFile sReport
        Set psTempExportToRemove to ""
    End_Procedure    
    
    Function ExportReportForWeb String sProject Returns String
        Integer iProjectType iRet
        String sType sExt sOutputFile sInputPath sError sOutputPath sInputFile sPath sTmp sPart
        
        Send DoRemoveTempWebReport
        
        Move "PDF" to sType
        
        If (Trim(sProject)="") ;
            Function_Return ""
        Move sProject to sInputFile
        File_Exist sProject iRet
        If (iRet) Begin
            Move sProject to sInputFile    
        End
        Else Begin
            Get psDefaultLayoutDirectory to sInputPath
            If (sInputPath<>"") Begin
                File_Exist (sInputPath+"\"+sProject) iRet
                If (iRet) Begin
                    Move (sInputPath+"\"+sProject) to sInputFile     
                End
            End
        End
        Get LLJobOpen to iRet
        Get LLGetOptionString LL_OPTIONSTR_LIST_PRJEXT to sExt
        If (uppercase(Right(sProject,(Length(sExt)+1)))=("."+(Uppercase(sExt)))) Begin
            Move LL_PROJECT_LIST to iProjectType
        End
        Get LLGetOptionString LL_OPTIONSTR_CARD_PRJEXT to sExt
        If (uppercase(Right(sProject,(Length(sExt)+1)))=("."+(Uppercase(sExt)))) Begin
            Move LL_PROJECT_CARD to iProjectType
        End
        Get LLGetOptionString LL_OPTIONSTR_LABEL_PRJEXT to sExt
        If (uppercase(Right(sProject,(Length(sExt)+1)))=("."+(Uppercase(sExt)))) Begin
            Move LL_PROJECT_LABEL to iProjectType
        End
        
        If (iProjectType=0) Begin
            Get LLGetErrorText LL_ERR_CFGNOTFOUND to sError
            Error 999 sError
            Get LLJobClose to iRet
            Function_Return ""
        End
        
        Move (Uppercase(Trim(sType))) to sType
        
        If (sType="PDF") Begin
            Get GetReportsCache of ghoWebApp False to sOutputPath
            Get psSessionKey of ghoWebSessionManager to sOutputFile
            Move (Trim(sOutputFile)+".PDF") to sOutputFile
            Set psTempExportToRemove to (sOutputPath+"\"+sOutputFile)
        End
        If (Trim(sOutputPath)="") Begin
            Get LLJobClose to iRet
            Function_Return ""
        End
        Move (GetFileAttributes(sOutputPath)) to iRet
        If ( (iRet=-1) or ((iRet iand FILE_ATTRIBUTE_DIRECTORY) <> FILE_ATTRIBUTE_DIRECTORY) ) Begin
            Move sOutputPath to sTmp
            While (sTmp<>"")
                If (Pos("\",sTmp)<>0) Begin
                    Move (Left(sTmp,(Pos("\",sTmp)-1))) to sPart
                    Move (Replace(sPart,sTmp,"")) to sTmp
                    Move (Replace("\",sTmp,"")) to sTmp
                    If (sPath<>"") ;
                        Move (sPath+"\") to sPath
                    Move (sPath+sPart) to sPath
                End
                Else Begin
                    Move sOutputPath to sPath
                    Move "" to sTmp
                End
                If (Right(sPath,1)<>":") Begin
                    Move (GetFileAttributes(sPath)) to iRet
                    If ( (iRet=-1) or ((iRet iand FILE_ATTRIBUTE_DIRECTORY) <> FILE_ATTRIBUTE_DIRECTORY) ) Begin
                        Make_Directory sPath
                    End
                End
            Loop
        End
        Move (GetFileAttributes(sOutputPath)) to iRet
        If ( (iRet=-1) or ((iRet iand FILE_ATTRIBUTE_DIRECTORY) <> FILE_ATTRIBUTE_DIRECTORY) ) Begin        
            Get LLJobClose to iRet
            Error DFERR_RAWFILE_ERROR
            Function_Return ""            
        End
        Get LLPrintStart iProjectType sInputFile LL_PRINT_EXPORT to iRet
        If (iRet<>0) Begin
            Get LLGetErrorText iRet to sError
            Get LLPrintEnd to iRet
            Get LLJobClose to iRet
            Error 999 sError
            Function_Return ""
        End
        
        Get LLPrintSetOptionString LL_PRNOPTSTR_EXPORT sType to iRet
        Get LLXSetParameter LL_LLX_EXTENSIONTYPE_EXPORT sType "Export.File" sOutputFile to iRet
        Get LLXSetParameter LL_LLX_EXTENSIONTYPE_EXPORT sType "Export.Path" sOutputPath to iRet
        Get LLXSetParameter LL_LLX_EXTENSIONTYPE_EXPORT sType "Export.Quiet" "1" to iRet
        Get LLXSetParameter LL_LLX_EXTENSIONTYPE_EXPORT sType "Export.ShowResult" "0" to iRet
        
        Get DoPrintList to iRet
        Get LLPrintEnd to iRet            

    	Get LLJobClose to iRet
    	
    	File_Exist (sOutputPath+"\"+sOutputFile) iRet
    	If (iRet) Begin
            Get DownloadURL of ghoWebResourceManager (sOutputPath+"\"+sOutputFile)  to sOutputFile
  	        Function_Return sOutputFile
        End
        Function_Return ""
    End_Function    
    #ENDIF
    
    Procedure Destroy
        #IFDEF Is$WebApp
        Send DoRemoveTempWebReport
        #ENDIF
        Forward Send Destroy
    End_Procedure    
End_Class
